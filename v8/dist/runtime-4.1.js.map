{"version":3,"file":"runtime-4.1.js","sources":["../src/core/attachments/Attachment.ts","../src/core/attachments/BoundingBoxAttachment.ts","../src/core/attachments/ClippingAttachment.ts","../src/core/attachments/MeshAttachment.ts","../src/core/attachments/PathAttachment.ts","../src/core/attachments/PointAttachment.ts","../src/core/attachments/RegionAttachment.ts","../src/core/attachments/Sequence.ts","../src/core/Animation.ts","../src/core/AnimationState.ts","../src/core/AnimationStateData.ts","../src/core/AtlasAttachmentLoader.ts","../src/core/Bone.ts","../src/core/BoneData.ts","../src/core/ConstraintData.ts","../src/core/Event.ts","../src/core/EventData.ts","../src/core/IkConstraint.ts","../src/core/IkConstraintData.ts","../src/core/PathConstraintData.ts","../src/core/PathConstraint.ts","../src/core/Slot.ts","../src/core/TransformConstraint.ts","../src/core/Skeleton.ts","../src/core/SkeletonData.ts","../src/core/SlotData.ts","../src/core/TransformConstraintData.ts","../src/core/Skin.ts","../src/core/SkeletonBinary.ts","../src/core/SkeletonBounds.ts","../src/core/SkeletonJson.ts","../src/Spine.ts"],"sourcesContent":["import { AttachmentType, Utils } from '@pixi-spine/base';\r\nimport type { IAttachment, NumberArrayLike } from '@pixi-spine/base';\r\n\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * The base class for all attachments.\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n\r\n    constructor(name: string) {\r\n        if (!name) throw new Error('name cannot be null.');\r\n        this.name = name;\r\n    }\r\n\r\n    abstract copy(): Attachment;\r\n}\r\n\r\n/**\r\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\r\n * {@link Slot#deform}.\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    /** The unique ID for this attachment. */\r\n    id = VertexAttachment.nextID++;\r\n\r\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\r\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\r\n     * if this attachment has no weights. */\r\n    bones: Array<number> | null = null;\r\n\r\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\r\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\r\n     * each vertex. */\r\n    vertices: NumberArrayLike = [];\r\n\r\n    /** The maximum number of world vertex values that can be output by\r\n     * {@link #computeWorldVertices()} using the `count` parameter. */\r\n    worldVerticesLength = 0;\r\n\r\n    /** Timelines for the timeline attachment are also applied to this attachment.\r\n     * May be null if no attachment-specific timelines should be applied. */\r\n    timelineAttachment: Attachment = this;\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\r\n     * not empty, it is used to deform the vertices.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide.\r\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\r\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\r\n     *           `stride` / 2.\r\n     * @param offset The `worldVertices` index to begin writing values.\r\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        const skeleton = slot.bone.skeleton;\r\n        const deformArray = slot.deform;\r\n        let vertices = this.vertices;\r\n        const bones = this.bones;\r\n\r\n        if (!bones) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            const mat = slot.bone.matrix;\r\n            const x = mat.tx;\r\n            const y = mat.ty;\r\n            const a = mat.a;\r\n            const b = mat.c;\r\n            const c = mat.b;\r\n            const d = mat.d;\r\n\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                const vx = vertices[v];\r\n                const vy = vertices[v + 1];\r\n\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n\r\n            return;\r\n        }\r\n        let v = 0;\r\n        let skip = 0;\r\n\r\n        for (let i = 0; i < start; i += 2) {\r\n            const n = bones[v];\r\n\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        const skeletonBones = skeleton.bones;\r\n\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b];\r\n                    const vy = vertices[b + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            const deform = deformArray;\r\n\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b] + deform[f];\r\n                    const vy = vertices[b + 1] + deform[f + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Does not copy id (generated) or name (set on construction). **/\r\n    copyTo(attachment: VertexAttachment) {\r\n        if (this.bones) {\r\n            attachment.bones = new Array<number>(this.bones.length);\r\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n        } else attachment.bones = null;\r\n\r\n        if (this.vertices) {\r\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n        }\r\n\r\n        attachment.worldVerticesLength = this.worldVerticesLength;\r\n        attachment.timelineAttachment = this.timelineAttachment;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    type = AttachmentType.BoundingBox;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new BoundingBoxAttachment(this.name);\r\n\r\n        this.copyTo(copy);\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\r\nimport type { SlotData } from '../SlotData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\r\n    type = AttachmentType.Clipping;\r\n    /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of\r\n     * the skeleton's rendering. */\r\n    endSlot: SlotData | null = null;\r\n\r\n    // Nonessential.\r\n    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\r\n     * are not usually rendered at runtime. */\r\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new ClippingAttachment(this.name);\r\n\r\n        this.copyTo(copy);\r\n        copy.endSlot = this.endSlot;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, IMeshAttachment, IHasTextureRegion, NumberArrayLike, TextureRegion, Utils } from '@pixi-spine/base';\r\nimport type { Sequence } from './Sequence';\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment, IHasTextureRegion {\r\n    type = AttachmentType.Mesh;\r\n\r\n    region: TextureRegion | null = null;\r\n\r\n    /** The name of the texture region for this attachment. */\r\n    path: string;\r\n\r\n    /** The UV pair for each vertex, normalized within the texture region. */\r\n    regionUVs: Float32Array;\r\n\r\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\r\n    triangles: Array<number> = [];\r\n\r\n    /** The color to tint the mesh. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\r\n    width = 0;\r\n\r\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\r\n    height = 0;\r\n\r\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\r\n    hullLength = 0;\r\n\r\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\r\n     * nonessential data was exported. Triangulation is not performed at runtime. */\r\n    edges: Array<number> = [];\r\n\r\n    private parentMesh: MeshAttachment | null = null;\r\n\r\n    sequence: Sequence | null = null;\r\n\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor(name: string, path: string) {\r\n        super(name);\r\n        this.path = path;\r\n    }\r\n\r\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\r\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\r\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\r\n    getParentMesh() {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh(parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n        }\r\n    }\r\n\r\n    copy(): Attachment {\r\n        if (this.parentMesh) return this.newLinkedMesh();\r\n\r\n        const copy = new MeshAttachment(this.name, this.path);\r\n\r\n        copy.region = this.region;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        this.copyTo(copy);\r\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n        copy.triangles = new Array<number>(this.triangles.length);\r\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n        copy.hullLength = this.hullLength;\r\n\r\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\r\n\r\n        // Nonessential.\r\n        if (this.edges) {\r\n            copy.edges = new Array<number>(this.edges.length);\r\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n        }\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n\r\n        return copy;\r\n    }\r\n\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        if (this.sequence != null) this.sequence.apply(slot, this);\r\n        super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\r\n    }\r\n\r\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\r\n    newLinkedMesh(): MeshAttachment {\r\n        const copy = new MeshAttachment(this.name, this.path);\r\n\r\n        copy.region = this.region;\r\n        copy.color.setFromColor(this.color);\r\n        copy.timelineAttachment = this.timelineAttachment;\r\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\r\n        // if (copy.region != null) copy.updateRegion();\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PathAttachment extends VertexAttachment {\r\n    type = AttachmentType.Path;\r\n\r\n    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\r\n    lengths: Array<number> = [];\r\n\r\n    /** If true, the start and end knots are connected. */\r\n    closed = false;\r\n\r\n    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\r\n     * calculations are performed but calculating positions along the path is less accurate. */\r\n    constantSpeed = false;\r\n\r\n    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\r\n     * rendered at runtime. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new PathAttachment(this.name);\r\n\r\n        this.copyTo(copy);\r\n        copy.lengths = new Array<number>(this.lengths.length);\r\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n        copy.closed = closed;\r\n        copy.constantSpeed = this.constantSpeed;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\r\nimport type { Bone } from '../Bone';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class PointAttachment extends VertexAttachment {\r\n    type = AttachmentType.Point;\r\n\r\n    x = 0;\r\n    y = 0;\r\n    rotation = 0;\r\n\r\n    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\r\n     * are not usually rendered at runtime. */\r\n    color = new Color(0.38, 0.94, 0, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldPosition(bone: Bone, point: Vector2) {\r\n        const mat = bone.matrix;\r\n\r\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n\r\n        return point;\r\n    }\r\n\r\n    computeWorldRotation(bone: Bone) {\r\n        const mat = bone.matrix;\r\n        const cos = MathUtils.cosDeg(this.rotation);\r\n        const sin = MathUtils.sinDeg(this.rotation);\r\n        const x = cos * mat.a + sin * mat.c;\r\n        const y = cos * mat.b + sin * mat.d;\r\n\r\n        return Math.atan2(y, x) * MathUtils.radDeg;\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new PointAttachment(this.name);\r\n\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.rotation = this.rotation;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        return copy;\r\n    }\r\n}\r\n","import { Attachment } from './Attachment';\r\nimport { AttachmentType, NumberArrayLike, Color, TextureRegion, Utils, IHasTextureRegion, IRegionAttachment } from '@pixi-spine/base';\r\nimport type { Sequence } from './Sequence';\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class RegionAttachment extends Attachment implements IRegionAttachment, IHasTextureRegion {\r\n    type = AttachmentType.Region;\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 1;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 1;\r\n\r\n    /** The local rotation. */\r\n    rotation = 0;\r\n\r\n    /** The width of the region attachment in Spine. */\r\n    width = 0;\r\n\r\n    /** The height of the region attachment in Spine. */\r\n    height = 0;\r\n\r\n    /** The color to tint the region attachment. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The name of the texture region for this attachment. */\r\n    path: string;\r\n\r\n    private rendererObject: any = null;\r\n    region: TextureRegion | null = null;\r\n    sequence: Sequence | null = null;\r\n\r\n    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\r\n     *\r\n     * See {@link #updateOffset()}. */\r\n    offset = Utils.newFloatArray(8);\r\n\r\n    uvs = Utils.newFloatArray(8);\r\n\r\n    tempColor = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string, path: string) {\r\n        super(name);\r\n        this.path = path;\r\n    }\r\n\r\n    /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\r\n    updateRegion(): void {\r\n        if (!this.region) throw new Error('Region not set.');\r\n        const region = this.region;\r\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\r\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\r\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\r\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\r\n        const localX2 = localX + this.region.width * regionScaleX;\r\n        const localY2 = localY + this.region.height * regionScaleY;\r\n        const radians = (this.rotation * Math.PI) / 180;\r\n        const cos = Math.cos(radians);\r\n        const sin = Math.sin(radians);\r\n        const x = this.x;\r\n        const y = this.y;\r\n        const localXCos = localX * cos + x;\r\n        const localXSin = localX * sin;\r\n        const localYCos = localY * cos + y;\r\n        const localYSin = localY * sin;\r\n        const localX2Cos = localX2 * cos + x;\r\n        const localX2Sin = localX2 * sin;\r\n        const localY2Cos = localY2 * cos + y;\r\n        const localY2Sin = localY2 * sin;\r\n        const offset = this.offset;\r\n\r\n        offset[0] = localXCos - localYSin;\r\n        offset[1] = localYCos + localXSin;\r\n        offset[2] = localXCos - localY2Sin;\r\n        offset[3] = localY2Cos + localXSin;\r\n        offset[4] = localX2Cos - localY2Sin;\r\n        offset[5] = localY2Cos + localX2Sin;\r\n        offset[6] = localX2Cos - localYSin;\r\n        offset[7] = localYCos + localX2Sin;\r\n\r\n        const uvs = this.uvs;\r\n\r\n        if (region.degrees == 90) {\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v2;\r\n            uvs[4] = region.u;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v;\r\n            uvs[0] = region.u2;\r\n            uvs[1] = region.v2;\r\n        } else {\r\n            uvs[0] = region.u;\r\n            uvs[1] = region.v2;\r\n            uvs[2] = region.u;\r\n            uvs[3] = region.v;\r\n            uvs[4] = region.u2;\r\n            uvs[5] = region.v;\r\n            uvs[6] = region.u2;\r\n            uvs[7] = region.v2;\r\n        }\r\n    }\r\n\r\n    /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may\r\n     * be changed.\r\n     * <p>\r\n     * See <a href=\"http://esotericsoftware.com/spine-runtime-skeletons#World-transforms\">World transforms</a> in the Spine\r\n     * Runtimes Guide.\r\n     * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.\r\n     * @param offset The <code>worldVertices</code> index to begin writing values.\r\n     * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */\r\n    computeWorldVertices(slot: Slot, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        if (this.sequence != null) this.sequence.apply(slot, this);\r\n\r\n        const bone = slot.bone;\r\n        const vertexOffset = this.offset;\r\n        const mat = bone.matrix;\r\n        const x = mat.tx;\r\n        const y = mat.ty;\r\n        const a = mat.a;\r\n        const b = mat.c;\r\n        const c = mat.b;\r\n        const d = mat.d;\r\n        let offsetX = 0;\r\n        let offsetY = 0;\r\n\r\n        offsetX = vertexOffset[0];\r\n        offsetY = vertexOffset[1];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[2];\r\n        offsetY = vertexOffset[3];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[4];\r\n        offsetY = vertexOffset[5];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n        offset += stride;\r\n\r\n        offsetX = vertexOffset[6];\r\n        offsetY = vertexOffset[7];\r\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\r\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n    }\r\n\r\n    copy(): Attachment {\r\n        const copy = new RegionAttachment(this.name, this.path);\r\n\r\n        copy.region = this.region;\r\n        copy.rendererObject = this.rendererObject;\r\n        copy.x = this.x;\r\n        copy.y = this.y;\r\n        copy.scaleX = this.scaleX;\r\n        copy.scaleY = this.scaleY;\r\n        copy.rotation = this.rotation;\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\r\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\r\n        copy.color.setFromColor(this.color);\r\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\r\n\r\n        return copy;\r\n    }\r\n\r\n    static X1 = 0;\r\n    static Y1 = 1;\r\n    static C1R = 2;\r\n    static C1G = 3;\r\n    static C1B = 4;\r\n    static C1A = 5;\r\n    static U1 = 6;\r\n    static V1 = 7;\r\n\r\n    static X2 = 8;\r\n    static Y2 = 9;\r\n    static C2R = 10;\r\n    static C2G = 11;\r\n    static C2B = 12;\r\n    static C2A = 13;\r\n    static U2 = 14;\r\n    static V2 = 15;\r\n\r\n    static X3 = 16;\r\n    static Y3 = 17;\r\n    static C3R = 18;\r\n    static C3G = 19;\r\n    static C3B = 20;\r\n    static C3A = 21;\r\n    static U3 = 22;\r\n    static V3 = 23;\r\n\r\n    static X4 = 24;\r\n    static Y4 = 25;\r\n    static C4R = 26;\r\n    static C4G = 27;\r\n    static C4B = 28;\r\n    static C4A = 29;\r\n    static U4 = 30;\r\n    static V4 = 31;\r\n}\r\n","import { Utils, TextureRegion, IHasTextureRegion, ISequence } from '@pixi-spine/base';\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Sequence implements ISequence {\r\n    private static _nextID = 0;\r\n\r\n    id = Sequence.nextID();\r\n    regions: TextureRegion[];\r\n    start = 0;\r\n    digits = 0;\r\n    /** The index of the region to show for the setup pose. */\r\n    setupIndex = 0;\r\n\r\n    constructor(count: number) {\r\n        this.regions = new Array<TextureRegion>(count);\r\n    }\r\n\r\n    copy(): Sequence {\r\n        const copy = new Sequence(this.regions.length);\r\n\r\n        Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);\r\n        copy.start = this.start;\r\n        copy.digits = this.digits;\r\n        copy.setupIndex = this.setupIndex;\r\n\r\n        return copy;\r\n    }\r\n\r\n    apply(slot: Slot, attachment: IHasTextureRegion) {\r\n        let index = slot.sequenceIndex;\r\n\r\n        if (index == -1) index = this.setupIndex;\r\n        if (index >= this.regions.length) index = this.regions.length - 1;\r\n        const region = this.regions[index];\r\n\r\n        if (attachment.region != region) {\r\n            attachment.region = region;\r\n            // attachment.updateRegion();\r\n        }\r\n    }\r\n\r\n    getPath(basePath: string, index: number): string {\r\n        let result = basePath;\r\n        const frame = (this.start + index).toString();\r\n\r\n        for (let i = this.digits - frame.length; i > 0; i--) result += '0';\r\n        result += frame;\r\n\r\n        return result;\r\n    }\r\n\r\n    private static nextID(): number {\r\n        return Sequence._nextID++;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum SequenceMode {\r\n    hold = 0,\r\n    once = 1,\r\n    loop = 2,\r\n    pingpong = 3,\r\n    onceReverse = 4,\r\n    loopReverse = 5,\r\n    pingpongReverse = 6,\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const SequenceModeValues = [\r\n    SequenceMode.hold,\r\n    SequenceMode.once,\r\n    SequenceMode.loop,\r\n    SequenceMode.pingpong,\r\n    SequenceMode.onceReverse,\r\n    SequenceMode.loopReverse,\r\n    SequenceMode.pingpongReverse,\r\n];\r\n","import type { Event } from './Event';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { Attachment, VertexAttachment } from './attachments';\r\nimport { NumberArrayLike, IAnimation, ITimeline, MathUtils, MixBlend, StringSet, Utils, MixDirection, IHasTextureRegion } from '@pixi-spine/base';\r\nimport type { Slot } from './Slot';\r\nimport type { IkConstraint } from './IkConstraint';\r\nimport type { TransformConstraint } from './TransformConstraint';\r\nimport type { PathConstraint } from './PathConstraint';\r\nimport { SequenceMode, SequenceModeValues } from './attachments/Sequence';\r\n\r\n/**\r\n * A simple container for a list of timelines and a name.\r\n * @public\r\n * */\r\nexport class Animation implements IAnimation<Timeline> {\r\n    /** The animation's name, which is unique across all animations in the skeleton. */\r\n    name: string;\r\n    timelines: Array<Timeline> = [];\r\n    timelineIds: StringSet = new StringSet();\r\n\r\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\r\n    duration: number;\r\n\r\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (!name) throw new Error('name cannot be null.');\r\n        this.name = name;\r\n        this.setTimelines(timelines);\r\n        this.duration = duration;\r\n    }\r\n\r\n    setTimelines(timelines: Array<Timeline>) {\r\n        if (!timelines) throw new Error('timelines cannot be null.');\r\n        this.timelines = timelines;\r\n        this.timelineIds.clear();\r\n        for (let i = 0; i < timelines.length; i++) this.timelineIds.addAll(timelines[i].getPropertyIds());\r\n    }\r\n\r\n    hasTimeline(ids: string[]): boolean {\r\n        for (let i = 0; i < ids.length; i++) if (this.timelineIds.contains(ids[i])) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Applies all the animation's timelines to the specified skeleton.\r\n     *\r\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\r\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\r\n     * @param events May be null to ignore fired events. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        const timelines = this.timelines;\r\n\r\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\r\n    }\r\n}\r\n\r\nconst Property = {\r\n    rotate: 0,\r\n    x: 1,\r\n    y: 2,\r\n    scaleX: 3,\r\n    scaleY: 4,\r\n    shearX: 5,\r\n    shearY: 6,\r\n\r\n    rgb: 7,\r\n    alpha: 8,\r\n    rgb2: 9,\r\n\r\n    attachment: 10,\r\n    deform: 11,\r\n\r\n    event: 12,\r\n    drawOrder: 13,\r\n\r\n    ikConstraint: 14,\r\n    transformConstraint: 15,\r\n\r\n    pathConstraintPosition: 16,\r\n    pathConstraintSpacing: 17,\r\n    pathConstraintMix: 18,\r\n\r\n    sequence: 19,\r\n};\r\n\r\n/** The interface for all timelines.\r\n * @public\r\n * */\r\nexport abstract class Timeline implements ITimeline {\r\n    propertyIds: string[];\r\n    frames: NumberArrayLike;\r\n\r\n    constructor(frameCount: number, propertyIds: string[]) {\r\n        this.propertyIds = propertyIds;\r\n        this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\r\n    }\r\n\r\n    getPropertyIds() {\r\n        return this.propertyIds;\r\n    }\r\n\r\n    getFrameEntries(): number {\r\n        return 1;\r\n    }\r\n\r\n    getFrameCount() {\r\n        return this.frames.length / this.getFrameEntries();\r\n    }\r\n\r\n    getDuration(): number {\r\n        return this.frames[this.frames.length - this.getFrameEntries()];\r\n    }\r\n\r\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection): void;\r\n\r\n    static search1(frames: NumberArrayLike, time: number) {\r\n        const n = frames.length;\r\n\r\n        for (let i = 1; i < n; i++) if (frames[i] > time) return i - 1;\r\n\r\n        return n - 1;\r\n    }\r\n\r\n    static search(frames: NumberArrayLike, time: number, step: number) {\r\n        const n = frames.length;\r\n\r\n        for (let i = step; i < n; i += step) if (frames[i] > time) return i - step;\r\n\r\n        return n - step;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface BoneTimeline {\r\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\r\n    boneIndex: number;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface SlotTimeline {\r\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\r\n    slotIndex: number;\r\n}\r\n\r\n/** The base class for timelines that use interpolation between key frame values.\r\n * @public\r\n * */\r\nexport abstract class CurveTimeline extends Timeline {\r\n    protected curves: NumberArrayLike; // type, x, y, ...\r\n\r\n    constructor(frameCount: number, bezierCount: number, propertyIds: string[]) {\r\n        super(frameCount, propertyIds);\r\n        this.curves = Utils.newFloatArray(frameCount + bezierCount * 18 /* BEZIER_SIZE*/);\r\n        this.curves[frameCount - 1] = 1 /* STEPPED*/;\r\n    }\r\n\r\n    /** Sets the specified key frame to linear interpolation. */\r\n    setLinear(frame: number) {\r\n        this.curves[frame] = 0 /* LINEAR*/;\r\n    }\r\n\r\n    /** Sets the specified key frame to stepped interpolation. */\r\n    setStepped(frame: number) {\r\n        this.curves[frame] = 1 /* STEPPED*/;\r\n    }\r\n\r\n    /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\r\n     * than the actual number of Bezier curves. */\r\n    shrink(bezierCount: number) {\r\n        const size = this.getFrameCount() + bezierCount * 18; /* BEZIER_SIZE*/\r\n\r\n        if (this.curves.length > size) {\r\n            const newCurves = Utils.newFloatArray(size);\r\n\r\n            Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\r\n            this.curves = newCurves;\r\n        }\r\n    }\r\n\r\n    /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\r\n     * one curve per frame.\r\n     * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\r\n     *           in the constructor), inclusive.\r\n     * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\r\n     * @param value The index of the value for this frame that this curve is used for.\r\n     * @param time1 The time for the first key.\r\n     * @param value1 The value for the first key.\r\n     * @param cx1 The time for the first Bezier handle.\r\n     * @param cy1 The value for the first Bezier handle.\r\n     * @param cx2 The time of the second Bezier handle.\r\n     * @param cy2 The value for the second Bezier handle.\r\n     * @param time2 The time for the second key.\r\n     * @param value2 The value for the second key. */\r\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\r\n        const curves = this.curves;\r\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\r\n\r\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\r\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\r\n        const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\r\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\r\n        const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\r\n        let ddx = tmpx * 2 + dddx;\r\n        let ddy = tmpy * 2 + dddy;\r\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\r\n        let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\r\n        let x = time1 + dx;\r\n        let y = value1 + dy;\r\n\r\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dx += ddx;\r\n            dy += ddy;\r\n            ddx += dddx;\r\n            ddy += dddy;\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n    }\r\n\r\n    /** Returns the Bezier interpolated value for the specified time.\r\n     * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\r\n     * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\r\n     * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\r\n    getBezierValue(time: number, frameIndex: number, valueOffset: number, i: number) {\r\n        const curves = this.curves;\r\n\r\n        if (curves[i] > time) {\r\n            const x = this.frames[frameIndex];\r\n            const y = this.frames[frameIndex + valueOffset];\r\n\r\n            return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\r\n        }\r\n        const n = i + 18; /* BEZIER_SIZE*/\r\n\r\n        for (i += 2; i < n; i += 2) {\r\n            if (curves[i] >= time) {\r\n                const x = curves[i - 2];\r\n                const y = curves[i - 1];\r\n\r\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\r\n            }\r\n        }\r\n        frameIndex += this.getFrameEntries();\r\n        const x = curves[n - 2];\r\n        const y = curves[n - 1];\r\n\r\n        return y + ((time - x) / (this.frames[frameIndex] - x)) * (this.frames[frameIndex + valueOffset] - y);\r\n    }\r\n}\r\n/**\r\n * @public\r\n */\r\nexport abstract class CurveTimeline1 extends CurveTimeline {\r\n    constructor(frameCount: number, bezierCount: number, propertyId: string) {\r\n        super(frameCount, bezierCount, [propertyId]);\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 2 /* ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time and value for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time The frame time in seconds. */\r\n    setFrame(frame: number, time: number, value: number) {\r\n        frame <<= 1;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1 /* VALUE*/] = value;\r\n    }\r\n\r\n    /** Returns the interpolated value for the specified time. */\r\n    getCurveValue(time: number) {\r\n        const frames = this.frames;\r\n        let i = frames.length - 2;\r\n\r\n        for (let ii = 2; ii <= i; ii += 2) {\r\n            if (frames[ii] > time) {\r\n                i = ii - 2;\r\n                break;\r\n            }\r\n        }\r\n\r\n        const curveType = this.curves[i >> 1];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n                const value = frames[i + 1 /* VALUE*/];\r\n\r\n                return value + ((time - before) / (frames[i + 2 /* ENTRIES*/] - before)) * (frames[i + 2 /* ENTRIES*/ + 1 /* VALUE*/] - value);\r\n            case 1 /* STEPPED*/:\r\n                return frames[i + 1 /* VALUE*/];\r\n        }\r\n\r\n        return this.getBezierValue(time, i, 1 /* VALUE*/, curveType - 2 /* BEZIER*/);\r\n    }\r\n}\r\n\r\n/** The base class for a {@link CurveTimeline} which sets two properties.\r\n * @public\r\n * */\r\nexport abstract class CurveTimeline2 extends CurveTimeline {\r\n    /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\r\n     * @param propertyIds Unique identifiers for the properties the timeline modifies. */\r\n    constructor(frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\r\n        super(frameCount, bezierCount, [propertyId1, propertyId2]);\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 3 /* ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time and values for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time The frame time in seconds. */\r\n    setFrame(frame: number, time: number, value1: number, value2: number) {\r\n        frame *= 3 /* ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1 /* VALUE1*/] = value1;\r\n        this.frames[frame + 2 /* VALUE2*/] = value2;\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#rotation}.\r\n * @public\r\n * */\r\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = this.getCurveValue(time);\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.rotation = bone.data.rotation + r * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                r += bone.data.rotation - bone.rotation;\r\n            case MixBlend.add:\r\n                bone.rotation += r * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}.\r\n * @public\r\n * */\r\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n                    bone.y = bone.data.y;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\r\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                x = frames[i + 1 /* VALUE1*/];\r\n                y = frames[i + 2 /* VALUE2*/];\r\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\r\n\r\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\r\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                x = frames[i + 1 /* VALUE1*/];\r\n                y = frames[i + 2 /* VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n        }\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\r\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.x = bone.data.x;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.x += (bone.data.x - bone.x) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const x = this.getCurveValue(time);\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.x = bone.data.x + x * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.x += (bone.data.x + x - bone.x) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.x += x * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#x}.\r\n * @public\r\n * */\r\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.y = bone.data.y;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.y += (bone.data.y - bone.y) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const y = this.getCurveValue(time);\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.y = bone.data.y + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.y += (bone.data.y + y - bone.y) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.y += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n                    bone.scaleY = bone.data.scaleY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x;\r\n        let y;\r\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\r\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                x = frames[i + 1 /* VALUE1*/];\r\n                y = frames[i + 2 /* VALUE2*/];\r\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\r\n\r\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\r\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                x = frames[i + 1 /* VALUE1*/];\r\n                y = frames[i + 2 /* VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n        }\r\n        x *= bone.data.scaleX;\r\n        y *= bone.data.scaleY;\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                bone.scaleX += x - bone.data.scaleX;\r\n                bone.scaleY += y - bone.data.scaleY;\r\n            } else {\r\n                bone.scaleX = x;\r\n                bone.scaleY = y;\r\n            }\r\n        } else {\r\n            let bx = 0;\r\n            let by = 0;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        by = bone.scaleY;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleX = bone.data.scaleX;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const x = this.getCurveValue(time) * bone.data.scaleX;\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) bone.scaleX += x - bone.data.scaleX;\r\n            else bone.scaleX = x;\r\n        } else {\r\n            // Mixing out uses sign of setup or current pose, else use sign of key.\r\n            let bx = 0;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = bone.data.scaleX;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = bone.scaleX;\r\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\r\n                        bone.scaleX = bx + (x - bx) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\r\n * @public\r\n * */\r\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.scaleY = bone.data.scaleY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const y = this.getCurveValue(time) * bone.data.scaleY;\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) bone.scaleY += y - bone.data.scaleY;\r\n            else bone.scaleY = y;\r\n        } else {\r\n            // Mixing out uses sign of setup or current pose, else use sign of key.\r\n            let by = 0;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        by = bone.data.scaleY;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        by = bone.scaleY;\r\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup:\r\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\r\n                        bone.scaleY = by + (y - by) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n                    bone.shearY = bone.data.shearY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let x = 0;\r\n        let y = 0;\r\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\r\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                x = frames[i + 1 /* VALUE1*/];\r\n                y = frames[i + 2 /* VALUE2*/];\r\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\r\n\r\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\r\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                x = frames[i + 1 /* VALUE1*/];\r\n                y = frames[i + 2 /* VALUE2*/];\r\n                break;\r\n            default:\r\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\r\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n        }\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearX = bone.data.shearX;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const x = this.getCurveValue(time);\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearX = bone.data.shearX + x * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearX += x * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\r\n    boneIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);\r\n        this.boneIndex = boneIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.shearY = bone.data.shearY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const y = this.getCurveValue(time);\r\n\r\n        switch (blend) {\r\n            case MixBlend.setup:\r\n                bone.shearY = bone.data.shearY + y * alpha;\r\n                break;\r\n            case MixBlend.first:\r\n            case MixBlend.replace:\r\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n                break;\r\n            case MixBlend.add:\r\n                bone.shearY += y * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\r\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 5 /* ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number) {\r\n        frame *= 5 /* ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1 /* R*/] = r;\r\n        this.frames[frame + 2 /* G*/] = g;\r\n        this.frames[frame + 3 /* B*/] = b;\r\n        this.frames[frame + 4 /* A*/] = a;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        const frames = this.frames;\r\n        const color = slot.color;\r\n\r\n        if (time < frames[0]) {\r\n            const setup = slot.data.color;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.setFromColor(setup);\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n        const i = Timeline.search(frames, time, 5 /* ENTRIES*/);\r\n        const curveType = this.curves[i / 5 /* ENTRIES*/];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                a = frames[i + 4 /* A*/];\r\n                const t = (time - before) / (frames[i + 5 /* ENTRIES*/] - before);\r\n\r\n                r += (frames[i + 5 /* ENTRIES*/ + 1 /* R*/] - r) * t;\r\n                g += (frames[i + 5 /* ENTRIES*/ + 2 /* G*/] - g) * t;\r\n                b += (frames[i + 5 /* ENTRIES*/ + 3 /* B*/] - b) * t;\r\n                a += (frames[i + 5 /* ENTRIES*/ + 4 /* A*/] - a) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                a = frames[i + 4 /* A*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\r\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\r\n        }\r\n        if (alpha == 1) color.set(r, g, b, a);\r\n        else {\r\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color}.\r\n * @public\r\n * */\r\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 4 /* ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\r\n    setFrame(frame: number, time: number, r: number, g: number, b: number) {\r\n        frame <<= 2;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1 /* R*/] = r;\r\n        this.frames[frame + 2 /* G*/] = g;\r\n        this.frames[frame + 3 /* B*/] = b;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        const frames = this.frames;\r\n        const color = slot.color;\r\n\r\n        if (time < frames[0]) {\r\n            const setup = slot.data.color;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.r = setup.r;\r\n                    color.g = setup.g;\r\n                    color.b = setup.b;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.r += (setup.r - color.r) * alpha;\r\n                    color.g += (setup.g - color.g) * alpha;\r\n                    color.b += (setup.b - color.b) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\r\n        const curveType = this.curves[i >> 2];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\r\n\r\n                r += (frames[i + 4 /* ENTRIES*/ + 1 /* R*/] - r) * t;\r\n                g += (frames[i + 4 /* ENTRIES*/ + 2 /* G*/] - g) * t;\r\n                b += (frames[i + 4 /* ENTRIES*/ + 3 /* B*/] - b) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\r\n        }\r\n        if (alpha == 1) {\r\n            color.r = r;\r\n            color.g = g;\r\n            color.b = b;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                const setup = slot.data.color;\r\n\r\n                color.r = setup.r;\r\n                color.g = setup.g;\r\n                color.b = setup.b;\r\n            }\r\n            color.r += (r - color.r) * alpha;\r\n            color.g += (g - color.g) * alpha;\r\n            color.b += (b - color.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\r\n * @public\r\n * */\r\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        const color = slot.color;\r\n\r\n        if (time < this.frames[0]) {\r\n            // Time is before first frame.\r\n            const setup = slot.data.color;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    color.a = setup.a;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    color.a += (setup.a - color.a) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const a = this.getCurveValue(time);\r\n\r\n        if (alpha == 1) color.a = a;\r\n        else {\r\n            if (blend == MixBlend.setup) color.a = slot.data.color.a;\r\n            color.a += (a - color.a) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\r\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 8 /* ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\r\n        frame <<= 3;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1 /* R*/] = r;\r\n        this.frames[frame + 2 /* G*/] = g;\r\n        this.frames[frame + 3 /* B*/] = b;\r\n        this.frames[frame + 4 /* A*/] = a;\r\n        this.frames[frame + 5 /* R2*/] = r2;\r\n        this.frames[frame + 6 /* G2*/] = g2;\r\n        this.frames[frame + 7 /* B2*/] = b2;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        const frames = this.frames;\r\n        const light = slot.color;\r\n        const dark = slot.darkColor;\r\n\r\n        if (time < frames[0]) {\r\n            const setupLight = slot.data.color;\r\n            const setupDark = slot.data.darkColor;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    light.setFromColor(setupLight);\r\n                    dark.r = setupDark.r;\r\n                    dark.g = setupDark.g;\r\n                    dark.b = setupDark.b;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n                    dark.r += (setupDark.r - dark.r) * alpha;\r\n                    dark.g += (setupDark.g - dark.g) * alpha;\r\n                    dark.b += (setupDark.b - dark.b) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let a = 0;\r\n        let r2 = 0;\r\n        let g2 = 0;\r\n        let b2 = 0;\r\n        const i = Timeline.search(frames, time, 8 /* ENTRIES*/);\r\n        const curveType = this.curves[i >> 3];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                a = frames[i + 4 /* A*/];\r\n                r2 = frames[i + 5 /* R2*/];\r\n                g2 = frames[i + 6 /* G2*/];\r\n                b2 = frames[i + 7 /* B2*/];\r\n                const t = (time - before) / (frames[i + 8 /* ENTRIES*/] - before);\r\n\r\n                r += (frames[i + 8 /* ENTRIES*/ + 1 /* R*/] - r) * t;\r\n                g += (frames[i + 8 /* ENTRIES*/ + 2 /* G*/] - g) * t;\r\n                b += (frames[i + 8 /* ENTRIES*/ + 3 /* B*/] - b) * t;\r\n                a += (frames[i + 8 /* ENTRIES*/ + 4 /* A*/] - a) * t;\r\n                r2 += (frames[i + 8 /* ENTRIES*/ + 5 /* R2*/] - r2) * t;\r\n                g2 += (frames[i + 8 /* ENTRIES*/ + 6 /* G2*/] - g2) * t;\r\n                b2 += (frames[i + 8 /* ENTRIES*/ + 7 /* B2*/] - b2) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                a = frames[i + 4 /* A*/];\r\n                r2 = frames[i + 5 /* R2*/];\r\n                g2 = frames[i + 6 /* G2*/];\r\n                b2 = frames[i + 7 /* B2*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\r\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\r\n                r2 = this.getBezierValue(time, i, 5 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\r\n                g2 = this.getBezierValue(time, i, 6 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\r\n                b2 = this.getBezierValue(time, i, 7 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 6 - 2 /* BEZIER*/);\r\n        }\r\n\r\n        if (alpha == 1) {\r\n            light.set(r, g, b, a);\r\n            dark.r = r2;\r\n            dark.g = g2;\r\n            dark.b = b2;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                light.setFromColor(slot.data.color);\r\n                const setupDark = slot.data.darkColor;\r\n\r\n                dark.r = setupDark.r;\r\n                dark.g = setupDark.g;\r\n                dark.b = setupDark.b;\r\n            }\r\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n            dark.r += (r2 - dark.r) * alpha;\r\n            dark.g += (g2 - dark.g) * alpha;\r\n            dark.b += (b2 - dark.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\r\n * @public\r\n * */\r\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\r\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\r\n        this.slotIndex = slotIndex;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 7 /* ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\r\n    setFrame(frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\r\n        frame *= 7 /* ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1 /* R*/] = r;\r\n        this.frames[frame + 2 /* G*/] = g;\r\n        this.frames[frame + 3 /* B*/] = b;\r\n        this.frames[frame + 4 /* R2*/] = r2;\r\n        this.frames[frame + 5 /* G2*/] = g2;\r\n        this.frames[frame + 6 /* B2*/] = b2;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        const frames = this.frames;\r\n        const light = slot.color;\r\n        const dark = slot.darkColor;\r\n\r\n        if (time < frames[0]) {\r\n            const setupLight = slot.data.color;\r\n            const setupDark = slot.data.darkColor;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    light.r = setupLight.r;\r\n                    light.g = setupLight.g;\r\n                    light.b = setupLight.b;\r\n                    dark.r = setupDark.r;\r\n                    dark.g = setupDark.g;\r\n                    dark.b = setupDark.b;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    light.r += (setupLight.r - light.r) * alpha;\r\n                    light.g += (setupLight.g - light.g) * alpha;\r\n                    light.b += (setupLight.b - light.b) * alpha;\r\n                    dark.r += (setupDark.r - dark.r) * alpha;\r\n                    dark.g += (setupDark.g - dark.g) * alpha;\r\n                    dark.b += (setupDark.b - dark.b) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        let r2 = 0;\r\n        let g2 = 0;\r\n        let b2 = 0;\r\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\r\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                r2 = frames[i + 4 /* R2*/];\r\n                g2 = frames[i + 5 /* G2*/];\r\n                b2 = frames[i + 6 /* B2*/];\r\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\r\n\r\n                r += (frames[i + 7 /* ENTRIES*/ + 1 /* R*/] - r) * t;\r\n                g += (frames[i + 7 /* ENTRIES*/ + 2 /* G*/] - g) * t;\r\n                b += (frames[i + 7 /* ENTRIES*/ + 3 /* B*/] - b) * t;\r\n                r2 += (frames[i + 7 /* ENTRIES*/ + 4 /* R2*/] - r2) * t;\r\n                g2 += (frames[i + 7 /* ENTRIES*/ + 5 /* G2*/] - g2) * t;\r\n                b2 += (frames[i + 7 /* ENTRIES*/ + 6 /* B2*/] - b2) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                r = frames[i + 1 /* R*/];\r\n                g = frames[i + 2 /* G*/];\r\n                b = frames[i + 3 /* B*/];\r\n                r2 = frames[i + 4 /* R2*/];\r\n                g2 = frames[i + 5 /* G2*/];\r\n                b2 = frames[i + 6 /* B2*/];\r\n                break;\r\n            default:\r\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\r\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\r\n                r2 = this.getBezierValue(time, i, 4 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\r\n                g2 = this.getBezierValue(time, i, 5 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\r\n                b2 = this.getBezierValue(time, i, 6 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\r\n        }\r\n\r\n        if (alpha == 1) {\r\n            light.r = r;\r\n            light.g = g;\r\n            light.b = b;\r\n            dark.r = r2;\r\n            dark.g = g2;\r\n            dark.b = b2;\r\n        } else {\r\n            if (blend == MixBlend.setup) {\r\n                const setupLight = slot.data.color;\r\n                const setupDark = slot.data.darkColor;\r\n\r\n                light.r = setupLight.r;\r\n                light.g = setupLight.g;\r\n                light.b = setupLight.b;\r\n                dark.r = setupDark.r;\r\n                dark.g = setupDark.g;\r\n                dark.b = setupDark.b;\r\n            }\r\n            light.r += (r - light.r) * alpha;\r\n            light.g += (g - light.g) * alpha;\r\n            light.b += (b - light.b) * alpha;\r\n            dark.r += (r2 - dark.r) * alpha;\r\n            dark.g += (g2 - dark.g) * alpha;\r\n            dark.b += (b2 - dark.b) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#attachment}.\r\n * @public\r\n * */\r\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\r\n    attachmentNames: Array<string | null>;\r\n\r\n    constructor(frameCount: number, slotIndex: number) {\r\n        super(frameCount, [`${Property.attachment}|${slotIndex}`]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\r\n    setFrame(frame: number, time: number, attachmentName: string | null) {\r\n        this.frames[frame] = time;\r\n        this.attachmentNames[frame] = attachmentName;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        if (time < this.frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\r\n\r\n            return;\r\n        }\r\n\r\n        this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null) {\r\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}.\r\n * @public\r\n * */\r\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\r\n    slotIndex = 0;\r\n\r\n    /** The attachment that will be deformed. */\r\n    attachment: VertexAttachment;\r\n\r\n    /** The vertices for each key frame. */\r\n    vertices: Array<NumberArrayLike>;\r\n\r\n    constructor(frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\r\n        super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachment = attachment;\r\n        this.vertices = new Array<NumberArrayLike>(frameCount);\r\n    }\r\n\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the vertices for the specified key frame.\r\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\r\n    setFrame(frame: number, time: number, vertices: NumberArrayLike) {\r\n        this.frames[frame] = time;\r\n        this.vertices[frame] = vertices;\r\n    }\r\n\r\n    /** @param value1 Ignored (0 is used for a deform timeline).\r\n     * @param value2 Ignored (1 is used for a deform timeline). */\r\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\r\n        const curves = this.curves;\r\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\r\n\r\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\r\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\r\n        const tmpy = cy2 * 0.03 - cy1 * 0.06;\r\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\r\n        const dddy = (cy1 - cy2 + 0.33333333) * 0.018;\r\n        let ddx = tmpx * 2 + dddx;\r\n        let ddy = tmpy * 2 + dddy;\r\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\r\n        let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\r\n        let x = time1 + dx;\r\n        let y = dy;\r\n\r\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dx += ddx;\r\n            dy += ddy;\r\n            ddx += dddx;\r\n            ddy += dddy;\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n    }\r\n\r\n    getCurvePercent(time: number, frame: number) {\r\n        const curves = this.curves;\r\n        let i = curves[frame];\r\n\r\n        switch (i) {\r\n            case 0 /* LINEAR*/:\r\n                const x = this.frames[frame];\r\n\r\n                return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\r\n            case 1 /* STEPPED*/:\r\n                return 0;\r\n        }\r\n        i -= 2 /* BEZIER*/;\r\n        if (curves[i] > time) {\r\n            const x = this.frames[frame];\r\n\r\n            return (curves[i + 1] * (time - x)) / (curves[i] - x);\r\n        }\r\n        const n = i + 18; /* BEZIER_SIZE*/\r\n\r\n        for (i += 2; i < n; i += 2) {\r\n            if (curves[i] >= time) {\r\n                const x = curves[i - 2];\r\n                const y = curves[i - 1];\r\n\r\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\r\n            }\r\n        }\r\n        const x = curves[n - 2];\r\n        const y = curves[n - 1];\r\n\r\n        return y + ((1 - y) * (time - x)) / (this.frames[frame + this.getFrameEntries()] - x);\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot: Slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const slotAttachment: Attachment | null = slot.getAttachment();\r\n\r\n        if (!slotAttachment) return;\r\n        if (!(slotAttachment instanceof VertexAttachment) || (<VertexAttachment>slotAttachment).timelineAttachment != this.attachment) return;\r\n\r\n        const deform: Array<number> = slot.deform;\r\n\r\n        if (deform.length == 0) blend = MixBlend.setup;\r\n\r\n        const vertices = this.vertices;\r\n        const vertexCount = vertices[0].length;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    deform.length = 0;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    if (alpha == 1) {\r\n                        deform.length = 0;\r\n\r\n                        return;\r\n                    }\r\n                    deform.length = vertexCount;\r\n                    const vertexAttachment = <VertexAttachment>slotAttachment;\r\n\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\r\n                    } else {\r\n                        // Weighted deform offsets.\r\n                        alpha = 1 - alpha;\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\r\n                    }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        deform.length = vertexCount;\r\n        if (time >= frames[frames.length - 1]) {\r\n            // Time is after last frame.\r\n            const lastVertices = vertices[frames.length - 1];\r\n\r\n            if (alpha == 1) {\r\n                if (blend == MixBlend.add) {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] - setupVertices[i];\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\r\n                    }\r\n                } else Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\r\n            } else {\r\n                switch (blend) {\r\n                    case MixBlend.setup: {\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (!vertexAttachment.bones) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                const setup = setupVertices[i];\r\n\r\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\r\n                            }\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MixBlend.first:\r\n                    case MixBlend.replace:\r\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\r\n                        break;\r\n                    case MixBlend.add:\r\n                        const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                        if (!vertexAttachment.bones) {\r\n                            // Unweighted vertex positions, with alpha.\r\n                            const setupVertices = vertexAttachment.vertices;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\r\n                        } else {\r\n                            // Weighted deform offsets, with alpha.\r\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\r\n                        }\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        const frame = Timeline.search1(frames, time);\r\n        const percent = this.getCurvePercent(time, frame);\r\n        const prevVertices = vertices[frame];\r\n        const nextVertices = vertices[frame + 1];\r\n\r\n        if (alpha == 1) {\r\n            if (blend == MixBlend.add) {\r\n                const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                if (!vertexAttachment.bones) {\r\n                    // Unweighted vertex positions, with alpha.\r\n                    const setupVertices = vertexAttachment.vertices;\r\n\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\r\n                    }\r\n                } else {\r\n                    // Weighted deform offsets, with alpha.\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0; i < vertexCount; i++) {\r\n                    const prev = prevVertices[i];\r\n\r\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\r\n                }\r\n            }\r\n        } else {\r\n            switch (blend) {\r\n                case MixBlend.setup: {\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n                            const setup = setupVertices[i];\r\n\r\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case MixBlend.first:\r\n                case MixBlend.replace:\r\n                    for (let i = 0; i < vertexCount; i++) {\r\n                        const prev = prevVertices[i];\r\n\r\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\r\n                    }\r\n                    break;\r\n                case MixBlend.add:\r\n                    const vertexAttachment = slotAttachment as VertexAttachment;\r\n\r\n                    if (!vertexAttachment.bones) {\r\n                        // Unweighted vertex positions, with alpha.\r\n                        const setupVertices = vertexAttachment.vertices;\r\n\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\r\n                        }\r\n                    } else {\r\n                        // Weighted deform offsets, with alpha.\r\n                        for (let i = 0; i < vertexCount; i++) {\r\n                            const prev = prevVertices[i];\r\n\r\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Fires an {@link Event} when specific animation times are reached.\r\n * @public\r\n * */\r\nexport class EventTimeline extends Timeline {\r\n    static propertyIds = [`${Property.event}`];\r\n\r\n    /** The event for each key frame. */\r\n    events: Array<Event>;\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount, EventTimeline.propertyIds);\r\n\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the event for the specified key frame. */\r\n    setFrame(frame: number, event: Event) {\r\n        this.frames[frame] = event.time;\r\n        this.events[frame] = event;\r\n    }\r\n\r\n    /** Fires events for frames > `lastTime` and <= `time`. */\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (!firedEvents) return;\r\n\r\n        const frames = this.frames;\r\n        const frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) {\r\n            // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1])\r\n            // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let i = 0;\r\n\r\n        if (lastTime < frames[0]) i = 0;\r\n        else {\r\n            i = Timeline.search1(frames, lastTime) + 1;\r\n            const frameTime = frames[i];\r\n\r\n            while (i > 0) {\r\n                // Fire multiple events with the same frame.\r\n                if (frames[i - 1] != frameTime) break;\r\n                i--;\r\n            }\r\n        }\r\n        for (; i < frameCount && time >= frames[i]; i++) firedEvents.push(this.events[i]);\r\n    }\r\n}\r\n\r\n/** Changes a skeleton's {@link Skeleton#drawOrder}.\r\n * @public\r\n * */\r\nexport class DrawOrderTimeline extends Timeline {\r\n    static propertyIds = [`${Property.drawOrder}`];\r\n\r\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\r\n    drawOrders: Array<Array<number> | null>;\r\n\r\n    constructor(frameCount: number) {\r\n        super(frameCount, DrawOrderTimeline.propertyIds);\r\n        this.drawOrders = new Array<Array<number> | null>(frameCount);\r\n    }\r\n\r\n    getFrameCount() {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time in seconds and the draw order for the specified key frame.\r\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\r\n     *           draw order. */\r\n    setFrame(frame: number, time: number, drawOrder: Array<number> | null) {\r\n        this.frames[frame] = time;\r\n        this.drawOrders[frame] = drawOrder;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        if (direction == MixDirection.mixOut) {\r\n            if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        if (time < this.frames[0]) {\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\r\n            return;\r\n        }\r\n\r\n        const idx = Timeline.search1(this.frames, time);\r\n        const drawOrderToSetupIndex = this.drawOrders[idx];\r\n\r\n        if (!drawOrderToSetupIndex) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n        else {\r\n            const drawOrder: Array<Slot> = skeleton.drawOrder;\r\n            const slots: Array<Slot> = skeleton.slots;\r\n\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\r\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}.\r\n * @public\r\n * */\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\r\n    ikConstraintIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, ikConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);\r\n        this.ikConstraintIndex = ikConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 6 /* ENTRIES*/;\r\n    }\r\n\r\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\r\n    setFrame(frame: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\r\n        frame *= 6 /* ENTRIES*/;\r\n        this.frames[frame] = time;\r\n        this.frames[frame + 1 /* MIX*/] = mix;\r\n        this.frames[frame + 2 /* SOFTNESS*/] = softness;\r\n        this.frames[frame + 3 /* BEND_DIRECTION*/] = bendDirection;\r\n        this.frames[frame + 4 /* COMPRESS*/] = compress ? 1 : 0;\r\n        this.frames[frame + 5 /* STRETCH*/] = stretch ? 1 : 0;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mix = constraint.data.mix;\r\n                    constraint.softness = constraint.data.softness;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\r\n                    constraint.bendDirection = constraint.data.bendDirection;\r\n                    constraint.compress = constraint.data.compress;\r\n                    constraint.stretch = constraint.data.stretch;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let mix = 0;\r\n        let softness = 0;\r\n        const i = Timeline.search(frames, time, 6 /* ENTRIES*/);\r\n        const curveType = this.curves[i / 6 /* ENTRIES*/];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                mix = frames[i + 1 /* MIX*/];\r\n                softness = frames[i + 2 /* SOFTNESS*/];\r\n                const t = (time - before) / (frames[i + 6 /* ENTRIES*/] - before);\r\n\r\n                mix += (frames[i + 6 /* ENTRIES*/ + 1 /* MIX*/] - mix) * t;\r\n                softness += (frames[i + 6 /* ENTRIES*/ + 2 /* SOFTNESS*/] - softness) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                mix = frames[i + 1 /* MIX*/];\r\n                softness = frames[i + 2 /* SOFTNESS*/];\r\n                break;\r\n            default:\r\n                mix = this.getBezierValue(time, i, 1 /* MIX*/, curveType - 2 /* BEZIER*/);\r\n                softness = this.getBezierValue(time, i, 2 /* SOFTNESS*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\r\n            constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\r\n\r\n            if (direction == MixDirection.mixOut) {\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            } else {\r\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\r\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\r\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\r\n            }\r\n        } else {\r\n            constraint.mix += (mix - constraint.mix) * alpha;\r\n            constraint.softness += (softness - constraint.softness) * alpha;\r\n            if (direction == MixDirection.mixIn) {\r\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\r\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\r\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\r\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}.\r\n * @public\r\n * */\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\r\n    transformConstraintIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, transformConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);\r\n        this.transformConstraintIndex = transformConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 7 /* ENTRIES*/;\r\n    }\r\n\r\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\r\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number, mixScaleX: number, mixScaleY: number, mixShearY: number) {\r\n        const frames = this.frames;\r\n\r\n        frame *= 7 /* ENTRIES*/;\r\n        frames[frame] = time;\r\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\r\n        frames[frame + 2 /* X*/] = mixX;\r\n        frames[frame + 3 /* Y*/] = mixY;\r\n        frames[frame + 4 /* SCALEX*/] = mixScaleX;\r\n        frames[frame + 5 /* SCALEY*/] = mixScaleY;\r\n        frames[frame + 6 /* SHEARY*/] = mixShearY;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            const data = constraint.data;\r\n\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mixRotate = data.mixRotate;\r\n                    constraint.mixX = data.mixX;\r\n                    constraint.mixY = data.mixY;\r\n                    constraint.mixScaleX = data.mixScaleX;\r\n                    constraint.mixScaleY = data.mixScaleY;\r\n                    constraint.mixShearY = data.mixShearY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\r\n                    constraint.mixX += (data.mixX - constraint.mixX) * alpha;\r\n                    constraint.mixY += (data.mixY - constraint.mixY) * alpha;\r\n                    constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\r\n                    constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\r\n                    constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate;\r\n        let x;\r\n        let y;\r\n        let scaleX;\r\n        let scaleY;\r\n        let shearY;\r\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\r\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                rotate = frames[i + 1 /* ROTATE*/];\r\n                x = frames[i + 2 /* X*/];\r\n                y = frames[i + 3 /* Y*/];\r\n                scaleX = frames[i + 4 /* SCALEX*/];\r\n                scaleY = frames[i + 5 /* SCALEY*/];\r\n                shearY = frames[i + 6 /* SHEARY*/];\r\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\r\n\r\n                rotate += (frames[i + 7 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\r\n                x += (frames[i + 7 /* ENTRIES*/ + 2 /* X*/] - x) * t;\r\n                y += (frames[i + 7 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\r\n                scaleX += (frames[i + 7 /* ENTRIES*/ + 4 /* SCALEX*/] - scaleX) * t;\r\n                scaleY += (frames[i + 7 /* ENTRIES*/ + 5 /* SCALEY*/] - scaleY) * t;\r\n                shearY += (frames[i + 7 /* ENTRIES*/ + 6 /* SHEARY*/] - shearY) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                rotate = frames[i + 1 /* ROTATE*/];\r\n                x = frames[i + 2 /* X*/];\r\n                y = frames[i + 3 /* Y*/];\r\n                scaleX = frames[i + 4 /* SCALEX*/];\r\n                scaleY = frames[i + 5 /* SCALEY*/];\r\n                shearY = frames[i + 6 /* SHEARY*/];\r\n                break;\r\n            default:\r\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\r\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\r\n                scaleX = this.getBezierValue(time, i, 4 /* SCALEX*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\r\n                scaleY = this.getBezierValue(time, i, 5 /* SCALEY*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\r\n                shearY = this.getBezierValue(time, i, 6 /* SHEARY*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            const data = constraint.data;\r\n\r\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\r\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\r\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\r\n            constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\r\n            constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\r\n            constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\r\n        } else {\r\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\r\n            constraint.mixX += (x - constraint.mixX) * alpha;\r\n            constraint.mixY += (y - constraint.mixY) * alpha;\r\n            constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\r\n            constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\r\n            constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#position}.\r\n * @public\r\n * */\r\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\r\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\r\n    pathConstraintIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.position = constraint.data.position;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const position = this.getCurveValue(time);\r\n\r\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n        else constraint.position += (position - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a path constraint's {@link PathConstraint#spacing}.\r\n * @public\r\n * */\r\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.spacing = constraint.data.spacing;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const spacing = this.getCurveValue(time);\r\n\r\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\r\n * {@link PathConstraint#getMixY()}.\r\n * @public\r\n * */\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\r\n    pathConstraintIndex = 0;\r\n\r\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\r\n        super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);\r\n        this.pathConstraintIndex = pathConstraintIndex;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return 4 /* ENTRIES*/;\r\n    }\r\n\r\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\r\n        const frames = this.frames;\r\n\r\n        frame <<= 2;\r\n        frames[frame] = time;\r\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\r\n        frames[frame + 2 /* X*/] = mixX;\r\n        frames[frame + 3 /* Y*/] = mixY;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (!constraint.active) return;\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    constraint.mixRotate = constraint.data.mixRotate;\r\n                    constraint.mixX = constraint.data.mixX;\r\n                    constraint.mixY = constraint.data.mixY;\r\n\r\n                    return;\r\n                case MixBlend.first:\r\n                    constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\r\n                    constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\r\n                    constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let rotate;\r\n        let x;\r\n        let y;\r\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\r\n        const curveType = this.curves[i >> 2];\r\n\r\n        switch (curveType) {\r\n            case 0 /* LINEAR*/:\r\n                const before = frames[i];\r\n\r\n                rotate = frames[i + 1 /* ROTATE*/];\r\n                x = frames[i + 2 /* X*/];\r\n                y = frames[i + 3 /* Y*/];\r\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\r\n\r\n                rotate += (frames[i + 4 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\r\n                x += (frames[i + 4 /* ENTRIES*/ + 2 /* X*/] - x) * t;\r\n                y += (frames[i + 4 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\r\n                break;\r\n            case 1 /* STEPPED*/:\r\n                rotate = frames[i + 1 /* ROTATE*/];\r\n                x = frames[i + 2 /* X*/];\r\n                y = frames[i + 3 /* Y*/];\r\n                break;\r\n            default:\r\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\r\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\r\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\r\n        }\r\n\r\n        if (blend == MixBlend.setup) {\r\n            const data = constraint.data;\r\n\r\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\r\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\r\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\r\n        } else {\r\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\r\n            constraint.mixX += (x - constraint.mixX) * alpha;\r\n            constraint.mixY += (y - constraint.mixY) * alpha;\r\n        }\r\n    }\r\n}\r\n\r\n/** Changes a slot's {@link Slot#getSequenceIndex()} for an attachment's {@link Sequence}.\r\n * @public\r\n * */\r\nexport class SequenceTimeline extends Timeline implements SlotTimeline {\r\n    static ENTRIES = 3;\r\n    static MODE = 1;\r\n    static DELAY = 2;\r\n\r\n    slotIndex: number;\r\n    attachment: IHasTextureRegion;\r\n\r\n    constructor(frameCount: number, slotIndex: number, attachment: IHasTextureRegion) {\r\n        super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);\r\n        this.slotIndex = slotIndex;\r\n        this.attachment = attachment;\r\n    }\r\n\r\n    getFrameEntries() {\r\n        return SequenceTimeline.ENTRIES;\r\n    }\r\n\r\n    getSlotIndex() {\r\n        return this.slotIndex;\r\n    }\r\n\r\n    getAttachment() {\r\n        return this.attachment as unknown as Attachment;\r\n    }\r\n\r\n    /** Sets the time, mode, index, and frame time for the specified frame.\r\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\r\n     * @param time Seconds between frames. */\r\n    setFrame(frame: number, time: number, mode: SequenceMode, index: number, delay: number) {\r\n        const frames = this.frames;\r\n\r\n        frame *= SequenceTimeline.ENTRIES;\r\n        frames[frame] = time;\r\n        frames[frame + SequenceTimeline.MODE] = mode | (index << 4);\r\n        frames[frame + SequenceTimeline.DELAY] = delay;\r\n    }\r\n\r\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\r\n        const slot = skeleton.slots[this.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n        const slotAttachment = slot.attachment;\r\n        const attachment = this.attachment as unknown as Attachment;\r\n\r\n        if (slotAttachment != attachment) {\r\n            if (!(slotAttachment instanceof VertexAttachment) || (slotAttachment as VertexAttachment).timelineAttachment != attachment) return;\r\n        }\r\n\r\n        const frames = this.frames;\r\n\r\n        if (time < frames[0]) {\r\n            // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) slot.sequenceIndex = -1;\r\n\r\n            return;\r\n        }\r\n\r\n        const i = Timeline.search(frames, time, SequenceTimeline.ENTRIES);\r\n        const before = frames[i];\r\n        const modeAndIndex = frames[i + SequenceTimeline.MODE];\r\n        const delay = frames[i + SequenceTimeline.DELAY];\r\n\r\n        if (!this.attachment.sequence) return;\r\n        let index = modeAndIndex >> 4;\r\n        const count = this.attachment.sequence.regions.length;\r\n        const mode = SequenceModeValues[modeAndIndex & 0xf];\r\n\r\n        if (mode != SequenceMode.hold) {\r\n            index += ((time - before) / delay + 0.00001) | 0;\r\n            switch (mode) {\r\n                case SequenceMode.once:\r\n                    index = Math.min(count - 1, index);\r\n                    break;\r\n                case SequenceMode.loop:\r\n                    index %= count;\r\n                    break;\r\n                case SequenceMode.pingpong: {\r\n                    const n = (count << 1) - 2;\r\n\r\n                    index = n == 0 ? 0 : index % n;\r\n                    if (index >= count) index = n - index;\r\n                    break;\r\n                }\r\n                case SequenceMode.onceReverse:\r\n                    index = Math.max(count - 1 - index, 0);\r\n                    break;\r\n                case SequenceMode.loopReverse:\r\n                    index = count - 1 - (index % count);\r\n                    break;\r\n                case SequenceMode.pingpongReverse: {\r\n                    const n = (count << 1) - 2;\r\n\r\n                    index = n == 0 ? 0 : (index + count - 1) % n;\r\n                    if (index >= count) index = n - index;\r\n                }\r\n            }\r\n        }\r\n        slot.sequenceIndex = index;\r\n    }\r\n}\r\n","import { IAnimationState, IAnimationStateListener, ITrackEntry, MathUtils, MixBlend, MixDirection, Pool, StringSet, Utils } from '@pixi-spine/base';\r\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\r\nimport type { AnimationStateData } from './AnimationStateData';\r\nimport type { Event } from './Event';\r\nimport type { Skeleton } from './Skeleton';\r\nimport type { Slot } from './Slot';\r\n\r\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class AnimationState implements IAnimationState<AnimationStateData> {\r\n    static _emptyAnimation = new Animation('<empty>', [], 0);\r\n    private static emptyAnimation(): Animation {\r\n        return AnimationState._emptyAnimation;\r\n    }\r\n\r\n    /** The AnimationStateData to look up mix durations. */\r\n    data: AnimationStateData;\r\n\r\n    /** The list of tracks that currently have animations, which may contain null entries. */\r\n    tracks = new Array<TrackEntry | null>();\r\n\r\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n     * or faster. Defaults to 1.\r\n     *\r\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\r\n    timeScale = 1;\r\n    unkeyedState = 0;\r\n\r\n    events = new Array<Event>();\r\n    listeners = new Array<AnimationStateListener>();\r\n    queue = new EventQueue(this);\r\n    propertyIDs = new StringSet();\r\n    animationsChanged = false;\r\n\r\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n    constructor(data: AnimationStateData) {\r\n        this.data = data;\r\n    }\r\n\r\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\r\n    update(delta: number) {\r\n        delta *= this.timeScale;\r\n        const tracks = this.tracks;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            const current = tracks[i];\r\n\r\n            if (!current) continue;\r\n\r\n            current.animationLast = current.nextAnimationLast;\r\n            current.trackLast = current.nextTrackLast;\r\n\r\n            let currentDelta = delta * current.timeScale;\r\n\r\n            if (current.delay > 0) {\r\n                current.delay -= currentDelta;\r\n                if (current.delay > 0) continue;\r\n                currentDelta = -current.delay;\r\n                current.delay = 0;\r\n            }\r\n\r\n            let next = current.next;\r\n\r\n            if (next) {\r\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n                const nextTime = current.trackLast - next.delay;\r\n\r\n                if (nextTime >= 0) {\r\n                    next.delay = 0;\r\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                    current.trackTime += currentDelta;\r\n                    this.setCurrent(i, next, true);\r\n                    while (next.mixingFrom) {\r\n                        next.mixTime += delta;\r\n                        next = next.mixingFrom;\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\r\n                tracks[i] = null;\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                continue;\r\n            }\r\n            if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\r\n                // End mixing from entries once all have completed.\r\n                let from: TrackEntry | null = current.mixingFrom;\r\n\r\n                current.mixingFrom = null;\r\n                if (from) from.mixingTo = null;\r\n                while (from) {\r\n                    this.queue.end(from);\r\n                    from = from.mixingFrom;\r\n                }\r\n            }\r\n\r\n            current.trackTime += currentDelta;\r\n        }\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Returns true when all mixing from entries are complete. */\r\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\r\n        const from = to.mixingFrom;\r\n\r\n        if (!from) return true;\r\n\r\n        const finished = this.updateMixingFrom(from, delta);\r\n\r\n        from.animationLast = from.nextAnimationLast;\r\n        from.trackLast = from.nextTrackLast;\r\n\r\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                to.mixingFrom = from.mixingFrom;\r\n                if (from.mixingFrom) from.mixingFrom.mixingTo = to;\r\n                to.interruptAlpha = from.interruptAlpha;\r\n                this.queue.end(from);\r\n            }\r\n\r\n            return finished;\r\n        }\r\n\r\n        from.trackTime += delta * from.timeScale;\r\n        to.mixTime += delta;\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n     * animation state can be applied to multiple skeletons to pose them identically.\r\n     * @returns True if any animations were applied. */\r\n    apply(skeleton: Skeleton): boolean {\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        if (this.animationsChanged) this._animationsChanged();\r\n\r\n        const events = this.events;\r\n        const tracks = this.tracks;\r\n        let applied = false;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            const current = tracks[i];\r\n\r\n            if (!current || current.delay > 0) continue;\r\n            applied = true;\r\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n            // Apply mixing from entries first.\r\n            let mix = current.alpha;\r\n\r\n            if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);\r\n            else if (current.trackTime >= current.trackEnd && !current.next) mix = 0;\r\n\r\n            // Apply current entry.\r\n            const animationLast = current.animationLast;\r\n            const animationTime = current.getAnimationTime();\r\n            let applyTime = animationTime;\r\n            let applyEvents: Event[] | null = events;\r\n\r\n            if (current.reverse) {\r\n                applyTime = current.animation.duration - applyTime;\r\n                applyEvents = null;\r\n            }\r\n            const timelines = current.animation.timelines;\r\n            const timelineCount = timelines.length;\r\n\r\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\r\n                    Utils.webkit602BugfixHelper(mix, blend);\r\n                    const timeline = timelines[ii];\r\n\r\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\r\n                }\r\n            } else {\r\n                const timelineMode = current.timelineMode;\r\n\r\n                const shortestRotation = current.shortestRotation;\r\n                const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\r\n\r\n                if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\r\n\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    const timeline = timelines[ii];\r\n                    const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\r\n\r\n                    if (!shortestRotation && timeline instanceof RotateTimeline) {\r\n                        this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\r\n                    } else if (timeline instanceof AttachmentTimeline) {\r\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    } else {\r\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                        Utils.webkit602BugfixHelper(mix, blend);\r\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\r\n                    }\r\n                }\r\n            }\r\n            this.queueEvents(current, animationTime);\r\n            events.length = 0;\r\n            current.nextAnimationLast = animationTime;\r\n            current.nextTrackLast = current.trackTime;\r\n        }\r\n\r\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\r\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\r\n        // the time is before the first key).\r\n        const setupState = this.unkeyedState + SETUP;\r\n        const slots = skeleton.slots;\r\n\r\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.attachmentState == setupState) {\r\n                const attachmentName = slot.data.attachmentName;\r\n\r\n                slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n            }\r\n        }\r\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\r\n\r\n        this.queue.drain();\r\n\r\n        return applied;\r\n    }\r\n\r\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n        const from = to.mixingFrom;\r\n\r\n        if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n        let mix = 0;\r\n\r\n        if (to.mixDuration == 0) {\r\n            // Single frame mix to undo mixingFrom changes.\r\n            mix = 1;\r\n            if (blend == MixBlend.first) blend = MixBlend.setup;\r\n        } else {\r\n            mix = to.mixTime / to.mixDuration;\r\n            if (mix > 1) mix = 1;\r\n            if (blend != MixBlend.first) blend = from.mixBlend;\r\n        }\r\n\r\n        const attachments = mix < from.attachmentThreshold;\r\n        const drawOrder = mix < from.drawOrderThreshold;\r\n        const timelines = from.animation.timelines;\r\n        const timelineCount = timelines.length;\r\n        const alphaHold = from.alpha * to.interruptAlpha;\r\n        const alphaMix = alphaHold * (1 - mix);\r\n        const animationLast = from.animationLast;\r\n        const animationTime = from.getAnimationTime();\r\n        let applyTime = animationTime;\r\n        let events = null;\r\n\r\n        if (from.reverse) applyTime = from.animation.duration - applyTime;\r\n        else if (mix < from.eventThreshold) events = this.events;\r\n\r\n        if (blend == MixBlend.add) {\r\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\r\n        } else {\r\n            const timelineMode = from.timelineMode;\r\n            const timelineHoldMix = from.timelineHoldMix;\r\n\r\n            const shortestRotation = from.shortestRotation;\r\n            const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\r\n\r\n            if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\r\n\r\n            from.totalAlpha = 0;\r\n            for (let i = 0; i < timelineCount; i++) {\r\n                const timeline = timelines[i];\r\n                let direction = MixDirection.mixOut;\r\n                let timelineBlend: MixBlend;\r\n                let alpha = 0;\r\n\r\n                switch (timelineMode[i]) {\r\n                    case SUBSEQUENT:\r\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n                        timelineBlend = blend;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case HOLD_SUBSEQUENT:\r\n                        timelineBlend = blend;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    case HOLD_FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    default:\r\n                        timelineBlend = MixBlend.setup;\r\n                        const holdMix = timelineHoldMix[i];\r\n\r\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                        break;\r\n                }\r\n                from.totalAlpha += alpha;\r\n\r\n                if (!shortestRotation && timeline instanceof RotateTimeline)\r\n                    this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\r\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\r\n                else {\r\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                    Utils.webkit602BugfixHelper(alpha, blend);\r\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\r\n                    timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n        this.events.length = 0;\r\n        from.nextAnimationLast = animationTime;\r\n        from.nextTrackLast = from.trackTime;\r\n\r\n        return mix;\r\n    }\r\n\r\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\r\n        const slot = skeleton.slots[timeline.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        if (time < timeline.frames[0]) {\r\n            // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n        } else this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\r\n\r\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\r\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null, attachments: boolean) {\r\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n        if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\r\n    }\r\n\r\n    applyRotateTimeline(\r\n        timeline: RotateTimeline,\r\n        skeleton: Skeleton,\r\n        time: number,\r\n        alpha: number,\r\n        blend: MixBlend,\r\n        timelinesRotation: Array<number>,\r\n        i: number,\r\n        firstFrame: boolean\r\n    ) {\r\n        if (firstFrame) timelinesRotation[i] = 0;\r\n\r\n        if (alpha == 1) {\r\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n\r\n            return;\r\n        }\r\n\r\n        const bone = skeleton.bones[timeline.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        const frames = timeline.frames;\r\n        let r1 = 0;\r\n        let r2 = 0;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                default:\r\n                    return;\r\n                case MixBlend.first:\r\n                    r1 = bone.rotation;\r\n                    r2 = bone.data.rotation;\r\n            }\r\n        } else {\r\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n            r2 = bone.data.rotation + timeline.getCurveValue(time);\r\n        }\r\n\r\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n        let total = 0;\r\n        let diff = r2 - r1;\r\n\r\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n        if (diff == 0) {\r\n            total = timelinesRotation[i];\r\n        } else {\r\n            let lastTotal = 0;\r\n            let lastDiff = 0;\r\n\r\n            if (firstFrame) {\r\n                lastTotal = 0;\r\n                lastDiff = diff;\r\n            } else {\r\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n            }\r\n            const current = diff > 0;\r\n            let dir = lastTotal >= 0;\r\n            // Detect cross at 0 (not 180).\r\n\r\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                // A cross after a 360 rotation is a loop.\r\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n                dir = current;\r\n            }\r\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\r\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n            timelinesRotation[i] = total;\r\n        }\r\n        timelinesRotation[i + 1] = diff;\r\n        bone.rotation = r1 + total * alpha;\r\n    }\r\n\r\n    queueEvents(entry: TrackEntry, animationTime: number) {\r\n        const animationStart = entry.animationStart;\r\n        const animationEnd = entry.animationEnd;\r\n        const duration = animationEnd - animationStart;\r\n        const trackLastWrapped = entry.trackLast % duration;\r\n\r\n        // Queue events before complete.\r\n        const events = this.events;\r\n        let i = 0;\r\n        const n = events.length;\r\n\r\n        for (; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.time < trackLastWrapped) break;\r\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n\r\n        // Queue complete if completed a loop iteration or the animation.\r\n        let complete = false;\r\n\r\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n        if (complete) this.queue.complete(entry);\r\n\r\n        // Queue events after complete.\r\n        for (; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n    }\r\n\r\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTracks() {\r\n        const oldDrainDisabled = this.queue.drainDisabled;\r\n\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Removes all animations from the track, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTrack(trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        const current = this.tracks[trackIndex];\r\n\r\n        if (!current) return;\r\n\r\n        this.queue.end(current);\r\n\r\n        this.clearNext(current);\r\n\r\n        let entry = current;\r\n\r\n        while (true) {\r\n            const from = entry.mixingFrom;\r\n\r\n            if (!from) break;\r\n            this.queue.end(from);\r\n            entry.mixingFrom = null;\r\n            entry.mixingTo = null;\r\n            entry = from;\r\n        }\r\n\r\n        this.tracks[current.trackIndex] = null;\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\r\n        const from = this.expandToIndex(index);\r\n\r\n        this.tracks[index] = current;\r\n        current.previous = null;\r\n\r\n        if (from) {\r\n            if (interrupt) this.queue.interrupt(from);\r\n            current.mixingFrom = from;\r\n            from.mixingTo = current;\r\n            current.mixTime = 0;\r\n\r\n            // Store the interrupted mix percentage.\r\n            if (from.mixingFrom && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n        }\r\n\r\n        this.queue.start(current);\r\n    }\r\n\r\n    /** Sets an animation by name.\r\n     *\r\n     * See {@link #setAnimationWith()}. */\r\n    setAnimation(trackIndex: number, animationName: string, loop = false) {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\r\n\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n     * applied to a skeleton, it is replaced (not mixed from).\r\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    setAnimationWith(trackIndex: number, animation: Animation, loop = false) {\r\n        if (!animation) throw new Error('animation cannot be null.');\r\n        let interrupt = true;\r\n        let current = this.expandToIndex(trackIndex);\r\n\r\n        if (current) {\r\n            if (current.nextTrackLast == -1) {\r\n                // Don't mix from an entry that was never applied.\r\n                this.tracks[trackIndex] = current.mixingFrom;\r\n                this.queue.interrupt(current);\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                current = current.mixingFrom;\r\n                interrupt = false;\r\n            } else this.clearNext(current);\r\n        }\r\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\r\n\r\n        this.setCurrent(trackIndex, entry, interrupt);\r\n        this.queue.drain();\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Queues an animation by name.\r\n     *\r\n     * See {@link #addAnimationWith()}. */\r\n    addAnimation(trackIndex: number, animationName: string, loop = false, delay = 0) {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\r\n\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n     * equivalent to calling {@link #setAnimationWith()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n     *           previous entry is looping, its next loop completion is used instead of its duration.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addAnimationWith(trackIndex: number, animation: Animation, loop = false, delay = 0) {\r\n        if (!animation) throw new Error('animation cannot be null.');\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n\r\n        if (last) {\r\n            while (last.next) last = last.next;\r\n        }\r\n\r\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n        if (!last) {\r\n            this.setCurrent(trackIndex, entry, true);\r\n            this.queue.drain();\r\n        } else {\r\n            last.next = entry;\r\n            entry.previous = last;\r\n            if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\r\n        }\r\n\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     *\r\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n     * 0 still mixes out over one frame.\r\n     *\r\n     * Mixing in is done by first setting an empty animation, then adding an animation using\r\n     * {@link #addAnimation()} and on the returned track entry, set the\r\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\r\n    setEmptyAnimation(trackIndex: number, mixDuration = 0) {\r\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\r\n\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n     * {@link #setEmptyAnimation()}.\r\n     *\r\n     * See {@link #setEmptyAnimation()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n     *           loop completion is used instead of its duration.\r\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addEmptyAnimation(trackIndex: number, mixDuration = 0, delay = 0) {\r\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\r\n\r\n        if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n     * duration. */\r\n    setEmptyAnimations(mixDuration = 0) {\r\n        const oldDrainDisabled = this.queue.drainDisabled;\r\n\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            const current = this.tracks[i];\r\n\r\n            if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n        }\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    expandToIndex(index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n        this.tracks.length = index + 1;\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @param last May be null. */\r\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry | null) {\r\n        const entry = this.trackEntryPool.obtain();\r\n\r\n        entry.reset();\r\n        entry.trackIndex = trackIndex;\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.holdPrevious = false;\r\n\r\n        entry.reverse = false;\r\n        entry.shortestRotation = false;\r\n\r\n        entry.eventThreshold = 0;\r\n        entry.attachmentThreshold = 0;\r\n        entry.drawOrderThreshold = 0;\r\n\r\n        entry.animationStart = 0;\r\n        entry.animationEnd = animation.duration;\r\n        entry.animationLast = -1;\r\n        entry.nextAnimationLast = -1;\r\n\r\n        entry.delay = 0;\r\n        entry.trackTime = 0;\r\n        entry.trackLast = -1;\r\n        entry.nextTrackLast = -1;\r\n        entry.trackEnd = Number.MAX_VALUE;\r\n        entry.timeScale = 1;\r\n\r\n        entry.alpha = 1;\r\n        entry.mixTime = 0;\r\n        entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\r\n        entry.interruptAlpha = 1;\r\n        entry.totalAlpha = 0;\r\n        entry.mixBlend = MixBlend.replace;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\r\n    clearNext(entry: TrackEntry) {\r\n        let next = entry.next;\r\n\r\n        while (next) {\r\n            this.queue.dispose(next);\r\n            next = next.next;\r\n        }\r\n        entry.next = null;\r\n    }\r\n\r\n    _animationsChanged() {\r\n        this.animationsChanged = false;\r\n\r\n        this.propertyIDs.clear();\r\n        const tracks = this.tracks;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let entry = tracks[i];\r\n\r\n            if (!entry) continue;\r\n            while (entry.mixingFrom) entry = entry.mixingFrom;\r\n            do {\r\n                if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\r\n                entry = entry.mixingTo;\r\n            } while (entry);\r\n        }\r\n    }\r\n\r\n    computeHold(entry: TrackEntry) {\r\n        const to = entry.mixingTo;\r\n        const timelines = entry.animation.timelines;\r\n        const timelinesCount = entry.animation.timelines.length;\r\n        const timelineMode = entry.timelineMode;\r\n\r\n        timelineMode.length = timelinesCount;\r\n        const timelineHoldMix = entry.timelineHoldMix;\r\n\r\n        timelineHoldMix.length = 0;\r\n        const propertyIDs = this.propertyIDs;\r\n\r\n        if (to && to.holdPrevious) {\r\n            for (let i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\r\n\r\n            return;\r\n        }\r\n\r\n        // eslint-disable-next-line no-restricted-syntax, no-labels\r\n        outer: for (let i = 0; i < timelinesCount; i++) {\r\n            const timeline = timelines[i];\r\n            const ids = timeline.getPropertyIds();\r\n\r\n            if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;\r\n            else if (\r\n                !to ||\r\n                timeline instanceof AttachmentTimeline ||\r\n                timeline instanceof DrawOrderTimeline ||\r\n                timeline instanceof EventTimeline ||\r\n                !to.animation.hasTimeline(ids)\r\n            ) {\r\n                timelineMode[i] = FIRST;\r\n            } else {\r\n                for (let next = to.mixingTo; next; next = next.mixingTo) {\r\n                    if (next.animation.hasTimeline(ids)) continue;\r\n                    if (entry.mixDuration > 0) {\r\n                        timelineMode[i] = HOLD_MIX;\r\n                        timelineHoldMix[i] = next;\r\n                        // eslint-disable-next-line no-labels\r\n                        continue outer;\r\n                    }\r\n                    break;\r\n                }\r\n                timelineMode[i] = HOLD_FIRST;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\r\n    getCurrent(trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    /** Adds a listener to receive events for all track entries. */\r\n    addListener(listener: AnimationStateListener) {\r\n        if (!listener) throw new Error('listener cannot be null.');\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    /** Removes the listener added with {@link #addListener()}. */\r\n    removeListener(listener: AnimationStateListener) {\r\n        const index = this.listeners.indexOf(listener);\r\n\r\n        if (index >= 0) this.listeners.splice(index, 1);\r\n    }\r\n\r\n    /** Removes all listeners added with {@link #addListener()}. */\r\n    clearListeners() {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n     * are not wanted because new animations are being set. */\r\n    clearListenerNotifications() {\r\n        this.queue.clear();\r\n    }\r\n\r\n    // deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1 = false;\r\n\r\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2 = false;\r\n\r\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3 = false;\r\n\r\n    hasAnimation(animationName: string): boolean {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        return animation !== null;\r\n    }\r\n\r\n    hasAnimationByName(animationName: string): boolean {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\r\n        }\r\n\r\n        return this.hasAnimation(animationName);\r\n    }\r\n}\r\n\r\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\r\n * @public\r\n * */\r\nexport class TrackEntry implements ITrackEntry {\r\n    /** The animation to apply for this track entry. */\r\n    animation: Animation | null = null;\r\n\r\n    previous: TrackEntry | null = null;\r\n\r\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\r\n    next: TrackEntry | null = null;\r\n\r\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\r\n    mixingFrom: TrackEntry | null = null;\r\n\r\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\r\n    mixingTo: TrackEntry | null = null;\r\n\r\n    /** The listener for events generated by this track entry, or null.\r\n     *\r\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\r\n    listener: AnimationStateListener | null = null;\r\n\r\n    /** The index of the track where this track entry is either current or queued.\r\n     *\r\n     * See {@link AnimationState#getCurrent()}. */\r\n    trackIndex = 0;\r\n\r\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     * duration. */\r\n    loop = false;\r\n\r\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n     * of being mixed out.\r\n     *\r\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n     * keys the property, only when a higher track also keys the property.\r\n     *\r\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n     * previous animation. */\r\n    holdPrevious = false;\r\n\r\n    reverse = false;\r\n\r\n    shortestRotation = false;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n     * timelines are not applied while this animation is being mixed out. */\r\n    eventThreshold = 0;\r\n\r\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\r\n    attachmentThreshold = 0;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n     * so draw order timelines are not applied while this animation is being mixed out. */\r\n    drawOrderThreshold = 0;\r\n\r\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n     *\r\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n     * value to prevent timeline keys before the start time from triggering. */\r\n    animationStart = 0;\r\n\r\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\r\n    animationEnd = 0;\r\n\r\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n     * is applied. */\r\n    animationLast = 0;\r\n\r\n    nextAnimationLast = 0;\r\n\r\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n     *\r\n     * {@link #timeScale} affects the delay. */\r\n    delay = 0;\r\n\r\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\r\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n     * looping. */\r\n    trackTime = 0;\r\n\r\n    trackLast = 0;\r\n    nextTrackLast = 0;\r\n\r\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n     *\r\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n     * abruptly cease being applied. */\r\n    trackEnd = 0;\r\n\r\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n     * faster. Defaults to 1.\r\n     *\r\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n     * match the animation speed.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n     * the time scale is not 1, the delay may need to be adjusted.\r\n     *\r\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\r\n    timeScale = 0;\r\n\r\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n     * to 1, which overwrites the skeleton's current pose with this animation.\r\n     *\r\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\r\n    alpha = 0;\r\n\r\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n     * slightly more than `mixDuration` when the mix is complete. */\r\n    mixTime = 0;\r\n\r\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n     *\r\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n     * properties it was animating.\r\n     *\r\n     * The `mixDuration` can be set manually rather than use the value from\r\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n     * track entry only before {@link AnimationState#update(float)} is first called.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n     * afterward. */\r\n    mixDuration = 0;\r\n    interruptAlpha = 0;\r\n    totalAlpha = 0;\r\n\r\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n     * the values from the lower tracks.\r\n     *\r\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n     * called. */\r\n    mixBlend = MixBlend.replace;\r\n    timelineMode = new Array<number>();\r\n    timelineHoldMix = new Array<TrackEntry>();\r\n    timelinesRotation = new Array<number>();\r\n\r\n    reset() {\r\n        this.next = null;\r\n        this.previous = null;\r\n        this.mixingFrom = null;\r\n        this.mixingTo = null;\r\n        this.animation = null;\r\n        this.listener = null;\r\n        this.timelineMode.length = 0;\r\n        this.timelineHoldMix.length = 0;\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n     * `animationStart` time. */\r\n    getAnimationTime() {\r\n        if (this.loop) {\r\n            const duration = this.animationEnd - this.animationStart;\r\n\r\n            if (duration == 0) return this.animationStart;\r\n\r\n            return (this.trackTime % duration) + this.animationStart;\r\n        }\r\n\r\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n    }\r\n\r\n    setAnimationLast(animationLast: number) {\r\n        this.animationLast = animationLast;\r\n        this.nextAnimationLast = animationLast;\r\n    }\r\n\r\n    /** Returns true if at least one loop has been completed.\r\n     *\r\n     * See {@link AnimationStateListener#complete()}. */\r\n    isComplete() {\r\n        return this.trackTime >= this.animationEnd - this.animationStart;\r\n    }\r\n\r\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n     * long way around when using {@link #alpha} and starting animations on other tracks.\r\n     *\r\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\r\n    resetRotationDirections() {\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    getTrackComplete() {\r\n        const duration = this.animationEnd - this.animationStart;\r\n\r\n        if (duration != 0) {\r\n            if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\r\n            if (this.trackTime < duration) return duration; // Before duration.\r\n        }\r\n\r\n        return this.trackTime; // Next update.\r\n    }\r\n\r\n    // deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n    private static deprecatedWarning2: Boolean = false;\r\n\r\n    get time() {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\r\n        }\r\n\r\n        return this.trackTime;\r\n    }\r\n\r\n    set time(value: number) {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    get endTime() {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\r\n        }\r\n\r\n        return this.trackTime;\r\n    }\r\n\r\n    set endTime(value: number) {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    loopsCount() {\r\n        return Math.floor(this.trackTime / this.trackEnd);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventQueue {\r\n    objects: Array<any> = [];\r\n    drainDisabled = false;\r\n    animState: AnimationState;\r\n\r\n    constructor(animState: AnimationState) {\r\n        this.animState = animState;\r\n    }\r\n\r\n    start(entry: TrackEntry) {\r\n        this.objects.push(EventType.start);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    interrupt(entry: TrackEntry) {\r\n        this.objects.push(EventType.interrupt);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    end(entry: TrackEntry) {\r\n        this.objects.push(EventType.end);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    dispose(entry: TrackEntry) {\r\n        this.objects.push(EventType.dispose);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    complete(entry: TrackEntry) {\r\n        this.objects.push(EventType.complete);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    event(entry: TrackEntry, event: Event) {\r\n        this.objects.push(EventType.event);\r\n        this.objects.push(entry);\r\n        this.objects.push(event);\r\n    }\r\n\r\n    drain() {\r\n        if (this.drainDisabled) return;\r\n        this.drainDisabled = true;\r\n\r\n        const objects = this.objects;\r\n        const listeners = this.animState.listeners;\r\n\r\n        for (let i = 0; i < objects.length; i += 2) {\r\n            const type = objects[i] as EventType;\r\n            const entry = objects[i + 1] as TrackEntry;\r\n\r\n            switch (type) {\r\n                case EventType.start:\r\n                    if (entry.listener && entry.listener.start) entry.listener.start(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.start) listener.start(entry);\r\n                    }\r\n                    break;\r\n                case EventType.interrupt:\r\n                    if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.interrupt) listener.interrupt(entry);\r\n                    }\r\n                    break;\r\n                case EventType.end:\r\n                    if (entry.listener && entry.listener.end) entry.listener.end(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.end) listener.end(entry);\r\n                    }\r\n                // Fall through.\r\n                case EventType.dispose:\r\n                    if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.dispose) listener.dispose(entry);\r\n                    }\r\n                    this.animState.trackEntryPool.free(entry);\r\n                    break;\r\n                case EventType.complete:\r\n                    if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.complete) listener.complete(entry);\r\n                    }\r\n                    break;\r\n                case EventType.event:\r\n                    const event = objects[i++ + 2] as Event;\r\n\r\n                    if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.event) listener.event(entry, event);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        this.clear();\r\n\r\n        this.drainDisabled = false;\r\n    }\r\n\r\n    clear() {\r\n        this.objects.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum EventType {\r\n    start,\r\n    interrupt,\r\n    end,\r\n    dispose,\r\n    complete,\r\n    event,\r\n}\r\n\r\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\r\n * events.\r\n *\r\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\r\n * {@link AnimationState#addListener()}.\r\n * @public\r\n * */\r\nexport interface AnimationStateListener extends IAnimationStateListener {\r\n    /** Invoked when this entry has been set as the current entry. */\r\n    start?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n     * mixing. */\r\n    interrupt?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n    end?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n    dispose?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked every time this entry's animation completes a loop. */\r\n    complete?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry's animation triggers an event. */\r\n    event?: (entry: TrackEntry, event: Event) => void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\r\n    start(entry: TrackEntry) {}\r\n\r\n    interrupt(entry: TrackEntry) {}\r\n\r\n    end(entry: TrackEntry) {}\r\n\r\n    dispose(entry: TrackEntry) {}\r\n\r\n    complete(entry: TrackEntry) {}\r\n\r\n    event(entry: TrackEntry, event: Event) {}\r\n}\r\n\r\n/** 1. A previously applied timeline has set this property.\r\n *\r\n * Result: Mix from the current pose to the timeline pose. */\r\nconst SUBSEQUENT = 0;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n *\r\n * Result: Mix from the setup pose to the timeline pose. */\r\nconst FIRST = 1;\r\n/** 1) A previously applied timeline has set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_SUBSEQUENT = 2;\r\n/** 1) This is the first timeline to set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n * that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_FIRST = 3;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry to be applied does have a timeline to set this property.\r\n * 3. The next track entry after that one does have a timeline to set this property.\r\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n *\r\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n * 2 track entries in a row have a timeline that sets the same property.\r\n *\r\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n * place. */\r\nconst HOLD_MIX = 4;\r\n\r\nconst SETUP = 1;\r\nconst CURRENT = 2;\r\n","import type { SkeletonData } from './SkeletonData';\r\nimport type { IAnimationStateData, StringMap } from '@pixi-spine/base';\r\nimport type { Animation } from './Animation';\r\n\r\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed.\r\n * @public\r\n * */\r\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\r\n    /** The SkeletonData to look up animations when they are specified by name. */\r\n    skeletonData: SkeletonData;\r\n\r\n    animationToMixTime: StringMap<number> = {};\r\n\r\n    /** The mix duration to use when no mix duration has been defined between two animations. */\r\n    defaultMix = 0;\r\n\r\n    constructor(skeletonData: SkeletonData) {\r\n        if (!skeletonData) throw new Error('skeletonData cannot be null.');\r\n        this.skeletonData = skeletonData;\r\n    }\r\n\r\n    /** Sets a mix duration by animation name.\r\n     *\r\n     * See {@link #setMixWith()}. */\r\n    setMix(fromName: string, toName: string, duration: number) {\r\n        const from = this.skeletonData.findAnimation(fromName);\r\n\r\n        if (!from) throw new Error(`Animation not found: ${fromName}`);\r\n        const to = this.skeletonData.findAnimation(toName);\r\n\r\n        if (!to) throw new Error(`Animation not found: ${toName}`);\r\n        this.setMixWith(from, to, duration);\r\n    }\r\n\r\n    /** Sets the mix duration when changing from the specified animation to the other.\r\n     *\r\n     * See {@link TrackEntry#mixDuration}. */\r\n    setMixWith(from: Animation, to: Animation, duration: number) {\r\n        if (!from) throw new Error('from cannot be null.');\r\n        if (!to) throw new Error('to cannot be null.');\r\n        const key = `${from.name}.${to.name}`;\r\n\r\n        this.animationToMixTime[key] = duration;\r\n    }\r\n\r\n    /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\r\n     * no mix duration has been set. */\r\n    getMix(from: Animation, to: Animation) {\r\n        const key = `${from.name}.${to.name}`;\r\n        const value = this.animationToMixTime[key];\r\n\r\n        return value === undefined ? this.defaultMix : value;\r\n    }\r\n}\r\n","import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment, Sequence } from './attachments';\r\nimport type { TextureAtlas } from '@pixi-spine/base';\r\nimport type { Skin } from './Skin';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class AtlasAttachmentLoader implements AttachmentLoader {\r\n    atlas: TextureAtlas;\r\n\r\n    constructor(atlas: TextureAtlas) {\r\n        this.atlas = atlas;\r\n    }\r\n\r\n    loadSequence(name: string, basePath: string, sequence: Sequence) {\r\n        const regions = sequence.regions;\r\n\r\n        for (let i = 0, n = regions.length; i < n; i++) {\r\n            const path = sequence.getPath(basePath, i);\r\n            const region = this.atlas.findRegion(path);\r\n\r\n            if (region == null) throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);\r\n            regions[i] = region;\r\n            regions[i].renderObject = regions[i];\r\n        }\r\n    }\r\n\r\n    newRegionAttachment(skin: Skin, name: string, path: string, sequence: Sequence): RegionAttachment {\r\n        const attachment = new RegionAttachment(name, path);\r\n\r\n        if (sequence != null) {\r\n            this.loadSequence(name, path, sequence);\r\n        } else {\r\n            const region = this.atlas.findRegion(path);\r\n\r\n            if (!region) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\r\n            region.renderObject = region;\r\n            attachment.region = region;\r\n        }\r\n\r\n        return attachment;\r\n    }\r\n\r\n    newMeshAttachment(skin: Skin, name: string, path: string, sequence: Sequence): MeshAttachment {\r\n        const attachment = new MeshAttachment(name, path);\r\n\r\n        if (sequence != null) {\r\n            this.loadSequence(name, path, sequence);\r\n        } else {\r\n            const region = this.atlas.findRegion(path);\r\n\r\n            if (!region) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\r\n            region.renderObject = region;\r\n            attachment.region = region;\r\n        }\r\n\r\n        return attachment;\r\n    }\r\n\r\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\r\n        return new BoundingBoxAttachment(name);\r\n    }\r\n\r\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\r\n        return new PathAttachment(name);\r\n    }\r\n\r\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\r\n        return new PointAttachment(name);\r\n    }\r\n\r\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\r\n        return new ClippingAttachment(name);\r\n    }\r\n}\r\n","import { Matrix } from 'pixi.js';\r\nimport type { Updatable } from './Updatable';\r\nimport type { BoneData } from './BoneData';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\r\n\r\n/** Stores a bone's current pose.\r\n *\r\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\r\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\r\n * constraint or application code modifies the world transform after it was computed from the local transform.\r\n * @public\r\n * */\r\nexport class Bone implements Updatable, IBone {\r\n    // be careful! Spine b,c is c,b in pixi matrix\r\n    matrix = new Matrix();\r\n\r\n    get worldX(): number {\r\n        return this.matrix.tx;\r\n    }\r\n\r\n    get worldY(): number {\r\n        return this.matrix.ty;\r\n    }\r\n\r\n    /** The bone's setup pose data. */\r\n    data: BoneData;\r\n\r\n    /** The skeleton this bone belongs to. */\r\n    skeleton: Skeleton;\r\n\r\n    /** The parent bone, or null if this is the root bone. */\r\n    parent: Bone | null = null;\r\n\r\n    /** The immediate children of this bone. */\r\n    children = new Array<Bone>();\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local rotation in degrees, counter clockwise. */\r\n    rotation = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 0;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 0;\r\n\r\n    /** The local shearX. */\r\n    shearX = 0;\r\n\r\n    /** The local shearY. */\r\n    shearY = 0;\r\n\r\n    /** The applied local x translation. */\r\n    ax = 0;\r\n\r\n    /** The applied local y translation. */\r\n    ay = 0;\r\n\r\n    /** The applied local rotation in degrees, counter clockwise. */\r\n    arotation = 0;\r\n\r\n    /** The applied local scaleX. */\r\n    ascaleX = 0;\r\n\r\n    /** The applied local scaleY. */\r\n    ascaleY = 0;\r\n\r\n    /** The applied local shearX. */\r\n    ashearX = 0;\r\n\r\n    /** The applied local shearY. */\r\n    ashearY = 0;\r\n\r\n    sorted = false;\r\n    active = false;\r\n\r\n    /** @param parent May be null. */\r\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone | null) {\r\n        if (!data) throw new Error('data cannot be null.');\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.skeleton = skeleton;\r\n        this.parent = parent;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\r\n     * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local applied transform. */\r\n    update() {\r\n        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local transform.\r\n     *\r\n     * See {@link #updateWorldTransformWith()}. */\r\n    updateWorldTransform() {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\r\n     * specified local transform. Child bones are not updated.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide. */\r\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n        this.ax = x;\r\n        this.ay = y;\r\n        this.arotation = rotation;\r\n        this.ascaleX = scaleX;\r\n        this.ascaleY = scaleY;\r\n        this.ashearX = shearX;\r\n        this.ashearY = shearY;\r\n\r\n        const parent = this.parent;\r\n        const m = this.matrix;\r\n\r\n        const sx = this.skeleton.scaleX;\r\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\r\n\r\n        if (!parent) {\r\n            // Root bone.\r\n            const skeleton = this.skeleton;\r\n            const rotationY = rotation + 90 + shearY;\r\n\r\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\r\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\r\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\r\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\r\n            m.tx = x * sx + skeleton.x;\r\n            m.ty = y * sy + skeleton.y;\r\n\r\n            return;\r\n        }\r\n\r\n        let pa = parent.matrix.a;\r\n        let pb = parent.matrix.c;\r\n        let pc = parent.matrix.b;\r\n        let pd = parent.matrix.d;\r\n\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n\r\n        switch (this.data.transformMode) {\r\n            case TransformMode.Normal: {\r\n                const rotationY = rotation + 90 + shearY;\r\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n\r\n                return;\r\n            }\r\n            case TransformMode.OnlyTranslation: {\r\n                const rotationY = rotation + 90 + shearY;\r\n\r\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\r\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\r\n                break;\r\n            }\r\n            case TransformMode.NoRotationOrReflection: {\r\n                let s = pa * pa + pc * pc;\r\n                let prx = 0;\r\n\r\n                if (s > 0.0001) {\r\n                    s = Math.abs(pa * pd - pb * pc) / s;\r\n                    pa /= sx;\r\n                    pc /= sy;\r\n                    pb = pc * s;\r\n                    pd = pa * s;\r\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\r\n                } else {\r\n                    pa = 0;\r\n                    pc = 0;\r\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\r\n                }\r\n                const rx = rotation + shearX - prx;\r\n                const ry = rotation + shearY - prx + 90;\r\n                const la = MathUtils.cosDeg(rx) * scaleX;\r\n                const lb = MathUtils.cosDeg(ry) * scaleY;\r\n                const lc = MathUtils.sinDeg(rx) * scaleX;\r\n                const ld = MathUtils.sinDeg(ry) * scaleY;\r\n\r\n                m.a = pa * la - pb * lc;\r\n                m.c = pa * lb - pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n                break;\r\n            }\r\n            case TransformMode.NoScale:\r\n            case TransformMode.NoScaleOrReflection: {\r\n                const cos = MathUtils.cosDeg(rotation);\r\n                const sin = MathUtils.sinDeg(rotation);\r\n                let za = (pa * cos + pb * sin) / sx;\r\n                let zc = (pc * cos + pd * sin) / sy;\r\n                let s = Math.sqrt(za * za + zc * zc);\r\n\r\n                if (s > 0.00001) s = 1 / s;\r\n                za *= s;\r\n                zc *= s;\r\n                s = Math.sqrt(za * za + zc * zc);\r\n                if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0)) s = -s;\r\n                const r = Math.PI / 2 + Math.atan2(zc, za);\r\n                const zb = Math.cos(r) * s;\r\n                const zd = Math.sin(r) * s;\r\n                const la = MathUtils.cosDeg(shearX) * scaleX;\r\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\r\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\r\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\r\n\r\n                m.a = za * la + zb * lc;\r\n                m.c = za * lb + zb * ld;\r\n                m.b = zc * la + zd * lc;\r\n                m.d = zc * lb + zd * ld;\r\n                break;\r\n            }\r\n        }\r\n        m.a *= sx;\r\n        m.c *= sx;\r\n        m.b *= sy;\r\n        m.d *= sy;\r\n    }\r\n\r\n    /** Sets this bone's local transform to the setup pose. */\r\n    setToSetupPose() {\r\n        const data = this.data;\r\n\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    }\r\n\r\n    /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\r\n    getWorldRotationX() {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\r\n    getWorldRotationY() {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\r\n    getWorldScaleX() {\r\n        const m = this.matrix;\r\n\r\n        return Math.sqrt(m.a * m.a + m.b * m.b);\r\n    }\r\n\r\n    /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\r\n    getWorldScaleY() {\r\n        const m = this.matrix;\r\n\r\n        return Math.sqrt(m.c * m.c + m.d * m.d);\r\n    }\r\n\r\n    /** Computes the applied transform values from the world transform.\r\n     *\r\n     * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\r\n     * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\r\n     * constraints).\r\n     *\r\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\r\n     * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\r\n    updateAppliedTransform() {\r\n        const parent = this.parent;\r\n        const m = this.matrix;\r\n\r\n        if (!parent) {\r\n            this.ax = m.tx - this.skeleton.x;\r\n            this.ay = m.ty - this.skeleton.y;\r\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\r\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n            this.ashearX = 0;\r\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\r\n\r\n            return;\r\n        }\r\n        const pm = parent.matrix;\r\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\r\n        const dx = m.tx - pm.tx;\r\n        const dy = m.ty - pm.ty;\r\n\r\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\r\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\r\n        const ia = pid * pm.d;\r\n        const id = pid * pm.a;\r\n        const ib = pid * pm.c;\r\n        const ic = pid * pm.b;\r\n        const ra = ia * m.a - ib * m.b;\r\n        const rb = ia * m.c - ib * m.d;\r\n        const rc = id * m.b - ic * m.a;\r\n        const rd = id * m.d - ic * m.c;\r\n\r\n        this.ashearX = 0;\r\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n        if (this.ascaleX > 0.0001) {\r\n            const det = ra * rd - rb * rc;\r\n\r\n            this.ascaleY = det / this.ascaleX;\r\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n        } else {\r\n            this.ascaleX = 0;\r\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n            this.ashearY = 0;\r\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n        }\r\n    }\r\n\r\n    /** Transforms a point from world coordinates to the bone's local coordinates. */\r\n    worldToLocal(world: Vector2) {\r\n        const m = this.matrix;\r\n        const a = m.a;\r\n        const b = m.c;\r\n        const c = m.b;\r\n        const d = m.d;\r\n        const invDet = 1 / (a * d - b * c);\r\n        const x = world.x - m.tx;\r\n        const y = world.y - m.ty;\r\n\r\n        world.x = x * d * invDet - y * b * invDet;\r\n        world.y = y * a * invDet - x * c * invDet;\r\n\r\n        return world;\r\n    }\r\n\r\n    /** Transforms a point from the bone's local coordinates to world coordinates. */\r\n    localToWorld(local: Vector2) {\r\n        const m = this.matrix;\r\n        const x = local.x;\r\n        const y = local.y;\r\n\r\n        local.x = x * m.a + y * m.c + m.tx;\r\n        local.y = x * m.b + y * m.d + m.ty;\r\n\r\n        return local;\r\n    }\r\n\r\n    /** Transforms a world rotation to a local rotation. */\r\n    worldToLocalRotation(worldRotation: number) {\r\n        const sin = MathUtils.sinDeg(worldRotation);\r\n        const cos = MathUtils.cosDeg(worldRotation);\r\n        const mat = this.matrix;\r\n\r\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** Transforms a local rotation to a world rotation. */\r\n    localToWorldRotation(localRotation: number) {\r\n        localRotation -= this.rotation - this.shearX;\r\n        const sin = MathUtils.sinDeg(localRotation);\r\n        const cos = MathUtils.cosDeg(localRotation);\r\n        const mat = this.matrix;\r\n\r\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    /** Rotates the world transform the specified amount.\r\n     * <p>\r\n     * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\r\n     * need to be called on any child bones, recursively. */\r\n    rotateWorld(degrees: number) {\r\n        const mat = this.matrix;\r\n        const a = mat.a;\r\n        const b = mat.c;\r\n        const c = mat.b;\r\n        const d = mat.d;\r\n        const cos = MathUtils.cosDeg(degrees);\r\n        const sin = MathUtils.sinDeg(degrees);\r\n\r\n        mat.a = cos * a - sin * c;\r\n        mat.c = cos * b - sin * d;\r\n        mat.b = sin * a + cos * c;\r\n        mat.d = sin * b + cos * d;\r\n    }\r\n}\r\n","import { Color, TransformMode } from '@pixi-spine/base';\r\n\r\n/** Stores the setup pose for a {@link Bone}.\r\n * @public\r\n * */\r\nexport class BoneData {\r\n    /** The index of the bone in {@link Skeleton#getBones()}. */\r\n    index = 0;\r\n\r\n    /** The name of the bone, which is unique across all bones in the skeleton. */\r\n    name: string;\r\n\r\n    /** @returns May be null. */\r\n    parent: BoneData | null = null;\r\n\r\n    /** The bone's length. */\r\n    length = 0;\r\n\r\n    /** The local x translation. */\r\n    x = 0;\r\n\r\n    /** The local y translation. */\r\n    y = 0;\r\n\r\n    /** The local rotation. */\r\n    rotation = 0;\r\n\r\n    /** The local scaleX. */\r\n    scaleX = 1;\r\n\r\n    /** The local scaleY. */\r\n    scaleY = 1;\r\n\r\n    /** The local shearX. */\r\n    shearX = 0;\r\n\r\n    /** The local shearX. */\r\n    shearY = 0;\r\n\r\n    /** The transform mode for how parent world transforms affect this bone. */\r\n    transformMode = TransformMode.Normal;\r\n\r\n    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\r\n     * bone.\r\n     * @see Skin#bones */\r\n    skinRequired = false;\r\n\r\n    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\r\n     * rendered at runtime. */\r\n    color = new Color();\r\n\r\n    constructor(index: number, name: string, parent: BoneData | null) {\r\n        if (index < 0) throw new Error('index must be >= 0.');\r\n        if (!name) throw new Error('name cannot be null.');\r\n        this.index = index;\r\n        this.name = name;\r\n        this.parent = parent;\r\n    }\r\n}\r\n","/** The base class for all constraint datas.\r\n * @public\r\n * */\r\nexport abstract class ConstraintData {\r\n    constructor(public name: string, public order: number, public skinRequired: boolean) {}\r\n}\r\n","import type { EventData } from './EventData';\r\nimport type { IEvent } from '@pixi-spine/base';\r\n\r\n/** Stores the current pose values for an {@link Event}.\r\n *\r\n * See Timeline {@link Timeline#apply()},\r\n * AnimationStateListener {@link AnimationStateListener#event()}, and\r\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class Event implements IEvent {\r\n    data: EventData;\r\n    intValue = 0;\r\n    floatValue = 0;\r\n    stringValue: string | null = null;\r\n    time = 0;\r\n    volume = 0;\r\n    balance = 0;\r\n\r\n    constructor(time: number, data: EventData) {\r\n        if (!data) throw new Error('data cannot be null.');\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n","import type { IEventData } from '@pixi-spine/base';\r\n\r\n/** Stores the setup pose values for an {@link Event}.\r\n *\r\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class EventData implements IEventData {\r\n    name: string;\r\n    intValue = 0;\r\n    floatValue = 0;\r\n    stringValue: string | null = null;\r\n    audioPath: string | null = null;\r\n    volume = 0;\r\n    balance = 0;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n","import type { Updatable } from './Updatable';\r\nimport type { IkConstraintData } from './IkConstraintData';\r\nimport type { Bone } from './Bone';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { MathUtils, settings, TransformMode } from '@pixi-spine/base';\r\n\r\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\r\n * the last bone is as close to the target bone as possible.\r\n *\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class IkConstraint implements Updatable {\r\n    /** The IK constraint's setup pose data. */\r\n    data: IkConstraintData;\r\n\r\n    /** The bones that will be modified by this IK constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The bone that is the IK target. */\r\n    target: Bone;\r\n\r\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\r\n    bendDirection = 0;\r\n\r\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n    compress = false;\r\n\r\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n    stretch = false;\r\n\r\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n    mix = 1;\r\n\r\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n    softness = 0;\r\n    active = false;\r\n\r\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\r\n        if (!data) throw new Error('data cannot be null.');\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.mix = data.mix;\r\n        this.softness = data.softness;\r\n        this.bendDirection = data.bendDirection;\r\n        this.compress = data.compress;\r\n        this.stretch = data.stretch;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            const bone = skeleton.findBone(data.bones[i].name);\r\n\r\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}`);\r\n            this.bones.push(bone);\r\n        }\r\n        const target = skeleton.findBone(data.target.name);\r\n\r\n        if (!target) throw new Error(`Couldn't find bone ${data.target.name}`);\r\n        this.target = target;\r\n    }\r\n\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    update() {\r\n        if (this.mix == 0) return;\r\n        const target = this.target;\r\n        const bones = this.bones;\r\n\r\n        switch (bones.length) {\r\n            case 1:\r\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\r\n                break;\r\n            case 2:\r\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /** Applies 1 bone IK. The target is specified in the world coordinate system. */\r\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\r\n        const p = bone.parent.matrix;\r\n\r\n        if (!p) throw new Error('IK bone must have parent.');\r\n        const pa = p.a;\r\n        let pb = p.c;\r\n        const pc = p.b;\r\n        let pd = p.d;\r\n        let rotationIK = -bone.ashearX - bone.arotation;\r\n        let tx = 0;\r\n        let ty = 0;\r\n\r\n        const skelX = bone.skeleton.scaleX;\r\n        const skelY = settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;\r\n\r\n        switch (bone.data.transformMode) {\r\n            case TransformMode.OnlyTranslation:\r\n                tx = targetX - bone.worldX;\r\n                ty = targetY - bone.worldY;\r\n                // TODO: possible bug in spine-ts runtime!\r\n                if (settings.yDown) {\r\n                    ty = -ty;\r\n                }\r\n                break;\r\n            case TransformMode.NoRotationOrReflection:\r\n                const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\r\n                const sa = pa / skelX;\r\n                const sc = pc / skelY;\r\n\r\n                pb = -sc * s * skelX;\r\n                pd = sa * s * skelY;\r\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\r\n            // Fall through\r\n            default:\r\n                const x = targetX - p.tx;\r\n                const y = targetY - p.ty;\r\n                const d = pa * pd - pb * pc;\r\n\r\n                tx = (x * pd - y * pb) / d - bone.ax;\r\n                ty = (y * pa - x * pc) / d - bone.ay;\r\n        }\r\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\r\n        if (bone.ascaleX < 0) rotationIK += 180;\r\n        if (rotationIK > 180) rotationIK -= 360;\r\n        else if (rotationIK < -180) rotationIK += 360;\r\n        let sx = bone.ascaleX;\r\n        let sy = bone.ascaleY;\r\n\r\n        if (compress || stretch) {\r\n            switch (bone.data.transformMode) {\r\n                case TransformMode.NoScale:\r\n                case TransformMode.NoScaleOrReflection:\r\n                    tx = targetX - bone.worldX;\r\n                    ty = targetY - bone.worldY;\r\n            }\r\n            const b = bone.data.length * sx;\r\n            const dd = Math.sqrt(tx * tx + ty * ty);\r\n\r\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\r\n                const s = (dd / b - 1) * alpha + 1;\r\n\r\n                sx *= s;\r\n                if (uniform) sy *= s;\r\n            }\r\n        }\r\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\r\n    }\r\n\r\n    /** Applies 2 bone IK. The target is specified in the world coordinate system.\r\n     * @param child A direct descendant of the parent bone. */\r\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, uniform: boolean, softness: number, alpha: number) {\r\n        const px = parent.ax;\r\n        const py = parent.ay;\r\n        let psx = parent.ascaleX;\r\n        let psy = parent.ascaleY;\r\n        let sx = psx;\r\n        let sy = psy;\r\n        let csx = child.ascaleX;\r\n        const pmat = parent.matrix;\r\n        let os1 = 0;\r\n        let os2 = 0;\r\n        let s2 = 0;\r\n\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        } else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        } else os2 = 0;\r\n        const cx = child.ax;\r\n        let cy = 0;\r\n        let cwx = 0;\r\n        let cwy = 0;\r\n        let a = pmat.a;\r\n        let b = pmat.c;\r\n        let c = pmat.b;\r\n        let d = pmat.d;\r\n        const u = Math.abs(psx - psy) <= 0.0001;\r\n\r\n        if (!u || stretch) {\r\n            cy = 0;\r\n            cwx = a * cx + pmat.tx;\r\n            cwy = c * cx + pmat.ty;\r\n        } else {\r\n            cy = child.ay;\r\n            cwx = a * cx + b * cy + pmat.tx;\r\n            cwy = c * cx + d * cy + pmat.ty;\r\n        }\r\n        const pp = parent.parent.matrix;\r\n\r\n        if (!pp) throw new Error('IK parent must itself have a parent.');\r\n        a = pp.a;\r\n        b = pp.c;\r\n        c = pp.b;\r\n        d = pp.d;\r\n        const id = 1 / (a * d - b * c);\r\n        let x = cwx - pp.tx;\r\n        let y = cwy - pp.ty;\r\n        const dx = (x * d - y * b) * id - px;\r\n        const dy = (y * a - x * c) * id - py;\r\n        const l1 = Math.sqrt(dx * dx + dy * dy);\r\n        let l2 = child.data.length * csx;\r\n        let a1;\r\n        let a2;\r\n\r\n        if (l1 < 0.0001) {\r\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\r\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n\r\n            return;\r\n        }\r\n        x = targetX - pp.tx;\r\n        y = targetY - pp.ty;\r\n        let tx = (x * d - y * b) * id - px;\r\n        let ty = (y * a - x * c) * id - py;\r\n        let dd = tx * tx + ty * ty;\r\n\r\n        if (softness != 0) {\r\n            softness *= psx * (csx + 1) * 0.5;\r\n            const td = Math.sqrt(dd);\r\n            const sd = td - l1 - l2 * psx + softness;\r\n\r\n            if (sd > 0) {\r\n                let p = Math.min(1, sd / (softness * 2)) - 1;\r\n\r\n                p = (sd - softness * (1 - p * p)) / td;\r\n                tx -= p * tx;\r\n                ty -= p * ty;\r\n                dd = tx * tx + ty * ty;\r\n            }\r\n        }\r\n        // eslint-disable-next-line no-restricted-syntax, no-labels\r\n        outer: if (u) {\r\n            l2 *= psx;\r\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n\r\n            if (cos < -1) {\r\n                cos = -1;\r\n                a2 = Math.PI * bendDir;\r\n            } else if (cos > 1) {\r\n                cos = 1;\r\n                a2 = 0;\r\n                if (stretch) {\r\n                    a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\r\n                    sx *= a;\r\n                    if (uniform) sy *= a;\r\n                }\r\n            } else a2 = Math.acos(cos) * bendDir;\r\n            a = l1 + l2 * cos;\r\n            b = l2 * Math.sin(a2);\r\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n        } else {\r\n            a = psx * l2;\r\n            b = psy * l2;\r\n            const aa = a * a;\r\n            const bb = b * b;\r\n            const ta = Math.atan2(ty, tx);\r\n\r\n            c = bb * l1 * l1 + aa * dd - aa * bb;\r\n            const c1 = -2 * bb * l1;\r\n            const c2 = bb - aa;\r\n\r\n            d = c1 * c1 - 4 * c2 * c;\r\n            if (d >= 0) {\r\n                let q = Math.sqrt(d);\r\n\r\n                if (c1 < 0) q = -q;\r\n                q = -(c1 + q) * 0.5;\r\n                const r0 = q / c2;\r\n                const r1 = c / q;\r\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n\r\n                if (r * r <= dd) {\r\n                    y = Math.sqrt(dd - r * r) * bendDir;\r\n                    a1 = ta - Math.atan2(y, r);\r\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                    // eslint-disable-next-line no-labels\r\n                    break outer;\r\n                }\r\n            }\r\n            let minAngle = MathUtils.PI;\r\n            let minX = l1 - a;\r\n            let minDist = minX * minX;\r\n            let minY = 0;\r\n            let maxAngle = 0;\r\n            let maxX = l1 + a;\r\n            let maxDist = maxX * maxX;\r\n            let maxY = 0;\r\n\r\n            c = (-a * l1) / (aa - bb);\r\n            if (c >= -1 && c <= 1) {\r\n                c = Math.acos(c);\r\n                x = a * Math.cos(c) + l1;\r\n                y = b * Math.sin(c);\r\n                d = x * x + y * y;\r\n                if (d < minDist) {\r\n                    minAngle = c;\r\n                    minDist = d;\r\n                    minX = x;\r\n                    minY = y;\r\n                }\r\n                if (d > maxDist) {\r\n                    maxAngle = c;\r\n                    maxDist = d;\r\n                    maxX = x;\r\n                    maxY = y;\r\n                }\r\n            }\r\n            if (dd <= (minDist + maxDist) * 0.5) {\r\n                a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                a2 = minAngle * bendDir;\r\n            } else {\r\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                a2 = maxAngle * bendDir;\r\n            }\r\n        }\r\n        const os = Math.atan2(cy, cx) * s2;\r\n        let rotation = parent.arotation;\r\n\r\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n        if (a1 > 180) a1 -= 360;\r\n        else if (a1 < -180)\r\n            //\r\n            a1 += 360;\r\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\r\n        rotation = child.arotation;\r\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n        if (a2 > 180) a2 -= 360;\r\n        else if (a2 < -180)\r\n            //\r\n            a2 += 360;\r\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n    }\r\n}\r\n","import { ConstraintData } from './ConstraintData';\r\nimport type { BoneData } from './BoneData';\r\n\r\n/** Stores the setup pose for an {@link IkConstraint}.\r\n * <p>\r\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class IkConstraintData extends ConstraintData {\r\n    /** The bones that are constrained by this IK constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The bone that is the IK target. */\r\n    private _target: BoneData | null = null;\r\n    public set target(boneData: BoneData) {\r\n        this._target = boneData;\r\n    }\r\n    public get target() {\r\n        if (!this._target) throw new Error('BoneData not set.');\r\n        else return this._target;\r\n    }\r\n\r\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\r\n    bendDirection = 1;\r\n\r\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\r\n    compress = false;\r\n\r\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\r\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\r\n    stretch = false;\r\n\r\n    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\r\n     * is scaled on both the X and Y axes. */\r\n    uniform = false;\r\n\r\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\r\n    mix = 1;\r\n\r\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\r\n    softness = 0;\r\n\r\n    constructor(name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n","import { ConstraintData } from './ConstraintData';\r\nimport type { SlotData } from './SlotData';\r\nimport type { BoneData } from './BoneData';\r\nimport { PositionMode, RotateMode } from '@pixi-spine/base';\r\n\r\n/** Stores the setup pose for a {@link PathConstraint}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class PathConstraintData extends ConstraintData {\r\n    /** The bones that will be modified by this path constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The slot whose path attachment will be used to constrained the bones. */\r\n    private _target: SlotData | null = null;\r\n    public set target(slotData: SlotData) {\r\n        this._target = slotData;\r\n    }\r\n    public get target() {\r\n        if (!this._target) throw new Error('SlotData not set.');\r\n        else return this._target;\r\n    }\r\n\r\n    /** The mode for positioning the first bone on the path. */\r\n    positionMode: PositionMode = PositionMode.Fixed;\r\n\r\n    /** The mode for positioning the bones after the first bone on the path. */\r\n    spacingMode: SpacingMode = SpacingMode.Fixed;\r\n\r\n    /** The mode for adjusting the rotation of the bones. */\r\n    rotateMode: RotateMode = RotateMode.Chain;\r\n\r\n    /** An offset added to the constrained bone rotation. */\r\n    offsetRotation = 0;\r\n\r\n    /** The position along the path. */\r\n    position = 0;\r\n\r\n    /** The spacing between bones. */\r\n    spacing = 0;\r\n\r\n    mixRotate = 0;\r\n    mixX = 0;\r\n    mixY = 0;\r\n\r\n    constructor(name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n\r\n/** Controls how bones after the first bone are positioned along the path.\r\n *\r\n * [Spacing mode](http://esotericsoftware.com/spine-path-constraints#Spacing-mode) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport enum SpacingMode {\r\n    Length,\r\n    Fixed,\r\n    Percent,\r\n    Proportional,\r\n}\r\n","import { PathAttachment } from './attachments';\r\nimport type { Updatable } from './Updatable';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport type { Bone } from './Bone';\r\nimport type { Slot } from './Slot';\r\nimport type { Skeleton } from './Skeleton';\r\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\r\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\r\n * constrained bones so they follow a {@link PathAttachment}.\r\n *\r\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class PathConstraint implements Updatable {\r\n    static NONE = -1;\r\n    static BEFORE = -2;\r\n    static AFTER = -3;\r\n    static epsilon = 0.00001;\r\n\r\n    /** The path constraint's setup pose data. */\r\n    data: PathConstraintData;\r\n\r\n    /** The bones that will be modified by this path constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The slot whose path attachment will be used to constrained the bones. */\r\n    target: Slot;\r\n\r\n    /** The position along the path. */\r\n    position = 0;\r\n\r\n    /** The spacing between bones. */\r\n    spacing = 0;\r\n\r\n    mixRotate = 0;\r\n\r\n    mixX = 0;\r\n\r\n    mixY = 0;\r\n\r\n    spaces = new Array<number>();\r\n    positions = new Array<number>();\r\n    world = new Array<number>();\r\n    curves = new Array<number>();\r\n    lengths = new Array<number>();\r\n    segments = new Array<number>();\r\n\r\n    active = false;\r\n\r\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\r\n        if (!data) throw new Error('data cannot be null.');\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0, n = data.bones.length; i < n; i++) {\r\n            const bone = skeleton.findBone(data.bones[i].name);\r\n\r\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\r\n            this.bones.push(bone);\r\n        }\r\n        const target = skeleton.findSlot(data.target.name);\r\n\r\n        if (!target) throw new Error(`Couldn't find target bone ${data.target.name}`);\r\n        this.target = target;\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.mixRotate = data.mixRotate;\r\n        this.mixX = data.mixX;\r\n        this.mixY = data.mixY;\r\n    }\r\n\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    update() {\r\n        const attachment = this.target.getAttachment();\r\n\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n\r\n        const mixRotate = this.mixRotate;\r\n        const mixX = this.mixX;\r\n        const mixY = this.mixY;\r\n\r\n        if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\r\n\r\n        const data = this.data;\r\n        const tangents = data.rotateMode == RotateMode.Tangent;\r\n        const scale = data.rotateMode == RotateMode.ChainScale;\r\n\r\n        const bones = this.bones;\r\n        const boneCount = bones.length;\r\n        const spacesCount = tangents ? boneCount : boneCount + 1;\r\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\r\n        const lengths: Array<number> = scale ? (this.lengths = Utils.setArraySize(this.lengths, boneCount)) : [];\r\n        const spacing = this.spacing;\r\n\r\n        switch (data.spacingMode) {\r\n            case SpacingMode.Percent:\r\n                if (scale) {\r\n                    for (let i = 0, n = spacesCount - 1; i < n; i++) {\r\n                        const bone = bones[i];\r\n                        const setupLength = bone.data.length;\r\n\r\n                        if (setupLength < PathConstraint.epsilon) lengths[i] = 0;\r\n                        else {\r\n                            const x = setupLength * bone.matrix.a;\r\n                            const y = setupLength * bone.matrix.b;\r\n\r\n                            lengths[i] = Math.sqrt(x * x + y * y);\r\n                        }\r\n                    }\r\n                }\r\n                Utils.arrayFill(spaces, 1, spacesCount, spacing);\r\n                break;\r\n            case SpacingMode.Proportional:\r\n                let sum = 0;\r\n\r\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\r\n                    const bone = bones[i];\r\n                    const setupLength = bone.data.length;\r\n\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale) lengths[i] = 0;\r\n                        spaces[++i] = spacing;\r\n                    } else {\r\n                        const x = setupLength * bone.matrix.a;\r\n                        const y = setupLength * bone.matrix.b;\r\n                        const length = Math.sqrt(x * x + y * y);\r\n\r\n                        if (scale) lengths[i] = length;\r\n                        spaces[++i] = length;\r\n                        sum += length;\r\n                    }\r\n                }\r\n                if (sum > 0) {\r\n                    sum = (spacesCount / sum) * spacing;\r\n                    for (let i = 1; i < spacesCount; i++) spaces[i] *= sum;\r\n                }\r\n                break;\r\n            default:\r\n                const lengthSpacing = data.spacingMode == SpacingMode.Length;\r\n\r\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\r\n                    const bone = bones[i];\r\n                    const setupLength = bone.data.length;\r\n\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale) lengths[i] = 0;\r\n                        spaces[++i] = spacing;\r\n                    } else {\r\n                        const x = setupLength * bone.matrix.a;\r\n                        const y = setupLength * bone.matrix.b;\r\n                        const length = Math.sqrt(x * x + y * y);\r\n\r\n                        if (scale) lengths[i] = length;\r\n                        spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\r\n                    }\r\n                }\r\n        }\r\n\r\n        const positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\r\n        let boneX = positions[0];\r\n        let boneY = positions[1];\r\n        let offsetRotation = data.offsetRotation;\r\n        let tip = false;\r\n\r\n        if (offsetRotation == 0) tip = data.rotateMode == RotateMode.Chain;\r\n        else {\r\n            tip = false;\r\n            const p = this.target.bone.matrix;\r\n\r\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        }\r\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            const bone = bones[i];\r\n            const mat = bone.matrix;\r\n\r\n            mat.tx += (boneX - mat.tx) * mixX;\r\n            mat.ty += (boneY - mat.ty) * mixY;\r\n            const x = positions[p];\r\n            const y = positions[p + 1];\r\n            const dx = x - boneX;\r\n            const dy = y - boneY;\r\n\r\n            if (scale) {\r\n                const length = lengths[i];\r\n\r\n                if (length != 0) {\r\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\r\n\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (mixRotate > 0) {\r\n                const a = mat.a;\r\n                const b = mat.c;\r\n                const c = mat.b;\r\n                const d = mat.d;\r\n                let r = 0;\r\n                let cos = 0;\r\n                let sin = 0;\r\n\r\n                if (tangents) r = positions[p - 1];\r\n                else if (spaces[i + 1] == 0) r = positions[p + 2];\r\n                else r = Math.atan2(dy, dx);\r\n                r -= Math.atan2(c, a);\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    const length = bone.data.length;\r\n\r\n                    boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\r\n                } else {\r\n                    r += offsetRotation;\r\n                }\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    //\r\n                    r += MathUtils.PI2;\r\n                r *= mixRotate;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n            bone.updateAppliedTransform();\r\n        }\r\n    }\r\n\r\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean) {\r\n        const target = this.target;\r\n        let position = this.position;\r\n        const spaces = this.spaces;\r\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\r\n        let world: Array<number> = this.world;\r\n        const closed = path.closed;\r\n        let verticesLength = path.worldVerticesLength;\r\n        let curveCount = verticesLength / 6;\r\n        let prevCurve = PathConstraint.NONE;\r\n\r\n        if (!path.constantSpeed) {\r\n            const lengths = path.lengths;\r\n\r\n            curveCount -= closed ? 1 : 2;\r\n            const pathLength = lengths[curveCount];\r\n\r\n            if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\r\n\r\n            let multiplier;\r\n\r\n            switch (this.data.spacingMode) {\r\n                case SpacingMode.Percent:\r\n                    multiplier = pathLength;\r\n                    break;\r\n                case SpacingMode.Proportional:\r\n                    multiplier = pathLength / spacesCount;\r\n                    break;\r\n                default:\r\n                    multiplier = 1;\r\n            }\r\n            world = Utils.setArraySize(this.world, 8);\r\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                const space = spaces[i] * multiplier;\r\n\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (; ; curve++) {\r\n                    const length = lengths[curve];\r\n\r\n                    if (p > length) continue;\r\n                    if (curve == 0) p /= length;\r\n                    else {\r\n                        const prev = lengths[curve - 1];\r\n\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n            }\r\n\r\n            return out;\r\n        }\r\n\r\n        // World vertices.\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        } else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n        }\r\n\r\n        // Curve lengths.\r\n        const curves = Utils.setArraySize(this.curves, curveCount);\r\n        let pathLength = 0;\r\n        let x1 = world[0];\r\n        let y1 = world[1];\r\n        let cx1 = 0;\r\n        let cy1 = 0;\r\n        let cx2 = 0;\r\n        let cy2 = 0;\r\n        let x2 = 0;\r\n        let y2 = 0;\r\n        let tmpx = 0;\r\n        let tmpy = 0;\r\n        let dddfx = 0;\r\n        let dddfy = 0;\r\n        let ddfx = 0;\r\n        let ddfy = 0;\r\n        let dfx = 0;\r\n        let dfy = 0;\r\n\r\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n\r\n        if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\r\n\r\n        let multiplier;\r\n\r\n        switch (this.data.spacingMode) {\r\n            case SpacingMode.Percent:\r\n                multiplier = pathLength;\r\n                break;\r\n            case SpacingMode.Proportional:\r\n                multiplier = pathLength / spacesCount;\r\n                break;\r\n            default:\r\n                multiplier = 1;\r\n        }\r\n\r\n        const segments = this.segments;\r\n        let curveLength = 0;\r\n\r\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            const space = spaces[i] * multiplier;\r\n\r\n            position += space;\r\n            let p = position;\r\n\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0) p += pathLength;\r\n                curve = 0;\r\n            } else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            } else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n\r\n            // Determine curve containing position.\r\n            for (; ; curve++) {\r\n                const length = curves[curve];\r\n\r\n                if (p > length) continue;\r\n                if (curve == 0) p /= length;\r\n                else {\r\n                    const prev = curves[curve - 1];\r\n\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Curve segment lengths.\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                let ii = curve * 6;\r\n\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n\r\n            // Weight by segment length.\r\n            p *= curveLength;\r\n            for (; ; segment++) {\r\n                const length = segments[segment];\r\n\r\n                if (p > length) continue;\r\n                if (segment == 0) p /= length;\r\n                else {\r\n                    const prev = segments[segment - 1];\r\n\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        const x1 = temp[i];\r\n        const y1 = temp[i + 1];\r\n        const dx = temp[i + 2] - x1;\r\n        const dy = temp[i + 3] - y1;\r\n        const r = Math.atan2(dy, dx);\r\n\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        const x1 = temp[i + 2];\r\n        const y1 = temp[i + 3];\r\n        const dx = x1 - temp[i];\r\n        const dy = y1 - temp[i + 1];\r\n        const r = Math.atan2(dy, dx);\r\n\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addCurvePosition(\r\n        p: number,\r\n        x1: number,\r\n        y1: number,\r\n        cx1: number,\r\n        cy1: number,\r\n        cx2: number,\r\n        cy2: number,\r\n        x2: number,\r\n        y2: number,\r\n        out: Array<number>,\r\n        o: number,\r\n        tangents: boolean\r\n    ) {\r\n        if (p == 0 || isNaN(p)) {\r\n            out[o] = x1;\r\n            out[o + 1] = y1;\r\n            out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n\r\n            return;\r\n        }\r\n        const tt = p * p;\r\n        const ttt = tt * p;\r\n        const u = 1 - p;\r\n        const uu = u * u;\r\n        const uuu = uu * u;\r\n        const ut = u * p;\r\n        const ut3 = ut * 3;\r\n        const uut3 = u * ut3;\r\n        const utt3 = ut3 * p;\r\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\r\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) {\r\n            if (p < 0.001) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\r\n            else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n        }\r\n    }\r\n}\r\n","import { Color, ISlot } from '@pixi-spine/base';\r\n\r\nimport { Attachment, VertexAttachment } from './attachments/Attachment';\r\nimport type { Bone } from './Bone';\r\nimport type { SlotData } from './SlotData';\r\nimport type { Skeleton } from './Skeleton';\r\n\r\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\r\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\r\n * across multiple skeletons.\r\n * @public\r\n * */\r\nexport class Slot implements ISlot {\r\n    // this is canon\r\n    blendMode: string;\r\n    /** The slot's setup pose data. */\r\n    data: SlotData;\r\n\r\n    /** The bone this slot belongs to. */\r\n    bone: Bone;\r\n\r\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n     * color tinting. */\r\n    color: Color;\r\n\r\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n     * color's alpha is not used. */\r\n    darkColor: Color | null = null;\r\n\r\n    attachment: Attachment | null = null;\r\n\r\n    attachmentState = 0;\r\n\r\n    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\r\n     * {@link Sequence#getSetupIndex()}. */\r\n    sequenceIndex = -1;\r\n\r\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\r\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\r\n     *\r\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\r\n    deform = new Array<number>();\r\n\r\n    constructor(data: SlotData, bone: Bone) {\r\n        if (!data) throw new Error('data cannot be null.');\r\n        if (!bone) throw new Error('bone cannot be null.');\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.darkColor = !data.darkColor ? null : new Color();\r\n        this.setToSetupPose();\r\n\r\n        this.blendMode = this.data.blendMode;\r\n    }\r\n\r\n    /** The skeleton this slot belongs to. */\r\n    getSkeleton(): Skeleton {\r\n        return this.bone.skeleton;\r\n    }\r\n\r\n    /** The current attachment for the slot, or null if the slot has no attachment. */\r\n    getAttachment(): Attachment | null {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\r\n     * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\r\n     * specified attachment. */\r\n    setAttachment(attachment: Attachment | null) {\r\n        if (this.attachment == attachment) return;\r\n        if (\r\n            !(attachment instanceof VertexAttachment) ||\r\n            !(this.attachment instanceof VertexAttachment) ||\r\n            (<VertexAttachment>attachment).timelineAttachment != (<VertexAttachment>this.attachment).timelineAttachment\r\n        ) {\r\n            this.deform.length = 0;\r\n        }\r\n        this.attachment = attachment;\r\n        this.sequenceIndex = -1;\r\n    }\r\n\r\n    /** Sets this slot to the setup pose. */\r\n    setToSetupPose() {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.darkColor) this.darkColor.setFromColor(this.data.darkColor);\r\n        if (!this.data.attachmentName) this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n","import type { Updatable } from './Updatable';\r\nimport type { TransformConstraintData } from './TransformConstraintData';\r\nimport type { Bone } from './Bone';\r\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\r\nimport type { Skeleton } from './Skeleton';\r\n\r\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\r\n * bones to match that of the target bone.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class TransformConstraint implements Updatable {\r\n    /** The transform constraint's setup pose data. */\r\n    data: TransformConstraintData;\r\n\r\n    /** The bones that will be modified by this transform constraint. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The target bone whose world transform will be copied to the constrained bones. */\r\n    target: Bone;\r\n\r\n    mixRotate = 0;\r\n    mixX = 0;\r\n    mixY = 0;\r\n    mixScaleX = 0;\r\n    mixScaleY = 0;\r\n    mixShearY = 0;\r\n\r\n    temp = new Vector2();\r\n    active = false;\r\n\r\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\r\n        if (!data) throw new Error('data cannot be null.');\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        this.data = data;\r\n        this.mixRotate = data.mixRotate;\r\n        this.mixX = data.mixX;\r\n        this.mixY = data.mixY;\r\n        this.mixScaleX = data.mixScaleX;\r\n        this.mixScaleY = data.mixScaleY;\r\n        this.mixShearY = data.mixShearY;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            const bone = skeleton.findBone(data.bones[i].name);\r\n\r\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\r\n            this.bones.push(bone);\r\n        }\r\n        const target = skeleton.findBone(data.target.name);\r\n\r\n        if (!target) throw new Error(`Couldn't find target bone ${data.target.name}.`);\r\n        this.target = target;\r\n    }\r\n\r\n    isActive() {\r\n        return this.active;\r\n    }\r\n\r\n    update() {\r\n        if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0) return;\r\n\r\n        if (this.data.local) {\r\n            if (this.data.relative) this.applyRelativeLocal();\r\n            else this.applyAbsoluteLocal();\r\n        } else if (this.data.relative) this.applyRelativeWorld();\r\n        else this.applyAbsoluteWorld();\r\n    }\r\n\r\n    applyAbsoluteWorld() {\r\n        const mixRotate = this.mixRotate;\r\n        const mixX = this.mixX;\r\n        const mixY = this.mixY;\r\n        const mixScaleX = this.mixScaleX;\r\n        const mixScaleY = this.mixScaleY;\r\n        const mixShearY = this.mixShearY;\r\n        const translate = mixX != 0 || mixY != 0;\r\n\r\n        const target = this.target;\r\n        const targetMat = target.matrix;\r\n        const ta = targetMat.a;\r\n        const tb = targetMat.c;\r\n        const tc = targetMat.b;\r\n        const td = targetMat.d;\r\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\r\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n            const mat = bone.matrix;\r\n\r\n            if (mixRotate != 0) {\r\n                const a = mat.a;\r\n                const b = mat.c;\r\n                const c = mat.b;\r\n                const d = mat.d;\r\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    //\r\n                    r += MathUtils.PI2;\r\n                r *= mixRotate;\r\n                const cos = Math.cos(r);\r\n                const sin = Math.sin(r);\r\n\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n\r\n            if (translate) {\r\n                const temp = this.temp;\r\n\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += (temp.x - mat.tx) * mixX;\r\n                mat.ty += (temp.y - mat.ty) * mixY;\r\n            }\r\n\r\n            if (mixScaleX != 0) {\r\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n\r\n                if (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n            }\r\n            if (mixScaleY != 0) {\r\n                let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n\r\n                if (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n            }\r\n\r\n            if (mixShearY > 0) {\r\n                const b = mat.c;\r\n                const d = mat.d;\r\n                const by = Math.atan2(d, b);\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    //\r\n                    r += MathUtils.PI2;\r\n                r = by + (r + offsetShearY) * mixShearY;\r\n                const s = Math.sqrt(b * b + d * d);\r\n\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n            }\r\n\r\n            bone.updateAppliedTransform();\r\n        }\r\n    }\r\n\r\n    applyRelativeWorld() {\r\n        const mixRotate = this.mixRotate;\r\n        const mixX = this.mixX;\r\n        const mixY = this.mixY;\r\n        const mixScaleX = this.mixScaleX;\r\n        const mixScaleY = this.mixScaleY;\r\n        const mixShearY = this.mixShearY;\r\n        const translate = mixX != 0 || mixY != 0;\r\n\r\n        const target = this.target;\r\n        const targetMat = target.matrix;\r\n        const ta = targetMat.a;\r\n        const tb = targetMat.c;\r\n        const tc = targetMat.b;\r\n        const td = targetMat.d;\r\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\r\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n            const mat = bone.matrix;\r\n\r\n            if (mixRotate != 0) {\r\n                const a = mat.a;\r\n                const b = mat.c;\r\n                const c = mat.b;\r\n                const d = mat.d;\r\n                let r = Math.atan2(tc, ta) + offsetRotation;\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    //\r\n                    r += MathUtils.PI2;\r\n                r *= mixRotate;\r\n                const cos = Math.cos(r);\r\n                const sin = Math.sin(r);\r\n\r\n                mat.a = cos * a - sin * c;\r\n                mat.c = cos * b - sin * d;\r\n                mat.b = sin * a + cos * c;\r\n                mat.d = sin * b + cos * d;\r\n            }\r\n\r\n            if (translate) {\r\n                const temp = this.temp;\r\n\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                mat.tx += temp.x * mixX;\r\n                mat.ty += temp.y * mixY;\r\n            }\r\n\r\n            if (mixScaleX != 0) {\r\n                const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\r\n\r\n                mat.a *= s;\r\n                mat.b *= s;\r\n            }\r\n            if (mixScaleY != 0) {\r\n                const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\r\n\r\n                mat.c *= s;\r\n                mat.d *= s;\r\n            }\r\n\r\n            if (mixShearY > 0) {\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n\r\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    //\r\n                    r += MathUtils.PI2;\r\n                const b = mat.c;\r\n                const d = mat.d;\r\n\r\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\r\n                const s = Math.sqrt(b * b + d * d);\r\n\r\n                mat.c = Math.cos(r) * s;\r\n                mat.d = Math.sin(r) * s;\r\n            }\r\n\r\n            bone.updateAppliedTransform();\r\n        }\r\n    }\r\n\r\n    applyAbsoluteLocal() {\r\n        const mixRotate = this.mixRotate;\r\n        const mixX = this.mixX;\r\n        const mixY = this.mixY;\r\n        const mixScaleX = this.mixScaleX;\r\n        const mixScaleY = this.mixScaleY;\r\n        const mixShearY = this.mixShearY;\r\n\r\n        const target = this.target;\r\n\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            let rotation = bone.arotation;\r\n\r\n            if (mixRotate != 0) {\r\n                let r = target.arotation - rotation + this.data.offsetRotation;\r\n\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                rotation += r * mixRotate;\r\n            }\r\n\r\n            let x = bone.ax;\r\n            let y = bone.ay;\r\n\r\n            x += (target.ax - x + this.data.offsetX) * mixX;\r\n            y += (target.ay - y + this.data.offsetY) * mixY;\r\n\r\n            let scaleX = bone.ascaleX;\r\n            let scaleY = bone.ascaleY;\r\n\r\n            if (mixScaleX != 0 && scaleX != 0) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\r\n            if (mixScaleY != 0 && scaleY != 0) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\r\n\r\n            let shearY = bone.ashearY;\r\n\r\n            if (mixShearY != 0) {\r\n                let r = target.ashearY - shearY + this.data.offsetShearY;\r\n\r\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                shearY += r * mixShearY;\r\n            }\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n\r\n    applyRelativeLocal() {\r\n        const mixRotate = this.mixRotate;\r\n        const mixX = this.mixX;\r\n        const mixY = this.mixY;\r\n        const mixScaleX = this.mixScaleX;\r\n        const mixScaleY = this.mixScaleY;\r\n        const mixShearY = this.mixShearY;\r\n\r\n        const target = this.target;\r\n\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\r\n            const x = bone.ax + (target.ax + this.data.offsetX) * mixX;\r\n            const y = bone.ay + (target.ay + this.data.offsetY) * mixY;\r\n            const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);\r\n            const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);\r\n            const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\r\n\r\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n        }\r\n    }\r\n}\r\n","import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\r\nimport { Bone } from './Bone';\r\nimport { Slot } from './Slot';\r\nimport type { Updatable } from './Updatable';\r\nimport type { SkeletonData } from './SkeletonData';\r\nimport { IkConstraint } from './IkConstraint';\r\nimport { TransformConstraint } from './TransformConstraint';\r\nimport { PathConstraint } from './PathConstraint';\r\nimport type { Skin } from './Skin';\r\nimport { Color, MathUtils, NumberArrayLike, settings, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\r\n\r\n/** Stores the current pose for a skeleton.\r\n *\r\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\r\n    /** The skeleton's setup pose data. */\r\n    data: SkeletonData;\r\n\r\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\r\n    bones: Array<Bone>;\r\n\r\n    /** The skeleton's slots. */\r\n    slots: Array<Slot>;\r\n\r\n    /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\r\n    drawOrder: Array<Slot>;\r\n\r\n    /** The skeleton's IK constraints. */\r\n    ikConstraints: Array<IkConstraint>;\r\n\r\n    /** The skeleton's transform constraints. */\r\n    transformConstraints: Array<TransformConstraint>;\r\n\r\n    /** The skeleton's path constraints. */\r\n    pathConstraints: Array<PathConstraint>;\r\n\r\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\r\n    _updateCache = new Array<Updatable>();\r\n\r\n    /** The skeleton's current skin. May be null. */\r\n    skin: Skin | null = null;\r\n\r\n    /** The color to tint all the skeleton's attachments. */\r\n    color: Color;\r\n\r\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\r\n     * inheritance. */\r\n    scaleX = 1;\r\n\r\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\r\n     * inheritance. */\r\n    scaleY = 1;\r\n\r\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\r\n    x = 0;\r\n\r\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\r\n    y = 0;\r\n\r\n    constructor(data: SkeletonData) {\r\n        if (!data) throw new Error('data cannot be null.');\r\n        this.data = data;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            const boneData = data.bones[i];\r\n            let bone: Bone;\r\n\r\n            if (!boneData.parent) bone = new Bone(boneData, this, null);\r\n            else {\r\n                const parent = this.bones[boneData.parent.index];\r\n\r\n                bone = new Bone(boneData, this, parent);\r\n                parent.children.push(bone);\r\n            }\r\n            this.bones.push(bone);\r\n        }\r\n\r\n        this.slots = new Array<Slot>();\r\n        this.drawOrder = new Array<Slot>();\r\n        for (let i = 0; i < data.slots.length; i++) {\r\n            const slotData = data.slots[i];\r\n            const bone = this.bones[slotData.boneData.index];\r\n            const slot = new Slot(slotData, bone);\r\n\r\n            this.slots.push(slot);\r\n            this.drawOrder.push(slot);\r\n        }\r\n\r\n        this.ikConstraints = new Array<IkConstraint>();\r\n        for (let i = 0; i < data.ikConstraints.length; i++) {\r\n            const ikConstraintData = data.ikConstraints[i];\r\n\r\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n        }\r\n\r\n        this.transformConstraints = new Array<TransformConstraint>();\r\n        for (let i = 0; i < data.transformConstraints.length; i++) {\r\n            const transformConstraintData = data.transformConstraints[i];\r\n\r\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n        }\r\n\r\n        this.pathConstraints = new Array<PathConstraint>();\r\n        for (let i = 0; i < data.pathConstraints.length; i++) {\r\n            const pathConstraintData = data.pathConstraints[i];\r\n\r\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n        }\r\n\r\n        this.color = new Color(1, 1, 1, 1);\r\n        this.updateCache();\r\n    }\r\n\r\n    /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\r\n     * constraints, or weighted path attachments are added or removed. */\r\n    updateCache() {\r\n        const updateCache = this._updateCache;\r\n\r\n        updateCache.length = 0;\r\n\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            bone.sorted = bone.data.skinRequired;\r\n            bone.active = !bone.sorted;\r\n        }\r\n\r\n        if (this.skin) {\r\n            const skinBones = this.skin.bones;\r\n\r\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                let bone: Bone | null = this.bones[skinBones[i].index];\r\n\r\n                do {\r\n                    bone.sorted = false;\r\n                    bone.active = true;\r\n                    bone = bone.parent;\r\n                } while (bone);\r\n            }\r\n        }\r\n\r\n        // IK first, lowest hierarchy depth first.\r\n        const ikConstraints = this.ikConstraints;\r\n        const transformConstraints = this.transformConstraints;\r\n        const pathConstraints = this.pathConstraints;\r\n        const ikCount = ikConstraints.length;\r\n        const transformCount = transformConstraints.length;\r\n        const pathCount = pathConstraints.length;\r\n        const constraintCount = ikCount + transformCount + pathCount;\r\n\r\n        // eslint-disable-next-line no-restricted-syntax, no-labels\r\n        outer: for (let i = 0; i < constraintCount; i++) {\r\n            for (let ii = 0; ii < ikCount; ii++) {\r\n                const constraint = ikConstraints[ii];\r\n\r\n                if (constraint.data.order == i) {\r\n                    this.sortIkConstraint(constraint);\r\n                    // eslint-disable-next-line no-labels\r\n                    continue outer;\r\n                }\r\n            }\r\n            for (let ii = 0; ii < transformCount; ii++) {\r\n                const constraint = transformConstraints[ii];\r\n\r\n                if (constraint.data.order == i) {\r\n                    this.sortTransformConstraint(constraint);\r\n                    // eslint-disable-next-line no-labels\r\n                    continue outer;\r\n                }\r\n            }\r\n            for (let ii = 0; ii < pathCount; ii++) {\r\n                const constraint = pathConstraints[ii];\r\n\r\n                if (constraint.data.order == i) {\r\n                    this.sortPathConstraint(constraint);\r\n                    // eslint-disable-next-line no-labels\r\n                    continue outer;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\r\n    }\r\n\r\n    sortIkConstraint(constraint: IkConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        const target = constraint.target;\r\n\r\n        this.sortBone(target);\r\n\r\n        const constrained = constraint.bones;\r\n        const parent = constrained[0];\r\n\r\n        this.sortBone(parent);\r\n\r\n        if (constrained.length == 1) {\r\n            this._updateCache.push(constraint);\r\n            this.sortReset(parent.children);\r\n        } else {\r\n            const child = constrained[constrained.length - 1];\r\n\r\n            this.sortBone(child);\r\n\r\n            this._updateCache.push(constraint);\r\n\r\n            this.sortReset(parent.children);\r\n            child.sorted = true;\r\n        }\r\n    }\r\n\r\n    sortPathConstraint(constraint: PathConstraint) {\r\n        constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        const slot = constraint.target;\r\n        const slotIndex = slot.data.index;\r\n        const slotBone = slot.bone;\r\n\r\n        if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n        if (this.data.defaultSkin && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\r\n        const attachment = slot.getAttachment();\r\n\r\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n        const constrained = constraint.bones;\r\n        const boneCount = constrained.length;\r\n\r\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\r\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\r\n    }\r\n\r\n    sortTransformConstraint(constraint: TransformConstraint) {\r\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n        if (!constraint.active) return;\r\n\r\n        this.sortBone(constraint.target);\r\n\r\n        const constrained = constraint.bones;\r\n        const boneCount = constrained.length;\r\n\r\n        if (constraint.data.local) {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                const child = constrained[i];\r\n\r\n                this.sortBone(child.parent);\r\n                this.sortBone(child);\r\n            }\r\n        } else {\r\n            for (let i = 0; i < boneCount; i++) {\r\n                this.sortBone(constrained[i]);\r\n            }\r\n        }\r\n\r\n        this._updateCache.push(constraint);\r\n\r\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\r\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\r\n    }\r\n\r\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\r\n        const attachments = skin.attachments[slotIndex];\r\n\r\n        if (!attachments) return;\r\n        for (const key in attachments) {\r\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n        }\r\n    }\r\n\r\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n        const pathBones = (<PathAttachment>attachment).bones;\r\n\r\n        if (!pathBones) this.sortBone(slotBone);\r\n        else {\r\n            const bones = this.bones;\r\n\r\n            for (let i = 0, n = pathBones.length; i < n; ) {\r\n                let nn = pathBones[i++];\r\n\r\n                nn += i;\r\n                while (i < nn) this.sortBone(bones[pathBones[i++]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    sortBone(bone: Bone) {\r\n        if (!bone) return;\r\n        if (bone.sorted) return;\r\n        const parent = bone.parent;\r\n\r\n        if (parent) this.sortBone(parent);\r\n        bone.sorted = true;\r\n        this._updateCache.push(bone);\r\n    }\r\n\r\n    sortReset(bones: Array<Bone>) {\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (!bone.active) continue;\r\n            if (bone.sorted) this.sortReset(bone.children);\r\n            bone.sorted = false;\r\n        }\r\n    }\r\n\r\n    /** Updates the world transform for each bone and applies all constraints.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide. */\r\n    updateWorldTransform() {\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            bone.ax = bone.x;\r\n            bone.ay = bone.y;\r\n            bone.arotation = bone.rotation;\r\n            bone.ascaleX = bone.scaleX;\r\n            bone.ascaleY = bone.scaleY;\r\n            bone.ashearX = bone.shearX;\r\n            bone.ashearY = bone.shearY;\r\n        }\r\n\r\n        const updateCache = this._updateCache;\r\n\r\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\r\n    }\r\n\r\n    updateWorldTransformWith(parent: Bone) {\r\n        // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\r\n        const rootBone = this.getRootBone();\r\n        const pa = parent.matrix.a;\r\n        const pb = parent.matrix.c;\r\n        const pc = parent.matrix.b;\r\n        const pd = parent.matrix.d;\r\n\r\n        rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\r\n        rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\r\n\r\n        const rotationY = rootBone.rotation + 90 + rootBone.shearY;\r\n        const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\r\n        const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\r\n        const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\r\n        const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\r\n\r\n        const sx = this.scaleX;\r\n        const sy = settings.yDown ? -this.scaleY : this.scaleY;\r\n\r\n        rootBone.matrix.a = (pa * la + pb * lc) * sx;\r\n        rootBone.matrix.c = (pa * lb + pb * ld) * sx;\r\n        rootBone.matrix.b = (pc * la + pd * lc) * sy;\r\n        rootBone.matrix.d = (pc * lb + pd * ld) * sy;\r\n\r\n        // Update everything except root bone.\r\n        const updateCache = this._updateCache;\r\n\r\n        for (let i = 0, n = updateCache.length; i < n; i++) {\r\n            const updatable = updateCache[i];\r\n\r\n            if (updatable != rootBone) updatable.update();\r\n        }\r\n    }\r\n\r\n    /** Sets the bones, constraints, and slots to their setup pose values. */\r\n    setToSetupPose() {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    }\r\n\r\n    /** Sets the bones and constraints to their setup pose values. */\r\n    setBonesToSetupPose() {\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\r\n\r\n        const ikConstraints = this.ikConstraints;\r\n\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            const constraint = ikConstraints[i];\r\n\r\n            constraint.mix = constraint.data.mix;\r\n            constraint.softness = constraint.data.softness;\r\n            constraint.bendDirection = constraint.data.bendDirection;\r\n            constraint.compress = constraint.data.compress;\r\n            constraint.stretch = constraint.data.stretch;\r\n        }\r\n\r\n        const transformConstraints = this.transformConstraints;\r\n\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            const constraint = transformConstraints[i];\r\n            const data = constraint.data;\r\n\r\n            constraint.mixRotate = data.mixRotate;\r\n            constraint.mixX = data.mixX;\r\n            constraint.mixY = data.mixY;\r\n            constraint.mixScaleX = data.mixScaleX;\r\n            constraint.mixScaleY = data.mixScaleY;\r\n            constraint.mixShearY = data.mixShearY;\r\n        }\r\n\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            const constraint = pathConstraints[i];\r\n            const data = constraint.data;\r\n\r\n            constraint.position = data.position;\r\n            constraint.spacing = data.spacing;\r\n            constraint.mixRotate = data.mixRotate;\r\n            constraint.mixX = data.mixX;\r\n            constraint.mixY = data.mixY;\r\n        }\r\n    }\r\n\r\n    /** Sets the slots and draw order to their setup pose values. */\r\n    setSlotsToSetupPose() {\r\n        const slots = this.slots;\r\n\r\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\r\n    }\r\n\r\n    /** @returns May return null. */\r\n    getRootBone() {\r\n        if (this.bones.length == 0) return null;\r\n\r\n        return this.bones[0];\r\n    }\r\n\r\n    /** @returns May be null. */\r\n    findBone(boneName: string) {\r\n        if (!boneName) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (bone.data.name == boneName) return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @returns -1 if the bone was not found. */\r\n    findBoneIndex(boneName: string) {\r\n        if (!boneName) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n     * repeatedly.\r\n     * @returns May be null. */\r\n    findSlot(slotName: string) {\r\n        if (!slotName) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.data.name == slotName) return slot;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @returns -1 if the bone was not found. */\r\n    findSlotIndex(slotName: string) {\r\n        if (!slotName) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    /** Sets a skin by name.\r\n     *\r\n     * See {@link #setSkin()}. */\r\n    setSkinByName(skinName: string) {\r\n        const skin = this.data.findSkin(skinName);\r\n\r\n        if (!skin) throw new Error(`Skin not found: ${skinName}`);\r\n        this.setSkin(skin);\r\n    }\r\n\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\r\n     * skin is changed, {@link #updateCache()} is called.\r\n     *\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n     * old skin, each slot's setup mode attachment is attached from the new skin.\r\n     *\r\n     * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\r\n     * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\r\n     * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin(newSkin: Skin) {\r\n        if (newSkin == this.skin) return;\r\n        if (newSkin) {\r\n            if (this.skin) newSkin.attachAll(this, this.skin);\r\n            else {\r\n                const slots = this.slots;\r\n\r\n                for (let i = 0, n = slots.length; i < n; i++) {\r\n                    const slot = slots[i];\r\n                    const name = slot.data.attachmentName;\r\n\r\n                    if (name) {\r\n                        const attachment = newSkin.getAttachment(i, name);\r\n\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n        this.updateCache();\r\n    }\r\n\r\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\r\n     * name.\r\n     *\r\n     * See {@link #getAttachment()}.\r\n     * @returns May be null. */\r\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment | null {\r\n        const slot = this.data.findSlot(slotName);\r\n\r\n        if (!slot) throw new Error(`Can't find slot with name ${slotName}`);\r\n\r\n        return this.getAttachment(slot.index, attachmentName);\r\n    }\r\n\r\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\r\n     * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\r\n     *\r\n     * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\r\n     * @returns May be null. */\r\n    getAttachment(slotIndex: number, attachmentName: string): Attachment | null {\r\n        if (!attachmentName) throw new Error('attachmentName cannot be null.');\r\n        if (this.skin) {\r\n            const attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n\r\n            if (attachment) return attachment;\r\n        }\r\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n\r\n        return null;\r\n    }\r\n\r\n    /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\r\n     * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\r\n     * @param attachmentName May be null to clear the slot's attachment. */\r\n    setAttachment(slotName: string, attachmentName: string) {\r\n        if (!slotName) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.data.name == slotName) {\r\n                let attachment: Attachment | null = null;\r\n\r\n                if (attachmentName) {\r\n                    attachment = this.getAttachment(i, attachmentName);\r\n                    if (!attachment) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\r\n                }\r\n                slot.setAttachment(attachment);\r\n\r\n                return;\r\n            }\r\n        }\r\n        throw new Error(`Slot not found: ${slotName}`);\r\n    }\r\n\r\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it repeatedly.\r\n     * @return May be null. */\r\n    findIkConstraint(constraintName: string) {\r\n        if (!constraintName) throw new Error('constraintName cannot be null.');\r\n        const ikConstraints = this.ikConstraints;\r\n\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            const ikConstraint = ikConstraints[i];\r\n\r\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n     * this method than to call it repeatedly.\r\n     * @return May be null. */\r\n    findTransformConstraint(constraintName: string) {\r\n        if (!constraintName) throw new Error('constraintName cannot be null.');\r\n        const transformConstraints = this.transformConstraints;\r\n\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            const constraint = transformConstraints[i];\r\n\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it repeatedly.\r\n     * @return May be null. */\r\n    findPathConstraint(constraintName: string) {\r\n        if (!constraintName) throw new Error('constraintName cannot be null.');\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            const constraint = pathConstraints[i];\r\n\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\r\n     * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\r\n    getBoundsRect() {\r\n        const offset = new Vector2();\r\n        const size = new Vector2();\r\n\r\n        this.getBounds(offset, size);\r\n\r\n        return { x: offset.x, y: offset.y, width: size.x, height: size.y };\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * @param size An output value, the width and height of the AABB.\r\n     * @param temp Working memory to temporarily store attachments' computed world vertices. */\r\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\r\n        if (!offset) throw new Error('offset cannot be null.');\r\n        if (!size) throw new Error('size cannot be null.');\r\n        const drawOrder = this.drawOrder;\r\n        let minX = Number.POSITIVE_INFINITY;\r\n        let minY = Number.POSITIVE_INFINITY;\r\n        let maxX = Number.NEGATIVE_INFINITY;\r\n        let maxY = Number.NEGATIVE_INFINITY;\r\n\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            const slot = drawOrder[i];\r\n\r\n            if (!slot.bone.active) continue;\r\n            let verticesLength = 0;\r\n            let vertices: NumberArrayLike | null = null;\r\n            const attachment = slot.getAttachment();\r\n\r\n            if (attachment instanceof RegionAttachment) {\r\n                verticesLength = 8;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                (<RegionAttachment>attachment).computeWorldVertices(slot, vertices, 0, 2);\r\n            } else if (attachment instanceof MeshAttachment) {\r\n                const mesh = <MeshAttachment>attachment;\r\n\r\n                verticesLength = mesh.worldVerticesLength;\r\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n            }\r\n            if (vertices) {\r\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                    const x = vertices[ii];\r\n                    const y = vertices[ii + 1];\r\n\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n        }\r\n        offset.set(minX, minY);\r\n        size.set(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    get flipX(): boolean {\r\n        return this.scaleX == -1;\r\n    }\r\n\r\n    set flipX(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\r\n        }\r\n        this.scaleX = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    get flipY(): boolean {\r\n        return this.scaleY == -1;\r\n    }\r\n\r\n    set flipY(value: boolean) {\r\n        if (!Skeleton.deprecatedWarning1) {\r\n            Skeleton.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\r\n        }\r\n        this.scaleY = value ? 1.0 : -1.0;\r\n    }\r\n\r\n    private static deprecatedWarning1 = false;\r\n}\r\n","import type { ISkeletonData } from '@pixi-spine/base';\r\nimport type { Animation } from './Animation';\r\nimport type { BoneData } from './BoneData';\r\nimport type { SlotData } from './SlotData';\r\nimport type { Skin } from './Skin';\r\nimport type { EventData } from './EventData';\r\nimport type { IkConstraintData } from './IkConstraintData';\r\nimport type { TransformConstraintData } from './TransformConstraintData';\r\nimport type { PathConstraintData } from './PathConstraintData';\r\n\r\n/** Stores the setup pose and all of the stateless data for a skeleton.\r\n *\r\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\r\n * Guide.\r\n * @public\r\n * */\r\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\r\n    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\r\n    name: string | null = null;\r\n\r\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\r\n    bones = new Array<BoneData>(); // Ordered parents first.\r\n\r\n    /** The skeleton's slots. */\r\n    slots = new Array<SlotData>(); // Setup pose draw order.\r\n    skins = new Array<Skin>();\r\n\r\n    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\r\n     *\r\n     * See {@link Skeleton#getAttachmentByName()}.\r\n     * May be null. */\r\n    defaultSkin: Skin | null = null;\r\n\r\n    /** The skeleton's events. */\r\n    events = new Array<EventData>();\r\n\r\n    /** The skeleton's animations. */\r\n    animations = new Array<Animation>();\r\n\r\n    /** The skeleton's IK constraints. */\r\n    ikConstraints = new Array<IkConstraintData>();\r\n\r\n    /** The skeleton's transform constraints. */\r\n    transformConstraints = new Array<TransformConstraintData>();\r\n\r\n    /** The skeleton's path constraints. */\r\n    pathConstraints = new Array<PathConstraintData>();\r\n\r\n    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n    x = 0;\r\n\r\n    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\r\n    y = 0;\r\n\r\n    /** The width of the skeleton's axis aligned bounding box in the setup pose. */\r\n    width = 0;\r\n\r\n    /** The height of the skeleton's axis aligned bounding box in the setup pose. */\r\n    height = 0;\r\n\r\n    /** The Spine version used to export the skeleton data, or null. */\r\n    version: string | null = null;\r\n\r\n    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\r\n    hash: string | null = null;\r\n\r\n    // Nonessential\r\n    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\r\n    fps = 0;\r\n\r\n    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n    imagesPath: string | null = null;\r\n\r\n    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\r\n    audioPath: string | null = null;\r\n\r\n    /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findBone(boneName: string) {\r\n        if (!boneName) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            const bone = bones[i];\r\n\r\n            if (bone.name == boneName) return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** removed from spine-ts runtime **/\r\n    findBoneIndex(boneName: string) {\r\n        if (!boneName) throw new Error('boneName cannot be null.');\r\n        const bones = this.bones;\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findSlot(slotName: string) {\r\n        if (!slotName) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.name == slotName) return slot;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** removed from spine-ts runtime **/\r\n    findSlotIndex(slotName: string) {\r\n        if (!slotName) throw new Error('slotName cannot be null.');\r\n        const slots = this.slots;\r\n\r\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\r\n\r\n        return -1;\r\n    }\r\n\r\n    /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findSkin(skinName: string) {\r\n        if (!skinName) throw new Error('skinName cannot be null.');\r\n        const skins = this.skins;\r\n\r\n        for (let i = 0, n = skins.length; i < n; i++) {\r\n            const skin = skins[i];\r\n\r\n            if (skin.name == skinName) return skin;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\r\n     * multiple times.\r\n     * @returns May be null. */\r\n    findEvent(eventDataName: string) {\r\n        if (!eventDataName) throw new Error('eventDataName cannot be null.');\r\n        const events = this.events;\r\n\r\n        for (let i = 0, n = events.length; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.name == eventDataName) return event;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\r\n     * call it multiple times.\r\n     * @returns May be null. */\r\n    findAnimation(animationName: string) {\r\n        if (!animationName) throw new Error('animationName cannot be null.');\r\n        const animations = this.animations;\r\n\r\n        for (let i = 0, n = animations.length; i < n; i++) {\r\n            const animation = animations[i];\r\n\r\n            if (animation.name == animationName) return animation;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it multiple times.\r\n     * @return May be null. */\r\n    findIkConstraint(constraintName: string) {\r\n        if (!constraintName) throw new Error('constraintName cannot be null.');\r\n        const ikConstraints = this.ikConstraints;\r\n\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            const constraint = ikConstraints[i];\r\n\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\r\n     * this method than to call it multiple times.\r\n     * @return May be null. */\r\n    findTransformConstraint(constraintName: string) {\r\n        if (!constraintName) throw new Error('constraintName cannot be null.');\r\n        const transformConstraints = this.transformConstraints;\r\n\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            const constraint = transformConstraints[i];\r\n\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\r\n     * than to call it multiple times.\r\n     * @return May be null. */\r\n    findPathConstraint(constraintName: string) {\r\n        if (!constraintName) throw new Error('constraintName cannot be null.');\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            const constraint = pathConstraints[i];\r\n\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** removed from spine-ts runtime **/ findPathConstraintIndex(pathConstraintName: string) {\r\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\r\n        const pathConstraints = this.pathConstraints;\r\n\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\r\n\r\n        return -1;\r\n    }\r\n}\r\n","import { Color } from '@pixi-spine/base';\r\n\r\nimport type { BLEND_MODES } from 'pixi.js';\r\nimport type { ISlotData } from '@pixi-spine/base';\r\nimport type { BoneData } from './BoneData';\r\n\r\n/** Stores the setup pose for a {@link Slot}.\r\n * @public\r\n * */\r\nexport class SlotData implements ISlotData {\r\n    /** The index of the slot in {@link Skeleton#getSlots()}. */\r\n    index = 0;\r\n\r\n    /** The name of the slot, which is unique across all slots in the skeleton. */\r\n    name: string;\r\n\r\n    /** The bone this slot belongs to. */\r\n    boneData: BoneData;\r\n\r\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\r\n     * color tinting. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\r\n     * color's alpha is not used. */\r\n    darkColor: Color | null = null;\r\n\r\n    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\r\n    attachmentName: string | null = null;\r\n\r\n    /** The blend mode for drawing the slot's attachment. */\r\n    blendMode: BLEND_MODES = 'normal';\r\n\r\n    constructor(index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error('index must be >= 0.');\r\n        if (!name) throw new Error('name cannot be null.');\r\n        if (!boneData) throw new Error('boneData cannot be null.');\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n","import type { BoneData } from './BoneData';\r\nimport { ConstraintData } from './ConstraintData';\r\n\r\n/** Stores the setup pose for a {@link TransformConstraint}.\r\n *\r\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\r\n * @public\r\n * */\r\nexport class TransformConstraintData extends ConstraintData {\r\n    /** The bones that will be modified by this transform constraint. */\r\n    bones = new Array<BoneData>();\r\n\r\n    /** The target bone whose world transform will be copied to the constrained bones. */\r\n    private _target: BoneData | null = null;\r\n    public set target(boneData: BoneData) {\r\n        this._target = boneData;\r\n    }\r\n    public get target() {\r\n        if (!this._target) throw new Error('BoneData not set.');\r\n        else return this._target;\r\n    }\r\n\r\n    mixRotate = 0;\r\n    mixX = 0;\r\n    mixY = 0;\r\n    mixScaleX = 0;\r\n    mixScaleY = 0;\r\n    mixShearY = 0;\r\n\r\n    /** An offset added to the constrained bone rotation. */\r\n    offsetRotation = 0;\r\n\r\n    /** An offset added to the constrained bone X translation. */\r\n    offsetX = 0;\r\n\r\n    /** An offset added to the constrained bone Y translation. */\r\n    offsetY = 0;\r\n\r\n    /** An offset added to the constrained bone scaleX. */\r\n    offsetScaleX = 0;\r\n\r\n    /** An offset added to the constrained bone scaleY. */\r\n    offsetScaleY = 0;\r\n\r\n    /** An offset added to the constrained bone shearY. */\r\n    offsetShearY = 0;\r\n\r\n    relative = false;\r\n    local = false;\r\n\r\n    constructor(name: string) {\r\n        super(name, 0, false);\r\n    }\r\n}\r\n","import { Attachment, MeshAttachment } from './attachments';\r\nimport type { BoneData } from './BoneData';\r\nimport type { ConstraintData } from './ConstraintData';\r\nimport type { Skeleton } from './Skeleton';\r\n\r\nimport type { StringMap, ISkin } from '@pixi-spine/base';\r\n\r\n/** Stores an entry in the skin consisting of the slot index, name, and attachment\r\n * @public\r\n * **/\r\nexport class SkinEntry {\r\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) {}\r\n}\r\n\r\n/** Stores attachments by slot index and attachment name.\r\n *\r\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\r\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class Skin implements ISkin {\r\n    /** The skin's name, which is unique across all skins in the skeleton. */\r\n    name: string;\r\n\r\n    attachments = new Array<StringMap<Attachment>>();\r\n    bones = Array<BoneData>();\r\n    constraints = new Array<ConstraintData>();\r\n\r\n    constructor(name: string) {\r\n        if (!name) throw new Error('name cannot be null.');\r\n        this.name = name;\r\n    }\r\n\r\n    /** Adds an attachment to the skin for the specified slot index and name. */\r\n    setAttachment(slotIndex: number, name: string, attachment: Attachment) {\r\n        if (!attachment) throw new Error('attachment cannot be null.');\r\n        const attachments = this.attachments;\r\n\r\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\r\n        attachments[slotIndex][name] = attachment;\r\n    }\r\n\r\n    /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\r\n    addSkin(skin: Skin) {\r\n        for (let i = 0; i < skin.bones.length; i++) {\r\n            const bone = skin.bones[i];\r\n            let contained = false;\r\n\r\n            for (let ii = 0; ii < this.bones.length; ii++) {\r\n                if (this.bones[ii] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for (let i = 0; i < skin.constraints.length; i++) {\r\n            const constraint = skin.constraints[i];\r\n            let contained = false;\r\n\r\n            for (let ii = 0; ii < this.constraints.length; ii++) {\r\n                if (this.constraints[ii] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        const attachments = skin.getAttachments();\r\n\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            const attachment = attachments[i];\r\n\r\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n        }\r\n    }\r\n\r\n    /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\r\n     * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\r\n    copySkin(skin: Skin) {\r\n        for (let i = 0; i < skin.bones.length; i++) {\r\n            const bone = skin.bones[i];\r\n            let contained = false;\r\n\r\n            for (let ii = 0; ii < this.bones.length; ii++) {\r\n                if (this.bones[ii] == bone) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.bones.push(bone);\r\n        }\r\n\r\n        for (let i = 0; i < skin.constraints.length; i++) {\r\n            const constraint = skin.constraints[i];\r\n            let contained = false;\r\n\r\n            for (let ii = 0; ii < this.constraints.length; ii++) {\r\n                if (this.constraints[ii] == constraint) {\r\n                    contained = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!contained) this.constraints.push(constraint);\r\n        }\r\n\r\n        const attachments = skin.getAttachments();\r\n\r\n        for (let i = 0; i < attachments.length; i++) {\r\n            const attachment = attachments[i];\r\n\r\n            if (!attachment.attachment) continue;\r\n            if (attachment.attachment instanceof MeshAttachment) {\r\n                attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            } else {\r\n                attachment.attachment = attachment.attachment.copy();\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the attachment for the specified slot index and name, or null. */\r\n    getAttachment(slotIndex: number, name: string): Attachment | null {\r\n        const dictionary = this.attachments[slotIndex];\r\n\r\n        return dictionary ? dictionary[name] : null;\r\n    }\r\n\r\n    /** Removes the attachment in the skin for the specified slot index and name, if any. */\r\n    removeAttachment(slotIndex: number, name: string) {\r\n        const dictionary = this.attachments[slotIndex];\r\n\r\n        if (dictionary) delete dictionary[name];\r\n    }\r\n\r\n    /** Returns all attachments in this skin. */\r\n    getAttachments(): Array<SkinEntry> {\r\n        const entries = new Array<SkinEntry>();\r\n\r\n        for (let i = 0; i < this.attachments.length; i++) {\r\n            const slotAttachments = this.attachments[i];\r\n\r\n            if (slotAttachments) {\r\n                for (const name in slotAttachments) {\r\n                    const attachment = slotAttachments[name];\r\n\r\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\r\n                }\r\n            }\r\n        }\r\n\r\n        return entries;\r\n    }\r\n\r\n    /** Returns all attachments in this skin for the specified slot index. */\r\n    getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\r\n        const slotAttachments = this.attachments[slotIndex];\r\n\r\n        if (slotAttachments) {\r\n            for (const name in slotAttachments) {\r\n                const attachment = slotAttachments[name];\r\n\r\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Clears all attachments, bones, and constraints. */\r\n    clear() {\r\n        this.attachments.length = 0;\r\n        this.bones.length = 0;\r\n        this.constraints.length = 0;\r\n    }\r\n\r\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\r\n        let slotIndex = 0;\r\n\r\n        for (let i = 0; i < skeleton.slots.length; i++) {\r\n            const slot = skeleton.slots[i];\r\n            const slotAttachment = slot.getAttachment();\r\n\r\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                const dictionary = oldSkin.attachments[slotIndex];\r\n\r\n                for (const key in dictionary) {\r\n                    const skinAttachment: Attachment = dictionary[key];\r\n\r\n                    if (slotAttachment == skinAttachment) {\r\n                        const attachment = this.getAttachment(slotIndex, key);\r\n\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            slotIndex++;\r\n        }\r\n    }\r\n}\r\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\r\nimport {\r\n    AlphaTimeline,\r\n    Animation,\r\n    AttachmentTimeline,\r\n    CurveTimeline,\r\n    CurveTimeline1,\r\n    CurveTimeline2,\r\n    DeformTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RGB2Timeline,\r\n    RGBA2Timeline,\r\n    RGBATimeline,\r\n    RGBTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ScaleXTimeline,\r\n    ScaleYTimeline,\r\n    SequenceTimeline,\r\n    ShearTimeline,\r\n    ShearXTimeline,\r\n    ShearYTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TranslateXTimeline,\r\n    TranslateYTimeline,\r\n} from './Animation';\r\nimport { Event } from './Event';\r\nimport { SkeletonData } from './SkeletonData';\r\nimport { SlotData } from './SlotData';\r\nimport { BoneData } from './BoneData';\r\nimport { IkConstraintData } from './IkConstraintData';\r\nimport { TransformConstraintData } from './TransformConstraintData';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport { Skin } from './Skin';\r\nimport { EventData } from './EventData';\r\nimport { AttachmentType, BinaryInput, Color, IHasTextureRegion, PositionMode, Utils } from '@pixi-spine/base';\r\nimport { Sequence, SequenceModeValues } from './attachments';\r\n\r\n/** Loads skeleton data in the Spine binary format.\r\n *\r\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\r\nexport class SkeletonBinary {\r\n    ver40 = false;\r\n    static BlendModeValues = ['normal', 'add', 'multiply', 'screen'];\r\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n     * runtime than were used in Spine.\r\n     *\r\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\r\n    scale = 1;\r\n\r\n    attachmentLoader: AttachmentLoader;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor(attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData(binary: Uint8Array): SkeletonData {\r\n        const scale = this.scale;\r\n\r\n        const skeletonData = new SkeletonData();\r\n\r\n        skeletonData.name = ''; // BOZO\r\n\r\n        const input = new BinaryInput(binary);\r\n\r\n        const lowHash = input.readInt32();\r\n        const highHash = input.readInt32();\r\n\r\n        skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\r\n        skeletonData.version = input.readString();\r\n        const verShort = skeletonData.version.substr(0, 3);\r\n\r\n        if (verShort !== '4.0' && verShort !== '4.1') {\r\n            const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\r\n\r\n            console.error(error);\r\n        }\r\n        this.ver40 = verShort === '4.0';\r\n        skeletonData.x = input.readFloat();\r\n        skeletonData.y = input.readFloat();\r\n        skeletonData.width = input.readFloat();\r\n        skeletonData.height = input.readFloat();\r\n\r\n        const nonessential = input.readBoolean();\r\n\r\n        if (nonessential) {\r\n            skeletonData.fps = input.readFloat();\r\n\r\n            skeletonData.imagesPath = input.readString();\r\n            skeletonData.audioPath = input.readString();\r\n        }\r\n\r\n        let n = 0;\r\n        // Strings.\r\n\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const str = input.readString();\r\n\r\n            if (!str) throw new Error('String in string table must not be null.');\r\n            input.strings.push(str);\r\n        }\r\n\r\n        // Bones.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const name = input.readString();\r\n\r\n            if (!name) throw new Error('Bone name must not be null.');\r\n            const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n            const data = new BoneData(i, name, parent);\r\n\r\n            data.rotation = input.readFloat();\r\n            data.x = input.readFloat() * scale;\r\n            data.y = input.readFloat() * scale;\r\n            data.scaleX = input.readFloat();\r\n            data.scaleY = input.readFloat();\r\n            data.shearX = input.readFloat();\r\n            data.shearY = input.readFloat();\r\n            data.length = input.readFloat() * scale;\r\n            data.transformMode = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\r\n            skeletonData.bones.push(data);\r\n        }\r\n\r\n        // Slots.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const slotName = input.readString();\r\n\r\n            if (!slotName) throw new Error('Slot name must not be null.');\r\n            const boneData = skeletonData.bones[input.readInt(true)];\r\n            const data = new SlotData(i, slotName, boneData);\r\n\r\n            Color.rgba8888ToColor(data.color, input.readInt32());\r\n\r\n            const darkColor = input.readInt32();\r\n\r\n            if (darkColor != -1) Color.rgb888ToColor((data.darkColor = new Color()), darkColor);\r\n\r\n            data.attachmentName = input.readStringRef();\r\n            data.blendMode = SkeletonBinary.blendModeFromNumber(input.readInt(true));\r\n            skeletonData.slots.push(data);\r\n        }\r\n\r\n        // IK constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const name = input.readString();\r\n\r\n            if (!name) throw new Error('IK constraint data name must not be null.');\r\n            const data = new IkConstraintData(name);\r\n\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.mix = input.readFloat();\r\n            data.softness = input.readFloat() * scale;\r\n            data.bendDirection = input.readByte();\r\n            data.compress = input.readBoolean();\r\n            data.stretch = input.readBoolean();\r\n            data.uniform = input.readBoolean();\r\n            skeletonData.ikConstraints.push(data);\r\n        }\r\n\r\n        // Transform constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const name = input.readString();\r\n\r\n            if (!name) throw new Error('Transform constraint data name must not be null.');\r\n            const data = new TransformConstraintData(name);\r\n\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.bones[input.readInt(true)];\r\n            data.local = input.readBoolean();\r\n            data.relative = input.readBoolean();\r\n            data.offsetRotation = input.readFloat();\r\n            data.offsetX = input.readFloat() * scale;\r\n            data.offsetY = input.readFloat() * scale;\r\n            data.offsetScaleX = input.readFloat();\r\n            data.offsetScaleY = input.readFloat();\r\n            data.offsetShearY = input.readFloat();\r\n            data.mixRotate = input.readFloat();\r\n            data.mixX = input.readFloat();\r\n            data.mixY = input.readFloat();\r\n            data.mixScaleX = input.readFloat();\r\n            data.mixScaleY = input.readFloat();\r\n            data.mixShearY = input.readFloat();\r\n            skeletonData.transformConstraints.push(data);\r\n        }\r\n\r\n        // Path constraints.\r\n        n = input.readInt(true);\r\n        for (let i = 0, nn; i < n; i++) {\r\n            const name = input.readString();\r\n\r\n            if (!name) throw new Error('Path constraint data name must not be null.');\r\n            const data = new PathConstraintData(name);\r\n\r\n            data.order = input.readInt(true);\r\n            data.skinRequired = input.readBoolean();\r\n            nn = input.readInt(true);\r\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\r\n            data.target = skeletonData.slots[input.readInt(true)];\r\n            data.positionMode = input.readInt(true);\r\n            data.spacingMode = input.readInt(true);\r\n            data.rotateMode = input.readInt(true);\r\n            data.offsetRotation = input.readFloat();\r\n            data.position = input.readFloat();\r\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n            data.spacing = input.readFloat();\r\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n            data.mixRotate = input.readFloat();\r\n            data.mixX = input.readFloat();\r\n            data.mixY = input.readFloat();\r\n            skeletonData.pathConstraints.push(data);\r\n        }\r\n\r\n        // Default skin.\r\n        const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n\r\n        if (defaultSkin) {\r\n            skeletonData.defaultSkin = defaultSkin;\r\n            skeletonData.skins.push(defaultSkin);\r\n        }\r\n\r\n        // Skins.\r\n        {\r\n            let i = skeletonData.skins.length;\r\n\r\n            Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\r\n            for (; i < n; i++) {\r\n                const skin = this.readSkin(input, skeletonData, false, nonessential);\r\n\r\n                if (!skin) throw new Error('readSkin() should not have returned null.');\r\n                skeletonData.skins[i] = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        n = this.linkedMeshes.length;\r\n        for (let i = 0; i < n; i++) {\r\n            const linkedMesh = this.linkedMeshes[i];\r\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\r\n            if (!skin) throw new Error('Not skin found for linked mesh.');\r\n            if (!linkedMesh.parent) throw new Error('Linked mesh parent must not be null');\r\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\r\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? (parent as VertexAttachment) : linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\r\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const eventName = input.readStringRef();\r\n\r\n            if (!eventName) throw new Error();\r\n            const data = new EventData(eventName);\r\n\r\n            data.intValue = input.readInt(false);\r\n            data.floatValue = input.readFloat();\r\n            data.stringValue = input.readString();\r\n            data.audioPath = input.readString();\r\n            if (data.audioPath) {\r\n                data.volume = input.readFloat();\r\n                data.balance = input.readFloat();\r\n            }\r\n            skeletonData.events.push(data);\r\n        }\r\n\r\n        // Animations.\r\n        n = input.readInt(true);\r\n        for (let i = 0; i < n; i++) {\r\n            const animationName = input.readString();\r\n\r\n            if (!animationName) throw new Error('Animatio name must not be null.');\r\n            skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    private readSkin(input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin | null {\r\n        let skin = null;\r\n        let slotCount = 0;\r\n\r\n        if (defaultSkin) {\r\n            slotCount = input.readInt(true);\r\n            if (slotCount == 0) return null;\r\n            skin = new Skin('default');\r\n        } else {\r\n            const skinName = input.readStringRef();\r\n\r\n            if (!skinName) throw new Error('Skin name must not be null.');\r\n            skin = new Skin(skinName);\r\n            skin.bones.length = input.readInt(true);\r\n            for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n\r\n            slotCount = input.readInt(true);\r\n        }\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            const slotIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const name = input.readStringRef();\r\n\r\n                if (!name) throw new Error('Attachment name must not be null');\r\n                const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\r\n\r\n                if (attachment) skin.setAttachment(slotIndex, name, attachment);\r\n            }\r\n        }\r\n\r\n        return skin;\r\n    }\r\n\r\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment | null {\r\n        const scale = this.scale;\r\n\r\n        let name = input.readStringRef();\r\n\r\n        if (!name) name = attachmentName;\r\n\r\n        switch (input.readByte()) {\r\n            case AttachmentType.Region: {\r\n                let path = input.readStringRef();\r\n                const rotation = input.readFloat();\r\n                const x = input.readFloat();\r\n                const y = input.readFloat();\r\n                const scaleX = input.readFloat();\r\n                const scaleY = input.readFloat();\r\n                const width = input.readFloat();\r\n                const height = input.readFloat();\r\n                const color = input.readInt32();\r\n                const sequence = this.readSequence(input);\r\n\r\n                if (!path) path = name;\r\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\r\n\r\n                if (!region) return null;\r\n                region.path = path;\r\n                region.x = x * scale;\r\n                region.y = y * scale;\r\n                region.scaleX = scaleX;\r\n                region.scaleY = scaleY;\r\n                region.rotation = rotation;\r\n                region.width = width * scale;\r\n                region.height = height * scale;\r\n                Color.rgba8888ToColor(region.color, color);\r\n                region.sequence = sequence;\r\n                if (sequence == null) region.updateRegion();\r\n\r\n                return region;\r\n            }\r\n            case AttachmentType.BoundingBox: {\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\r\n                if (!box) return null;\r\n                box.worldVerticesLength = vertexCount << 1;\r\n                box.vertices = vertices.vertices;\r\n                box.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\r\n\r\n                return box;\r\n            }\r\n            case AttachmentType.Mesh: {\r\n                let path = input.readStringRef();\r\n                const color = input.readInt32();\r\n                const vertexCount = input.readInt(true);\r\n                const uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n                const triangles = this.readShortArray(input);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const hullLength = input.readInt(true);\r\n                const sequence = this.readSequence(input);\r\n                let edges: number[] = [];\r\n                let width = 0;\r\n                let height = 0;\r\n\r\n                if (nonessential) {\r\n                    edges = this.readShortArray(input);\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (!path) path = name;\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\r\n\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                mesh.bones = vertices.bones;\r\n                mesh.vertices = vertices.vertices;\r\n                mesh.worldVerticesLength = vertexCount << 1;\r\n                mesh.triangles = triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // if (sequence == null) mesh.updateRegion();\r\n                mesh.hullLength = hullLength << 1;\r\n                mesh.sequence = sequence;\r\n                if (nonessential) {\r\n                    mesh.edges = edges;\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n\r\n                return mesh;\r\n            }\r\n            case AttachmentType.LinkedMesh: {\r\n                let path = input.readStringRef();\r\n                const color = input.readInt32();\r\n                const skinName = input.readStringRef();\r\n                const parent = input.readStringRef();\r\n                const inheritTimelines = input.readBoolean();\r\n                const sequence = this.readSequence(input);\r\n                let width = 0;\r\n                let height = 0;\r\n\r\n                if (nonessential) {\r\n                    width = input.readFloat();\r\n                    height = input.readFloat();\r\n                }\r\n\r\n                if (!path) path = name;\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\r\n\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                Color.rgba8888ToColor(mesh.color, color);\r\n                mesh.sequence = sequence;\r\n                if (nonessential) {\r\n                    mesh.width = width * scale;\r\n                    mesh.height = height * scale;\r\n                }\r\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\r\n\r\n                return mesh;\r\n            }\r\n            case AttachmentType.Path: {\r\n                const closed = input.readBoolean();\r\n                const constantSpeed = input.readBoolean();\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const lengths = Utils.newArray(vertexCount / 3, 0);\r\n\r\n                for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\r\n                if (!path) return null;\r\n                path.closed = closed;\r\n                path.constantSpeed = constantSpeed;\r\n                path.worldVerticesLength = vertexCount << 1;\r\n                path.vertices = vertices.vertices;\r\n                path.bones = vertices.bones;\r\n                path.lengths = lengths;\r\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\r\n\r\n                return path;\r\n            }\r\n            case AttachmentType.Point: {\r\n                const rotation = input.readFloat();\r\n                const x = input.readFloat();\r\n                const y = input.readFloat();\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\r\n                if (!point) return null;\r\n                point.x = x * scale;\r\n                point.y = y * scale;\r\n                point.rotation = rotation;\r\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\r\n\r\n                return point;\r\n            }\r\n            case AttachmentType.Clipping: {\r\n                const endSlotIndex = input.readInt(true);\r\n                const vertexCount = input.readInt(true);\r\n                const vertices = this.readVertices(input, vertexCount);\r\n                const color = nonessential ? input.readInt32() : 0;\r\n\r\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\r\n                if (!clip) return null;\r\n                clip.endSlot = skeletonData.slots[endSlotIndex];\r\n                clip.worldVerticesLength = vertexCount << 1;\r\n                clip.vertices = vertices.vertices;\r\n                clip.bones = vertices.bones;\r\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\r\n\r\n                return clip;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private readSequence(input: BinaryInput) {\r\n        if (this.ver40 || !input.readBoolean()) return null;\r\n        const sequence = new Sequence(input.readInt(true));\r\n\r\n        sequence.start = input.readInt(true);\r\n        sequence.digits = input.readInt(true);\r\n        sequence.setupIndex = input.readInt(true);\r\n\r\n        return sequence;\r\n    }\r\n\r\n    private readDeformTimelineType(input: BinaryInput) {\r\n        if (this.ver40) return ATTACHMENT_DEFORM;\r\n\r\n        return input.readByte();\r\n    }\r\n\r\n    private readVertices(input: BinaryInput, vertexCount: number): Vertices {\r\n        const scale = this.scale;\r\n        const verticesLength = vertexCount << 1;\r\n        const vertices = new Vertices();\r\n\r\n        if (!input.readBoolean()) {\r\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n\r\n            return vertices;\r\n        }\r\n        const weights = new Array<number>();\r\n        const bonesArray = new Array<number>();\r\n\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const boneCount = input.readInt(true);\r\n\r\n            bonesArray.push(boneCount);\r\n            for (let ii = 0; ii < boneCount; ii++) {\r\n                bonesArray.push(input.readInt(true));\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat() * scale);\r\n                weights.push(input.readFloat());\r\n            }\r\n        }\r\n        vertices.vertices = Utils.toFloatArray(weights);\r\n        vertices.bones = bonesArray;\r\n\r\n        return vertices;\r\n    }\r\n\r\n    private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\r\n        const array = new Array<number>(n);\r\n\r\n        if (scale == 1) {\r\n            for (let i = 0; i < n; i++) array[i] = input.readFloat();\r\n        } else {\r\n            for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n    private readShortArray(input: BinaryInput): number[] {\r\n        const n = input.readInt(true);\r\n        const array = new Array<number>(n);\r\n\r\n        for (let i = 0; i < n; i++) array[i] = input.readShort();\r\n\r\n        return array;\r\n    }\r\n\r\n    private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\r\n        input.readInt(true); // Number of timelines.\r\n        const timelines = new Array<Timeline>();\r\n        const scale = this.scale;\r\n        // Slot timelines.\r\n\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const slotIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const timelineType = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n                const frameLast = frameCount - 1;\r\n\r\n                switch (timelineType) {\r\n                    case SLOT_ATTACHMENT: {\r\n                        const timeline = new AttachmentTimeline(frameCount, slotIndex);\r\n\r\n                        for (let frame = 0; frame < frameCount; frame++) timeline.setFrame(frame, input.readFloat(), input.readStringRef());\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGBA: {\r\n                        const bezierCount = input.readInt(true);\r\n                        const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let a = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, a);\r\n                            if (frame == frameLast) break;\r\n\r\n                            const time2 = input.readFloat();\r\n                            const r2 = input.readUnsignedByte() / 255.0;\r\n                            const g2 = input.readUnsignedByte() / 255.0;\r\n                            const b2 = input.readUnsignedByte() / 255.0;\r\n                            const a2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = r2;\r\n                            g = g2;\r\n                            b = b2;\r\n                            a = a2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGB: {\r\n                        const bezierCount = input.readInt(true);\r\n                        const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b);\r\n                            if (frame == frameLast) break;\r\n\r\n                            const time2 = input.readFloat();\r\n                            const r2 = input.readUnsignedByte() / 255.0;\r\n                            const g2 = input.readUnsignedByte() / 255.0;\r\n                            const b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = r2;\r\n                            g = g2;\r\n                            b = b2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGBA2: {\r\n                        const bezierCount = input.readInt(true);\r\n                        const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let a = input.readUnsignedByte() / 255.0;\r\n                        let r2 = input.readUnsignedByte() / 255.0;\r\n                        let g2 = input.readUnsignedByte() / 255.0;\r\n                        let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\r\n                            if (frame == frameLast) break;\r\n                            const time2 = input.readFloat();\r\n                            const nr = input.readUnsignedByte() / 255.0;\r\n                            const ng = input.readUnsignedByte() / 255.0;\r\n                            const nb = input.readUnsignedByte() / 255.0;\r\n                            const na = input.readUnsignedByte() / 255.0;\r\n                            const nr2 = input.readUnsignedByte() / 255.0;\r\n                            const ng2 = input.readUnsignedByte() / 255.0;\r\n                            const nb2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = nr;\r\n                            g = ng;\r\n                            b = nb;\r\n                            a = na;\r\n                            r2 = nr2;\r\n                            g2 = ng2;\r\n                            b2 = nb2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_RGB2: {\r\n                        const bezierCount = input.readInt(true);\r\n                        const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\r\n\r\n                        let time = input.readFloat();\r\n                        let r = input.readUnsignedByte() / 255.0;\r\n                        let g = input.readUnsignedByte() / 255.0;\r\n                        let b = input.readUnsignedByte() / 255.0;\r\n                        let r2 = input.readUnsignedByte() / 255.0;\r\n                        let g2 = input.readUnsignedByte() / 255.0;\r\n                        let b2 = input.readUnsignedByte() / 255.0;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\r\n                            if (frame == frameLast) break;\r\n                            const time2 = input.readFloat();\r\n                            const nr = input.readUnsignedByte() / 255.0;\r\n                            const ng = input.readUnsignedByte() / 255.0;\r\n                            const nb = input.readUnsignedByte() / 255.0;\r\n                            const nr2 = input.readUnsignedByte() / 255.0;\r\n                            const ng2 = input.readUnsignedByte() / 255.0;\r\n                            const nb2 = input.readUnsignedByte() / 255.0;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\r\n                            }\r\n                            time = time2;\r\n                            r = nr;\r\n                            g = ng;\r\n                            b = nb;\r\n                            r2 = nr2;\r\n                            g2 = ng2;\r\n                            b2 = nb2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        break;\r\n                    }\r\n                    case SLOT_ALPHA: {\r\n                        const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\r\n                        let time = input.readFloat();\r\n                        let a = input.readUnsignedByte() / 255;\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, a);\r\n                            if (frame == frameLast) break;\r\n                            const time2 = input.readFloat();\r\n                            const a2 = input.readUnsignedByte() / 255;\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\r\n                            }\r\n                            time = time2;\r\n                            a = a2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const boneIndex = input.readInt(true);\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const type = input.readByte();\r\n                const frameCount = input.readInt(true);\r\n                const bezierCount = input.readInt(true);\r\n\r\n                switch (type) {\r\n                    case BONE_ROTATE:\r\n                        timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_TRANSLATE:\r\n                        timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_TRANSLATEX:\r\n                        timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_TRANSLATEY:\r\n                        timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\r\n                        break;\r\n                    case BONE_SCALE:\r\n                        timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SCALEX:\r\n                        timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SCALEY:\r\n                        timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEAR:\r\n                        timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEARX:\r\n                        timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                        break;\r\n                    case BONE_SHEARY:\r\n                        timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const frameCount = input.readInt(true);\r\n            const frameLast = frameCount - 1;\r\n            const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\r\n            let time = input.readFloat();\r\n            let mix = input.readFloat();\r\n            let softness = input.readFloat() * scale;\r\n\r\n            for (let frame = 0, bezier = 0; ; frame++) {\r\n                timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\r\n                if (frame == frameLast) break;\r\n                const time2 = input.readFloat();\r\n                const mix2 = input.readFloat();\r\n                const softness2 = input.readFloat() * scale;\r\n\r\n                switch (input.readByte()) {\r\n                    case CURVE_STEPPED:\r\n                        timeline.setStepped(frame);\r\n                        break;\r\n                    case CURVE_BEZIER:\r\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\r\n                }\r\n                time = time2;\r\n                mix = mix2;\r\n                softness = softness2;\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const frameCount = input.readInt(true);\r\n            const frameLast = frameCount - 1;\r\n            const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\r\n            let time = input.readFloat();\r\n            let mixRotate = input.readFloat();\r\n            let mixX = input.readFloat();\r\n            let mixY = input.readFloat();\r\n            let mixScaleX = input.readFloat();\r\n            let mixScaleY = input.readFloat();\r\n            let mixShearY = input.readFloat();\r\n\r\n            for (let frame = 0, bezier = 0; ; frame++) {\r\n                timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\r\n                if (frame == frameLast) break;\r\n                const time2 = input.readFloat();\r\n                const mixRotate2 = input.readFloat();\r\n                const mixX2 = input.readFloat();\r\n                const mixY2 = input.readFloat();\r\n                const mixScaleX2 = input.readFloat();\r\n                const mixScaleY2 = input.readFloat();\r\n                const mixShearY2 = input.readFloat();\r\n\r\n                switch (input.readByte()) {\r\n                    case CURVE_STEPPED:\r\n                        timeline.setStepped(frame);\r\n                        break;\r\n                    case CURVE_BEZIER:\r\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\r\n                        setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\r\n                }\r\n                time = time2;\r\n                mixRotate = mixRotate2;\r\n                mixX = mixX2;\r\n                mixY = mixY2;\r\n                mixScaleX = mixScaleX2;\r\n                mixScaleY = mixScaleY2;\r\n                mixShearY = mixShearY2;\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const index = input.readInt(true);\r\n            const data = skeletonData.pathConstraints[index];\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                switch (input.readByte()) {\r\n                    case PATH_POSITION:\r\n                        timelines.push(\r\n                            readTimeline1(\r\n                                input,\r\n                                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\r\n                                data.positionMode == PositionMode.Fixed ? scale : 1\r\n                            )\r\n                        );\r\n                        break;\r\n                    case PATH_SPACING:\r\n                        timelines.push(\r\n                            readTimeline1(\r\n                                input,\r\n                                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\r\n                                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1\r\n                            )\r\n                        );\r\n                        break;\r\n                    case PATH_MIX:\r\n                        const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\r\n                        let time = input.readFloat();\r\n                        let mixRotate = input.readFloat();\r\n                        let mixX = input.readFloat();\r\n                        let mixY = input.readFloat();\r\n\r\n                        for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\r\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\r\n                            if (frame == frameLast) break;\r\n                            const time2 = input.readFloat();\r\n                            const mixRotate2 = input.readFloat();\r\n                            const mixX2 = input.readFloat();\r\n                            const mixY2 = input.readFloat();\r\n\r\n                            switch (input.readByte()) {\r\n                                case CURVE_STEPPED:\r\n                                    timeline.setStepped(frame);\r\n                                    break;\r\n                                case CURVE_BEZIER:\r\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\r\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\r\n                            }\r\n                            time = time2;\r\n                            mixRotate = mixRotate2;\r\n                            mixX = mixX2;\r\n                            mixY = mixY2;\r\n                        }\r\n                        timelines.push(timeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\r\n            const skin = skeletonData.skins[input.readInt(true)];\r\n\r\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                const slotIndex = input.readInt(true);\r\n\r\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n                    const attachmentName = input.readStringRef();\r\n\r\n                    if (!attachmentName) throw new Error('attachmentName must not be null.');\r\n                    const attachment = skin.getAttachment(slotIndex, attachmentName);\r\n                    const timelineType = this.readDeformTimelineType(input);\r\n                    const frameCount = input.readInt(true);\r\n                    const frameLast = frameCount - 1;\r\n\r\n                    switch (timelineType) {\r\n                        case ATTACHMENT_DEFORM: {\r\n                            const vertexAttachment = attachment as VertexAttachment;\r\n                            const weighted = vertexAttachment.bones;\r\n                            const vertices = vertexAttachment.vertices;\r\n                            const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\r\n\r\n                            const bezierCount = input.readInt(true);\r\n                            const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\r\n\r\n                            let time = input.readFloat();\r\n\r\n                            for (let frame = 0, bezier = 0; ; frame++) {\r\n                                let deform;\r\n                                let end = input.readInt(true);\r\n\r\n                                if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                                else {\r\n                                    deform = Utils.newFloatArray(deformLength);\r\n                                    const start = input.readInt(true);\r\n\r\n                                    end += start;\r\n                                    /* eslint-disable max-depth*/\r\n                                    if (scale == 1) {\r\n                                        for (let v = start; v < end; v++) deform[v] = input.readFloat();\r\n                                    } else {\r\n                                        for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\r\n                                    }\r\n                                    if (!weighted) {\r\n                                        for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\r\n                                    }\r\n                                    /* eslint-enable max-depth*/\r\n                                }\r\n\r\n                                timeline.setFrame(frame, time, deform);\r\n                                if (frame == frameLast) break;\r\n                                const time2 = input.readFloat();\r\n\r\n                                switch (input.readByte()) {\r\n                                    case CURVE_STEPPED:\r\n                                        timeline.setStepped(frame);\r\n                                        break;\r\n                                    case CURVE_BEZIER:\r\n                                        setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\r\n                                }\r\n                                time = time2;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            break;\r\n                        }\r\n                        case ATTACHMENT_SEQUENCE: {\r\n                            const timeline = new SequenceTimeline(frameCount, slotIndex, attachment as unknown as IHasTextureRegion);\r\n\r\n                            for (let frame = 0; frame < frameCount; frame++) {\r\n                                const time = input.readFloat();\r\n                                const modeAndIndex = input.readInt32();\r\n\r\n                                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 0xf], modeAndIndex >> 4, input.readFloat());\r\n                            }\r\n                            timelines.push(timeline);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        const drawOrderCount = input.readInt(true);\r\n\r\n        if (drawOrderCount > 0) {\r\n            const timeline = new DrawOrderTimeline(drawOrderCount);\r\n            const slotCount = skeletonData.slots.length;\r\n\r\n            for (let i = 0; i < drawOrderCount; i++) {\r\n                const time = input.readFloat();\r\n                const offsetCount = input.readInt(true);\r\n                const drawOrder = Utils.newArray(slotCount, 0);\r\n\r\n                for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\r\n                const unchanged = Utils.newArray(slotCount - offsetCount, 0);\r\n                let originalIndex = 0;\r\n                let unchangedIndex = 0;\r\n\r\n                for (let ii = 0; ii < offsetCount; ii++) {\r\n                    const slotIndex = input.readInt(true);\r\n                    // Collect unchanged items.\r\n\r\n                    while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Set changed items.\r\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n                }\r\n                // Collect remaining unchanged items.\r\n                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\r\n                // Fill in unchanged items.\r\n                for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                timeline.setFrame(i, time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Event timeline.\r\n        const eventCount = input.readInt(true);\r\n\r\n        if (eventCount > 0) {\r\n            const timeline = new EventTimeline(eventCount);\r\n\r\n            for (let i = 0; i < eventCount; i++) {\r\n                const time = input.readFloat();\r\n                const eventData = skeletonData.events[input.readInt(true)];\r\n                const event = new Event(time, eventData);\r\n\r\n                event.intValue = input.readInt(false);\r\n                event.floatValue = input.readFloat();\r\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n                if (event.data.audioPath) {\r\n                    event.volume = input.readFloat();\r\n                    event.balance = input.readFloat();\r\n                }\r\n                timeline.setFrame(i, event);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        let duration = 0;\r\n\r\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\r\n\r\n        return new Animation(name, timelines, duration);\r\n    }\r\n\r\n    static blendModeFromNumber(num: number) {\r\n        if (num == 0) return 'normal';\r\n        if (num == 1) return 'add';\r\n        if (num == 2) return 'multiply';\r\n        if (num == 3) return 'screen';\r\n        throw new Error(`Unknown blend mode: ${num}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string | null;\r\n    skin: string | null;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritTimeline: boolean;\r\n\r\n    constructor(mesh: MeshAttachment, skin: string | null, slotIndex: number, parent: string | null, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritTimeline = inheritDeform;\r\n    }\r\n}\r\n\r\nclass Vertices {\r\n    constructor(public bones: Array<number> | null = null, public vertices: Array<number> | Float32Array | null = null) {}\r\n}\r\n\r\nfunction readTimeline1(input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\r\n    let time = input.readFloat();\r\n    let value = input.readFloat() * scale;\r\n\r\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\r\n        timeline.setFrame(frame, time, value);\r\n        if (frame == frameLast) break;\r\n        const time2 = input.readFloat();\r\n        const value2 = input.readFloat() * scale;\r\n\r\n        switch (input.readByte()) {\r\n            case CURVE_STEPPED:\r\n                timeline.setStepped(frame);\r\n                break;\r\n            case CURVE_BEZIER:\r\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\r\n        }\r\n        time = time2;\r\n        value = value2;\r\n    }\r\n\r\n    return timeline;\r\n}\r\n\r\nfunction readTimeline2(input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\r\n    let time = input.readFloat();\r\n    let value1 = input.readFloat() * scale;\r\n    let value2 = input.readFloat() * scale;\r\n\r\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\r\n        timeline.setFrame(frame, time, value1, value2);\r\n        if (frame == frameLast) break;\r\n        const time2 = input.readFloat();\r\n        const nvalue1 = input.readFloat() * scale;\r\n        const nvalue2 = input.readFloat() * scale;\r\n\r\n        switch (input.readByte()) {\r\n            case CURVE_STEPPED:\r\n                timeline.setStepped(frame);\r\n                break;\r\n            case CURVE_BEZIER:\r\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\r\n                setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\r\n        }\r\n        time = time2;\r\n        value1 = nvalue1;\r\n        value2 = nvalue2;\r\n    }\r\n\r\n    return timeline;\r\n}\r\n\r\nfunction setBezier(\r\n    input: BinaryInput,\r\n    timeline: CurveTimeline,\r\n    bezier: number,\r\n    frame: number,\r\n    value: number,\r\n    time1: number,\r\n    time2: number,\r\n    value1: number,\r\n    value2: number,\r\n    scale: number\r\n) {\r\n    timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\r\n}\r\n\r\nconst BONE_ROTATE = 0;\r\nconst BONE_TRANSLATE = 1;\r\nconst BONE_TRANSLATEX = 2;\r\nconst BONE_TRANSLATEY = 3;\r\nconst BONE_SCALE = 4;\r\nconst BONE_SCALEX = 5;\r\nconst BONE_SCALEY = 6;\r\nconst BONE_SHEAR = 7;\r\nconst BONE_SHEARX = 8;\r\nconst BONE_SHEARY = 9;\r\n\r\nconst SLOT_ATTACHMENT = 0;\r\nconst SLOT_RGBA = 1;\r\nconst SLOT_RGB = 2;\r\nconst SLOT_RGBA2 = 3;\r\nconst SLOT_RGB2 = 4;\r\nconst SLOT_ALPHA = 5;\r\n\r\nconst ATTACHMENT_DEFORM = 0;\r\nconst ATTACHMENT_SEQUENCE = 1;\r\n\r\nconst PATH_POSITION = 0;\r\nconst PATH_SPACING = 1;\r\nconst PATH_MIX = 2;\r\n\r\n// const CURVE_LINEAR = 0;\r\nconst CURVE_STEPPED = 1;\r\nconst CURVE_BEZIER = 2;\r\n","import type { BoundingBoxAttachment } from './attachments';\r\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\r\n\r\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\r\n * provided along with convenience methods for doing hit detection.\r\n * @public\r\n * */\r\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\r\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\r\nimport {\r\n    AlphaTimeline,\r\n    Animation,\r\n    AttachmentTimeline,\r\n    CurveTimeline,\r\n    CurveTimeline1,\r\n    CurveTimeline2,\r\n    DeformTimeline,\r\n    DrawOrderTimeline,\r\n    EventTimeline,\r\n    IkConstraintTimeline,\r\n    PathConstraintMixTimeline,\r\n    PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline,\r\n    RGB2Timeline,\r\n    RGBA2Timeline,\r\n    RGBATimeline,\r\n    RGBTimeline,\r\n    RotateTimeline,\r\n    ScaleTimeline,\r\n    ScaleXTimeline,\r\n    ScaleYTimeline,\r\n    SequenceTimeline,\r\n    ShearTimeline,\r\n    ShearXTimeline,\r\n    ShearYTimeline,\r\n    Timeline,\r\n    TransformConstraintTimeline,\r\n    TranslateTimeline,\r\n    TranslateXTimeline,\r\n    TranslateYTimeline,\r\n} from './Animation';\r\nimport { Event } from './Event';\r\nimport { SkeletonData } from './SkeletonData';\r\nimport { SlotData } from './SlotData';\r\nimport { BoneData } from './BoneData';\r\nimport { IkConstraintData } from './IkConstraintData';\r\nimport { TransformConstraintData } from './TransformConstraintData';\r\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\r\nimport { Skin } from './Skin';\r\nimport { EventData } from './EventData';\r\nimport { NumberArrayLike, Color, IHasTextureRegion, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\r\nimport { Sequence, SequenceMode } from './attachments/Sequence';\r\n\r\n/** Loads skeleton data in the Spine JSON format.\r\n *\r\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\r\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\r\n * Runtimes Guide.\r\n * @public\r\n * */\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n\r\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\r\n     * runtime than were used in Spine.\r\n     *\r\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor(attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData(json: string | any): SkeletonData {\r\n        const scale = this.scale;\r\n        const skeletonData = new SkeletonData();\r\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        const skeletonMap = root.skeleton;\r\n\r\n        if (skeletonMap) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            const verShort = skeletonData.version.substr(0, 3);\r\n\r\n            if (verShort !== '4.0' && verShort !== '4.1') {\r\n                const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\r\n\r\n                console.error(error);\r\n            }\r\n            skeletonData.x = skeletonMap.x;\r\n            skeletonData.y = skeletonMap.y;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.fps = skeletonMap.fps;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                const boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                const parentName: string = getValue(boneMap, 'parent', null);\r\n\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\r\n                }\r\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n\r\n                data.length = getValue(boneMap, 'length', 0) * scale;\r\n                data.x = getValue(boneMap, 'x', 0) * scale;\r\n                data.y = getValue(boneMap, 'y', 0) * scale;\r\n                data.rotation = getValue(boneMap, 'rotation', 0);\r\n                data.scaleX = getValue(boneMap, 'scaleX', 1);\r\n                data.scaleY = getValue(boneMap, 'scaleY', 1);\r\n                data.shearX = getValue(boneMap, 'shearX', 0);\r\n                data.shearY = getValue(boneMap, 'shearY', 0);\r\n                data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, 'transform', 'Normal'));\r\n                data.skinRequired = getValue(boneMap, 'skin', false);\r\n\r\n                const color = getValue(boneMap, 'color', null);\r\n\r\n                if (color) data.color.setFromString(color);\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                const slotMap = root.slots[i];\r\n                const boneData = skeletonData.findBone(slotMap.bone);\r\n\r\n                if (!boneData) throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);\r\n                const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\r\n\r\n                const color: string = getValue(slotMap, 'color', null);\r\n\r\n                if (color) data.color.setFromString(color);\r\n\r\n                const dark: string = getValue(slotMap, 'dark', null);\r\n\r\n                if (dark) data.darkColor = Color.fromString(dark);\r\n\r\n                data.attachmentName = getValue(slotMap, 'attachment', null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, 'blend', 'normal'));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                const constraintMap = root.ik[i];\r\n                const data = new IkConstraintData(constraintMap.name);\r\n\r\n                data.order = getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = getValue(constraintMap, 'skin', false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    const boneName = constraintMap.bones[ii];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                data.target = skeletonData.findBone(constraintMap.target);\r\n\r\n                data.mix = getValue(constraintMap, 'mix', 1);\r\n                data.softness = getValue(constraintMap, 'softness', 0) * scale;\r\n                data.bendDirection = getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\r\n                data.compress = getValue(constraintMap, 'compress', false);\r\n                data.stretch = getValue(constraintMap, 'stretch', false);\r\n                data.uniform = getValue(constraintMap, 'uniform', false);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                const constraintMap = root.transform[i];\r\n                const data = new TransformConstraintData(constraintMap.name);\r\n\r\n                data.order = getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = getValue(constraintMap, 'skin', false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    const boneName = constraintMap.bones[ii];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n                const target = skeletonData.findBone(targetName);\r\n\r\n                if (!target) throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\r\n                data.target = target;\r\n\r\n                data.local = getValue(constraintMap, 'local', false);\r\n                data.relative = getValue(constraintMap, 'relative', false);\r\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\r\n                data.offsetX = getValue(constraintMap, 'x', 0) * scale;\r\n                data.offsetY = getValue(constraintMap, 'y', 0) * scale;\r\n                data.offsetScaleX = getValue(constraintMap, 'scaleX', 0);\r\n                data.offsetScaleY = getValue(constraintMap, 'scaleY', 0);\r\n                data.offsetShearY = getValue(constraintMap, 'shearY', 0);\r\n\r\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\r\n                data.mixX = getValue(constraintMap, 'mixX', 1);\r\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\r\n                data.mixScaleX = getValue(constraintMap, 'mixScaleX', 1);\r\n                data.mixScaleY = getValue(constraintMap, 'mixScaleY', data.mixScaleX);\r\n                data.mixShearY = getValue(constraintMap, 'mixShearY', 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                const constraintMap = root.path[i];\r\n                const data = new PathConstraintData(constraintMap.name);\r\n\r\n                data.order = getValue(constraintMap, 'order', 0);\r\n                data.skinRequired = getValue(constraintMap, 'skin', false);\r\n\r\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\r\n                    const boneName = constraintMap.bones[ii];\r\n                    const bone = skeletonData.findBone(boneName);\r\n\r\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                const targetName: string = constraintMap.target;\r\n                const target = skeletonData.findSlot(targetName);\r\n\r\n                if (!target) throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\r\n                data.target = target;\r\n\r\n                data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, 'positionMode', 'Percent'));\r\n                data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, 'spacingMode', 'Length'));\r\n                data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, 'rotateMode', 'Tangent'));\r\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\r\n                data.position = getValue(constraintMap, 'position', 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = getValue(constraintMap, 'spacing', 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\r\n                data.mixX = getValue(constraintMap, 'mixX', 1);\r\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let i = 0; i < root.skins.length; i++) {\r\n                const skinMap = root.skins[i];\r\n                const skin = new Skin(skinMap.name);\r\n\r\n                if (skinMap.bones) {\r\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n                        const boneName = skinMap.bones[ii];\r\n                        const bone = skeletonData.findBone(boneName);\r\n\r\n                        if (!bone) throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\r\n                        skin.bones.push(bone);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.ik) {\r\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n                        const constraintName = skinMap.ik[ii];\r\n                        const constraint = skeletonData.findIkConstraint(constraintName);\r\n\r\n                        if (!constraint) throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.transform) {\r\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n                        const constraintName = skinMap.transform[ii];\r\n                        const constraint = skeletonData.findTransformConstraint(constraintName);\r\n\r\n                        if (!constraint) throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                if (skinMap.path) {\r\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\r\n                        const constraintName = skinMap.path[ii];\r\n                        const constraint = skeletonData.findPathConstraint(constraintName);\r\n\r\n                        if (!constraint) throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\r\n                        skin.constraints.push(constraint);\r\n                    }\r\n                }\r\n\r\n                for (const slotName in skinMap.attachments) {\r\n                    const slot = skeletonData.findSlot(slotName);\r\n\r\n                    if (!slot) throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\r\n                    const slotMap = skinMap.attachments[slotName];\r\n\r\n                    for (const entryName in slotMap) {\r\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n\r\n                        if (attachment) skin.setAttachment(slot.index, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            const linkedMesh = this.linkedMeshes[i];\r\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\r\n            if (!skin) throw new Error(`Skin not found: ${linkedMesh.skin}`);\r\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\r\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\r\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\r\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (const eventName in root.events) {\r\n                const eventMap = root.events[eventName];\r\n                const data = new EventData(eventName);\r\n\r\n                data.intValue = getValue(eventMap, 'int', 0);\r\n                data.floatValue = getValue(eventMap, 'float', 0);\r\n                data.stringValue = getValue(eventMap, 'string', '');\r\n                data.audioPath = getValue(eventMap, 'audio', null);\r\n                if (data.audioPath) {\r\n                    data.volume = getValue(eventMap, 'volume', 1);\r\n                    data.balance = getValue(eventMap, 'balance', 0);\r\n                }\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (const animationName in root.animations) {\r\n                const animationMap = root.animations[animationName];\r\n\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment | null {\r\n        const scale = this.scale;\r\n\r\n        name = getValue(map, 'name', name);\r\n\r\n        switch (getValue(map, 'type', 'region')) {\r\n            case 'region': {\r\n                const path = getValue(map, 'path', name);\r\n                const sequence = this.readSequence(getValue(map, 'sequence', null));\r\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\r\n\r\n                if (!region) return null;\r\n                region.path = path;\r\n                region.x = getValue(map, 'x', 0) * scale;\r\n                region.y = getValue(map, 'y', 0) * scale;\r\n                region.scaleX = getValue(map, 'scaleX', 1);\r\n                region.scaleY = getValue(map, 'scaleY', 1);\r\n                region.rotation = getValue(map, 'rotation', 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n                region.sequence = sequence;\r\n\r\n                const color: string = getValue(map, 'color', null);\r\n\r\n                if (color) region.color.setFromString(color);\r\n\r\n                // if (region.region != null) region.updateRegion();\r\n                return region;\r\n            }\r\n            case 'boundingbox': {\r\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\r\n                if (!box) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                const color: string = getValue(map, 'color', null);\r\n\r\n                if (color) box.color.setFromString(color);\r\n\r\n                return box;\r\n            }\r\n            case 'mesh':\r\n            case 'linkedmesh': {\r\n                const path = getValue(map, 'path', name);\r\n                const sequence = this.readSequence(getValue(map, 'sequence', null));\r\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\r\n\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n\r\n                const color = getValue(map, 'color', null);\r\n\r\n                if (color) mesh.color.setFromString(color);\r\n\r\n                mesh.width = getValue(map, 'width', 0) * scale;\r\n                mesh.height = getValue(map, 'height', 0) * scale;\r\n                mesh.sequence = sequence;\r\n\r\n                const parent: string = getValue(map, 'parent', null);\r\n\r\n                if (parent) {\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>getValue(map, 'skin', null), slotIndex, parent, getValue(map, 'timelines', true)));\r\n\r\n                    return mesh;\r\n                }\r\n\r\n                const uvs: Array<number> = map.uvs;\r\n\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = new Float32Array(uvs);\r\n                // if (mesh.region != null) mesh.updateRegion();\r\n\r\n                mesh.edges = getValue(map, 'edges', null);\r\n                mesh.hullLength = getValue(map, 'hull', 0) * 2;\r\n\r\n                return mesh;\r\n            }\r\n            case 'path': {\r\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\r\n                if (!path) return null;\r\n                path.closed = getValue(map, 'closed', false);\r\n                path.constantSpeed = getValue(map, 'constantSpeed', true);\r\n\r\n                const vertexCount = map.vertexCount;\r\n\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n\r\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                const color: string = getValue(map, 'color', null);\r\n\r\n                if (color) path.color.setFromString(color);\r\n\r\n                return path;\r\n            }\r\n            case 'point': {\r\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\r\n                if (!point) return null;\r\n                point.x = getValue(map, 'x', 0) * scale;\r\n                point.y = getValue(map, 'y', 0) * scale;\r\n                point.rotation = getValue(map, 'rotation', 0);\r\n\r\n                const color = getValue(map, 'color', null);\r\n\r\n                if (color) point.color.setFromString(color);\r\n\r\n                return point;\r\n            }\r\n            case 'clipping': {\r\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\r\n                if (!clip) return null;\r\n\r\n                const end = getValue(map, 'end', null);\r\n\r\n                if (end != null) {\r\n                    const slot = skeletonData.findSlot(end);\r\n\r\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\r\n                    clip.endSlot = slot;\r\n                }\r\n\r\n                const vertexCount = map.vertexCount;\r\n\r\n                this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                const color: string = getValue(map, 'color', null);\r\n\r\n                if (color) clip.color.setFromString(color);\r\n\r\n                return clip;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    readSequence(map: any) {\r\n        if (map == null) return null;\r\n        const sequence = new Sequence(getValue(map, 'count', 0));\r\n\r\n        sequence.start = getValue(map, 'start', 1);\r\n        sequence.digits = getValue(map, 'digits', 0);\r\n        sequence.setupIndex = getValue(map, 'setup', 0);\r\n\r\n        return sequence;\r\n    }\r\n\r\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        const scale = this.scale;\r\n\r\n        attachment.worldVerticesLength = verticesLength;\r\n        const vertices: Array<number> = map.vertices;\r\n\r\n        if (verticesLength == vertices.length) {\r\n            const scaledVertices = Utils.toFloatArray(vertices);\r\n\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\r\n            }\r\n            attachment.vertices = scaledVertices;\r\n\r\n            return;\r\n        }\r\n        const weights = new Array<number>();\r\n        const bones = new Array<number>();\r\n\r\n        for (let i = 0, n = vertices.length; i < n; ) {\r\n            const boneCount = vertices[i++];\r\n\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\r\n        const scale = this.scale;\r\n        const timelines = new Array<Timeline>();\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (const slotName in map.slots) {\r\n                const slotMap = map.slots[slotName];\r\n                const slot = skeletonData.findSlot(slotName);\r\n\r\n                if (!slot) throw new Error(`Slot not found: ${slotName}`);\r\n                const slotIndex = slot.index;\r\n\r\n                for (const timelineName in slotMap) {\r\n                    const timelineMap = slotMap[timelineName];\r\n\r\n                    if (!timelineMap) continue;\r\n                    const frames = timelineMap.length;\r\n\r\n                    if (timelineName == 'attachment') {\r\n                        const timeline = new AttachmentTimeline(frames, slotIndex);\r\n\r\n                        for (let frame = 0; frame < frames; frame++) {\r\n                            const keyMap = timelineMap[frame];\r\n\r\n                            timeline.setFrame(frame, getValue(keyMap, 'time', 0), getValue(keyMap, 'name', null));\r\n                        }\r\n                        timelines.push(timeline);\r\n                    } else if (timelineName == 'rgba') {\r\n                        const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, 'time', 0);\r\n                        let color = Color.fromString(keyMap.color);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\r\n                            const nextMap = timelineMap[frame + 1];\r\n\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            const time2 = getValue(nextMap, 'time', 0);\r\n                            const newColor = Color.fromString(nextMap.color);\r\n                            const curve = keyMap.curve;\r\n\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n                    } else if (timelineName == 'rgb') {\r\n                        const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, 'time', 0);\r\n                        let color = Color.fromString(keyMap.color);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b);\r\n                            const nextMap = timelineMap[frame + 1];\r\n\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            const time2 = getValue(nextMap, 'time', 0);\r\n                            const newColor = Color.fromString(nextMap.color);\r\n                            const curve = keyMap.curve;\r\n\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n                    } else if (timelineName == 'alpha') {\r\n                        timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\r\n                    } else if (timelineName == 'rgba2') {\r\n                        const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\r\n\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, 'time', 0);\r\n                        let color = Color.fromString(keyMap.light);\r\n                        let color2 = Color.fromString(keyMap.dark);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\r\n                            const nextMap = timelineMap[frame + 1];\r\n\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            const time2 = getValue(nextMap, 'time', 0);\r\n                            const newColor = Color.fromString(nextMap.light);\r\n                            const newColor2 = Color.fromString(nextMap.dark);\r\n                            const curve = keyMap.curve;\r\n\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            color2 = newColor2;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n                    } else if (timelineName == 'rgb2') {\r\n                        const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\r\n\r\n                        let keyMap = timelineMap[0];\r\n                        let time = getValue(keyMap, 'time', 0);\r\n                        let color = Color.fromString(keyMap.light);\r\n                        let color2 = Color.fromString(keyMap.dark);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\r\n                            const nextMap = timelineMap[frame + 1];\r\n\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            const time2 = getValue(nextMap, 'time', 0);\r\n                            const newColor = Color.fromString(nextMap.light);\r\n                            const newColor2 = Color.fromString(nextMap.dark);\r\n                            const curve = keyMap.curve;\r\n\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\r\n                            }\r\n                            time = time2;\r\n                            color = newColor;\r\n                            color2 = newColor2;\r\n                            keyMap = nextMap;\r\n                        }\r\n\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (const boneName in map.bones) {\r\n                const boneMap = map.bones[boneName];\r\n                const bone = skeletonData.findBone(boneName);\r\n\r\n                if (!bone) throw new Error(`Bone not found: ${boneName}`);\r\n                const boneIndex = bone.index;\r\n\r\n                for (const timelineName in boneMap) {\r\n                    const timelineMap = boneMap[timelineName];\r\n                    const frames = timelineMap.length;\r\n\r\n                    if (frames == 0) continue;\r\n\r\n                    if (timelineName === 'rotate') {\r\n                        timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\r\n                    } else if (timelineName === 'translate') {\r\n                        const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\r\n\r\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, scale));\r\n                    } else if (timelineName === 'translatex') {\r\n                        const timeline = new TranslateXTimeline(frames, frames, boneIndex);\r\n\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\r\n                    } else if (timelineName === 'translatey') {\r\n                        const timeline = new TranslateYTimeline(frames, frames, boneIndex);\r\n\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\r\n                    } else if (timelineName === 'scale') {\r\n                        const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\r\n\r\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 1, 1));\r\n                    } else if (timelineName === 'scalex') {\r\n                        const timeline = new ScaleXTimeline(frames, frames, boneIndex);\r\n\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\r\n                    } else if (timelineName === 'scaley') {\r\n                        const timeline = new ScaleYTimeline(frames, frames, boneIndex);\r\n\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\r\n                    } else if (timelineName === 'shear') {\r\n                        const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\r\n\r\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, 1));\r\n                    } else if (timelineName === 'shearx') {\r\n                        const timeline = new ShearXTimeline(frames, frames, boneIndex);\r\n\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\r\n                    } else if (timelineName === 'sheary') {\r\n                        const timeline = new ShearYTimeline(frames, frames, boneIndex);\r\n\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (const constraintName in map.ik) {\r\n                const constraintMap = map.ik[constraintName];\r\n                let keyMap = constraintMap[0];\r\n\r\n                if (!keyMap) continue;\r\n\r\n                const constraint = skeletonData.findIkConstraint(constraintName);\r\n\r\n                if (!constraint) throw new Error(`IK Constraint not found: ${constraintName}`);\r\n                const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\r\n\r\n                let time = getValue(keyMap, 'time', 0);\r\n                let mix = getValue(keyMap, 'mix', 1);\r\n                let softness = getValue(keyMap, 'softness', 0) * scale;\r\n\r\n                for (let frame = 0, bezier = 0; ; frame++) {\r\n                    timeline.setFrame(\r\n                        frame,\r\n                        time,\r\n                        mix,\r\n                        softness,\r\n                        getValue(keyMap, 'bendPositive', true) ? 1 : -1,\r\n                        getValue(keyMap, 'compress', false),\r\n                        getValue(keyMap, 'stretch', false)\r\n                    );\r\n                    const nextMap = constraintMap[frame + 1];\r\n\r\n                    if (!nextMap) {\r\n                        timeline.shrink(bezier);\r\n                        break;\r\n                    }\r\n\r\n                    const time2 = getValue(nextMap, 'time', 0);\r\n                    const mix2 = getValue(nextMap, 'mix', 1);\r\n                    const softness2 = getValue(nextMap, 'softness', 0) * scale;\r\n                    const curve = keyMap.curve;\r\n\r\n                    if (curve) {\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\r\n                    }\r\n\r\n                    time = time2;\r\n                    mix = mix2;\r\n                    softness = softness2;\r\n                    keyMap = nextMap;\r\n                }\r\n                timelines.push(timeline);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (const constraintName in map.transform) {\r\n                const timelineMap = map.transform[constraintName];\r\n                let keyMap = timelineMap[0];\r\n\r\n                if (!keyMap) continue;\r\n\r\n                const constraint = skeletonData.findTransformConstraint(constraintName);\r\n\r\n                if (!constraint) throw new Error(`Transform constraint not found: ${constraintName}`);\r\n                const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\r\n\r\n                let time = getValue(keyMap, 'time', 0);\r\n                let mixRotate = getValue(keyMap, 'mixRotate', 1);\r\n                let mixX = getValue(keyMap, 'mixX', 1);\r\n                let mixY = getValue(keyMap, 'mixY', mixX);\r\n                let mixScaleX = getValue(keyMap, 'mixScaleX', 1);\r\n                let mixScaleY = getValue(keyMap, 'mixScaleY', mixScaleX);\r\n                const mixShearY = getValue(keyMap, 'mixShearY', 1);\r\n\r\n                for (let frame = 0, bezier = 0; ; frame++) {\r\n                    timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\r\n                    const nextMap = timelineMap[frame + 1];\r\n\r\n                    if (!nextMap) {\r\n                        timeline.shrink(bezier);\r\n                        break;\r\n                    }\r\n\r\n                    const time2 = getValue(nextMap, 'time', 0);\r\n                    const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\r\n                    const mixX2 = getValue(nextMap, 'mixX', 1);\r\n                    const mixY2 = getValue(nextMap, 'mixY', mixX2);\r\n                    const mixScaleX2 = getValue(nextMap, 'mixScaleX', 1);\r\n                    const mixScaleY2 = getValue(nextMap, 'mixScaleY', mixScaleX2);\r\n                    const mixShearY2 = getValue(nextMap, 'mixShearY', 1);\r\n                    const curve = keyMap.curve;\r\n\r\n                    if (curve) {\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\r\n                        bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\r\n                    }\r\n\r\n                    time = time2;\r\n                    mixRotate = mixRotate2;\r\n                    mixX = mixX2;\r\n                    mixY = mixY2;\r\n                    mixScaleX = mixScaleX2;\r\n                    mixScaleY = mixScaleY2;\r\n                    mixScaleX = mixScaleX2;\r\n                    keyMap = nextMap;\r\n                }\r\n                timelines.push(timeline);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.path) {\r\n            for (const constraintName in map.path) {\r\n                const constraintMap = map.path[constraintName];\r\n                const constraint = skeletonData.findPathConstraint(constraintName);\r\n\r\n                if (!constraint) throw new Error(`Path constraint not found: ${constraintName}`);\r\n                const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\r\n\r\n                for (const timelineName in constraintMap) {\r\n                    const timelineMap = constraintMap[timelineName];\r\n                    let keyMap = timelineMap[0];\r\n\r\n                    if (!keyMap) continue;\r\n\r\n                    const frames = timelineMap.length;\r\n\r\n                    if (timelineName === 'position') {\r\n                        const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\r\n\r\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\r\n                    } else if (timelineName === 'spacing') {\r\n                        const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\r\n\r\n                        timelines.push(\r\n                            readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1)\r\n                        );\r\n                    } else if (timelineName === 'mix') {\r\n                        const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\r\n                        let time = getValue(keyMap, 'time', 0);\r\n                        let mixRotate = getValue(keyMap, 'mixRotate', 1);\r\n                        let mixX = getValue(keyMap, 'mixX', 1);\r\n                        let mixY = getValue(keyMap, 'mixY', mixX);\r\n\r\n                        for (let frame = 0, bezier = 0; ; frame++) {\r\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\r\n                            const nextMap = timelineMap[frame + 1];\r\n\r\n                            if (!nextMap) {\r\n                                timeline.shrink(bezier);\r\n                                break;\r\n                            }\r\n                            const time2 = getValue(nextMap, 'time', 0);\r\n                            const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\r\n                            const mixX2 = getValue(nextMap, 'mixX', 1);\r\n                            const mixY2 = getValue(nextMap, 'mixY', mixX2);\r\n                            const curve = keyMap.curve;\r\n\r\n                            if (curve) {\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\r\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\r\n                            }\r\n                            time = time2;\r\n                            mixRotate = mixRotate2;\r\n                            mixX = mixX2;\r\n                            mixY = mixY2;\r\n                            keyMap = nextMap;\r\n                        }\r\n                        timelines.push(timeline);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // ver40 compatibility\r\n        if (map.deform) {\r\n            map.attachments = {};\r\n            for (const deformName in map.deform) {\r\n                const deformMap = map.deform[deformName];\r\n                const outMap = (map.attachments[deformName] = {});\r\n\r\n                for (const slotName in deformMap) {\r\n                    const slotMap = deformMap[slotName];\r\n                    const outMap2 = (outMap[slotName] = {});\r\n\r\n                    for (const innerMapName in slotMap) {\r\n                        outMap2[innerMapName] = {\r\n                            deform: slotMap[innerMapName],\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Attachment timelines.\r\n        if (map.attachments) {\r\n            for (const attachmentsName in map.attachments) {\r\n                const attachmentsMap = map.attachments[attachmentsName];\r\n                const skin = skeletonData.findSkin(attachmentsName);\r\n\r\n                if (skin == null) {\r\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\r\n                        throw new Error(`Skin not found: ${attachmentsName}`);\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                for (const slotMapName in attachmentsMap) {\r\n                    const slotMap = attachmentsMap[slotMapName];\r\n                    const slot = skeletonData.findSlot(slotMapName);\r\n\r\n                    if (!slot) throw new Error(`Slot not found: ${slotMapName}`);\r\n                    const slotIndex = slot.index;\r\n\r\n                    for (const attachmentMapName in slotMap) {\r\n                        const attachmentMap = slotMap[attachmentMapName];\r\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, attachmentMapName);\r\n\r\n                        for (const timelineMapName in attachmentMap) {\r\n                            const timelineMap = attachmentMap[timelineMapName];\r\n                            let keyMap = timelineMap[0];\r\n\r\n                            if (!keyMap) continue;\r\n\r\n                            if (timelineMapName == 'deform') {\r\n                                const weighted = attachment.bones;\r\n                                const vertices = attachment.vertices;\r\n                                const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\r\n\r\n                                const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\r\n                                let time = getValue(keyMap, 'time', 0);\r\n\r\n                                for (let frame = 0, bezier = 0; ; frame++) {\r\n                                    let deform: NumberArrayLike;\r\n                                    const verticesValue: Array<Number> = getValue(keyMap, 'vertices', null);\r\n\r\n                                    if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                                    else {\r\n                                        deform = Utils.newFloatArray(deformLength);\r\n                                        const start = <number>getValue(keyMap, 'offset', 0);\r\n\r\n                                        Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                        if (scale != 1) {\r\n                                            for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\r\n                                        }\r\n                                        if (!weighted) {\r\n                                            for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\r\n                                        }\r\n                                    }\r\n\r\n                                    timeline.setFrame(frame, time, deform);\r\n                                    const nextMap = timelineMap[frame + 1];\r\n\r\n                                    if (!nextMap) {\r\n                                        timeline.shrink(bezier);\r\n                                        break;\r\n                                    }\r\n                                    const time2 = getValue(nextMap, 'time', 0);\r\n                                    const curve = keyMap.curve;\r\n\r\n                                    if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\r\n                                    time = time2;\r\n                                    keyMap = nextMap;\r\n                                }\r\n                                timelines.push(timeline);\r\n                            } else if (timelineMapName == 'sequence') {\r\n                                const timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment as unknown as IHasTextureRegion);\r\n                                let lastDelay = 0;\r\n\r\n                                for (let frame = 0; frame < timelineMap.length; frame++) {\r\n                                    const delay = getValue(keyMap, 'delay', lastDelay);\r\n                                    const time = getValue(keyMap, 'time', 0);\r\n                                    const mode = SequenceMode[getValue(keyMap, 'mode', 'hold')] as unknown as number;\r\n                                    const index = getValue(keyMap, 'index', 0);\r\n\r\n                                    timeline.setFrame(frame, time, mode, index, delay);\r\n                                    lastDelay = delay;\r\n                                    keyMap = timelineMap[frame + 1];\r\n                                }\r\n                                timelines.push(timeline);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timelines.\r\n        if (map.drawOrder) {\r\n            const timeline = new DrawOrderTimeline(map.drawOrder.length);\r\n            const slotCount = skeletonData.slots.length;\r\n            let frame = 0;\r\n\r\n            for (let i = 0; i < map.drawOrder.length; i++, frame++) {\r\n                const drawOrderMap = map.drawOrder[i];\r\n                let drawOrder: Array<number> | null = null;\r\n                const offsets = getValue(drawOrderMap, 'offsets', null);\r\n\r\n                if (offsets) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0;\r\n                    let unchangedIndex = 0;\r\n\r\n                    for (let ii = 0; ii < offsets.length; ii++) {\r\n                        const offsetMap = offsets[ii];\r\n                        const slot = skeletonData.findSlot(offsetMap.slot);\r\n\r\n                        if (!slot) throw new Error(`Slot not found: ${slot}`);\r\n                        const slotIndex = slot.index;\r\n                        // Collect unchanged items.\r\n\r\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frame, getValue(drawOrderMap, 'time', 0), drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        // Event timelines.\r\n        if (map.events) {\r\n            const timeline = new EventTimeline(map.events.length);\r\n            let frame = 0;\r\n\r\n            for (let i = 0; i < map.events.length; i++, frame++) {\r\n                const eventMap = map.events[i];\r\n                const eventData = skeletonData.findEvent(eventMap.name);\r\n\r\n                if (!eventData) throw new Error(`Event not found: ${eventMap.name}`);\r\n                const event = new Event(Utils.toSinglePrecision(getValue(eventMap, 'time', 0)), eventData);\r\n\r\n                event.intValue = getValue(eventMap, 'int', eventData.intValue);\r\n                event.floatValue = getValue(eventMap, 'float', eventData.floatValue);\r\n                event.stringValue = getValue(eventMap, 'string', eventData.stringValue);\r\n                if (event.data.audioPath) {\r\n                    event.volume = getValue(eventMap, 'volume', 1);\r\n                    event.balance = getValue(eventMap, 'balance', 0);\r\n                }\r\n                timeline.setFrame(frame, event);\r\n            }\r\n            timelines.push(timeline);\r\n        }\r\n\r\n        let duration = 0;\r\n\r\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\r\n        if (isNaN(duration)) {\r\n            throw new Error('Error while parsing animation, duration is NaN');\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n    static blendModeFromString(str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == 'normal') return 'normal';\r\n        if (str == 'additive') return 'add';\r\n        if (str == 'multiply') return 'multiply';\r\n        if (str == 'screen') return 'screen';\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string;\r\n    skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n    inheritTimeline: boolean;\r\n\r\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n        this.inheritTimeline = inheritDeform;\r\n    }\r\n}\r\n\r\nfunction readTimeline1(keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\r\n    let keyMap = keys[0];\r\n    let time = getValue(keyMap, 'time', 0);\r\n    let value = getValue(keyMap, 'value', defaultValue) * scale;\r\n    let bezier = 0;\r\n\r\n    for (let frame = 0; ; frame++) {\r\n        timeline.setFrame(frame, time, value);\r\n        const nextMap = keys[frame + 1];\r\n\r\n        if (!nextMap) {\r\n            timeline.shrink(bezier);\r\n\r\n            return timeline;\r\n        }\r\n        const time2 = getValue(nextMap, 'time', 0);\r\n        const value2 = getValue(nextMap, 'value', defaultValue) * scale;\r\n\r\n        if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\r\n        time = time2;\r\n        value = value2;\r\n        keyMap = nextMap;\r\n    }\r\n}\r\n\r\nfunction readTimeline2(keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\r\n    let keyMap = keys[0];\r\n    let time = getValue(keyMap, 'time', 0);\r\n    let value1 = getValue(keyMap, name1, defaultValue) * scale;\r\n    let value2 = getValue(keyMap, name2, defaultValue) * scale;\r\n    let bezier = 0;\r\n\r\n    for (let frame = 0; ; frame++) {\r\n        timeline.setFrame(frame, time, value1, value2);\r\n        const nextMap = keys[frame + 1];\r\n\r\n        if (!nextMap) {\r\n            timeline.shrink(bezier);\r\n\r\n            return timeline;\r\n        }\r\n        const time2 = getValue(nextMap, 'time', 0);\r\n        const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\r\n        const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\r\n        const curve = keyMap.curve;\r\n\r\n        if (curve) {\r\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\r\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\r\n        }\r\n        time = time2;\r\n        value1 = nvalue1;\r\n        value2 = nvalue2;\r\n        keyMap = nextMap;\r\n    }\r\n}\r\n\r\nfunction readCurve(curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number, value1: number, value2: number, scale: number) {\r\n    if (curve == 'stepped') {\r\n        timeline.setStepped(frame);\r\n\r\n        return bezier;\r\n    }\r\n    const i = value << 2;\r\n    const cx1 = curve[i];\r\n    const cy1 = curve[i + 1] * scale;\r\n    const cx2 = curve[i + 2];\r\n    const cy2 = curve[i + 3] * scale;\r\n\r\n    timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\r\n\r\n    return bezier + 1;\r\n}\r\n\r\nfunction getValue(map: any, property: string, defaultValue: any) {\r\n    return map[property] !== undefined ? map[property] : defaultValue;\r\n}\r\n","import { SpineBase } from '@pixi-spine/base';\r\nimport { Skeleton } from './core/Skeleton';\r\nimport type { SkeletonData } from './core/SkeletonData';\r\nimport { AnimationState } from './core/AnimationState';\r\nimport { AnimationStateData } from './core/AnimationStateData';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\r\n    createSkeleton(spineData: SkeletonData) {\r\n        this.skeleton = new Skeleton(spineData);\r\n        this.skeleton.updateWorldTransform();\r\n        this.stateData = new AnimationStateData(spineData);\r\n        this.state = new AnimationState(this.stateData);\r\n    }\r\n}\r\n"],"names":["Attachment","name","_VertexAttachment","slot","worldVertices","start","count","offset","stride","skeleton","deformArray","vertices","bones","mat","x","y","a","b","c","d","v","w","vx","vy","skip","i","n","skeletonBones","wx","wy","weight","deform","f","attachment","Utils","VertexAttachment","BoundingBoxAttachment","AttachmentType","Color","copy","ClippingAttachment","MeshAttachment","path","parentMesh","PathAttachment","PointAttachment","bone","point","cos","MathUtils","sin","_RegionAttachment","region","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","uvs","vertexOffset","offsetX","offsetY","RegionAttachment","_Sequence","index","basePath","result","frame","Sequence","SequenceMode","t","SequenceModeValues","Animation","timelines","duration","StringSet","ids","lastTime","time","loop","events","alpha","blend","direction","Property","Timeline","frameCount","propertyIds","frames","step","CurveTimeline","bezierCount","size","newCurves","bezier","value","time1","value1","cx1","cy1","cx2","cy2","time2","value2","curves","tmpx","tmpy","dddx","dddy","ddx","ddy","dx","dy","frameIndex","valueOffset","CurveTimeline1","propertyId","ii","curveType","before","CurveTimeline2","propertyId1","propertyId2","RotateTimeline","boneIndex","MixBlend","r","TranslateTimeline","TranslateXTimeline","TranslateYTimeline","ScaleTimeline","bx","by","MixDirection","ScaleXTimeline","ScaleYTimeline","ShearTimeline","ShearXTimeline","ShearYTimeline","RGBATimeline","slotIndex","g","color","setup","RGBTimeline","AlphaTimeline","RGBA2Timeline","r2","g2","b2","light","dark","setupLight","setupDark","RGB2Timeline","AttachmentTimeline","attachmentName","DeformTimeline","firedEvents","slotAttachment","vertexCount","vertexAttachment","setupVertices","lastVertices","percent","prevVertices","nextVertices","prev","_EventTimeline","event","frameTime","EventTimeline","_DrawOrderTimeline","drawOrder","idx","drawOrderToSetupIndex","slots","DrawOrderTimeline","IkConstraintTimeline","ikConstraintIndex","mix","softness","bendDirection","compress","stretch","constraint","TransformConstraintTimeline","transformConstraintIndex","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","data","rotate","scaleX","scaleY","shearY","PathConstraintPositionTimeline","pathConstraintIndex","position","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","_SequenceTimeline","mode","delay","modeAndIndex","SequenceTimeline","_AnimationState","EventQueue","Pool","TrackEntry","delta","tracks","current","currentDelta","next","nextTime","from","to","finished","applied","animationLast","animationTime","applyTime","applyEvents","timelineCount","timeline","timelineMode","shortestRotation","firstFrame","timelineBlend","SUBSEQUENT","setupState","SETUP","attachments","alphaHold","alphaMix","timelineHoldMix","FIRST","HOLD_SUBSEQUENT","HOLD_FIRST","holdMix","CURRENT","timelinesRotation","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","trackIndex","interrupt","animationName","animation","last","mixDuration","timelinesCount","propertyIDs","outer","HOLD_MIX","listener","AnimationState","_TrackEntry","animState","EventType","objects","listeners","type","o","AnimationStateAdapter","AnimationStateData","skeletonData","fromName","toName","key","AtlasAttachmentLoader","atlas","sequence","regions","skin","Bone","parent","Matrix","rotation","shearX","m","sx","sy","settings","rotationY","pa","pb","pc","pd","TransformMode","la","lb","lc","ld","s","prx","rx","ry","za","zc","zb","zd","pm","pid","ia","id","ib","ic","ra","rb","rc","rd","det","world","invDet","local","worldRotation","localRotation","degrees","BoneData","ConstraintData","order","skinRequired","Event","EventData","IkConstraint","target","targetX","targetY","uniform","p","rotationIK","tx","ty","skelX","skelY","sa","sc","dd","child","bendDir","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","u","pp","l1","l2","a1","a2","td","sd","aa","bb","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","boneData","PathConstraintData","PositionMode","SpacingMode","RotateMode","slotData","_PathConstraint","tangents","scale","boneCount","spacesCount","spaces","lengths","setupLength","sum","length","lengthSpacing","positions","boneX","boneY","offsetRotation","tip","out","closed","verticesLength","curveCount","prevCurve","pathLength","multiplier","curve","space","x1","y1","x2","y2","dddfx","dddfy","ddfx","ddfy","dfx","dfy","segments","curveLength","segment","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraint","Slot","TransformConstraint","Vector2","translate","targetMat","tb","tc","degRadReflect","offsetShearY","_Skeleton","ikConstraintData","transformConstraintData","pathConstraintData","updateCache","skinBones","ikConstraints","transformConstraints","pathConstraints","ikCount","transformCount","pathCount","constraintCount","constrained","slotBone","pathBones","nn","rootBone","updatable","boneName","slotName","skinName","newSkin","constraintName","ikConstraint","mesh","Skeleton","SkeletonData","skins","eventDataName","animations","pathConstraintName","SlotData","TransformConstraintData","SkinEntry","Skin","contained","dictionary","entries","slotAttachments","oldSkin","skinAttachment","_SkeletonBinary","attachmentLoader","binary","input","BinaryInput","lowHash","highHash","verShort","error","nonessential","str","darkColor","defaultSkin","linkedMesh","eventName","slotCount","width","height","box","triangles","hullLength","edges","inheritTimelines","LinkedMesh","constantSpeed","endSlotIndex","clip","ATTACHMENT_DEFORM","Vertices","weights","bonesArray","array","timelineType","frameLast","SLOT_ATTACHMENT","SLOT_RGBA","CURVE_STEPPED","CURVE_BEZIER","setBezier","SLOT_RGB","SLOT_RGBA2","nr","ng","nb","na","nr2","ng2","nb2","SLOT_RGB2","SLOT_ALPHA","BONE_ROTATE","readTimeline1","BONE_TRANSLATE","readTimeline2","BONE_TRANSLATEX","BONE_TRANSLATEY","BONE_SCALE","BONE_SCALEX","BONE_SCALEY","BONE_SHEAR","BONE_SHEARX","BONE_SHEARY","mix2","softness2","mixRotate2","mixX2","mixY2","mixScaleX2","mixScaleY2","mixShearY2","PATH_POSITION","PATH_SPACING","PATH_MIX","iii","nnn","weighted","deformLength","end","vn","ATTACHMENT_SEQUENCE","drawOrderCount","offsetCount","unchanged","originalIndex","unchangedIndex","eventCount","eventData","num","SkeletonBinary","inheritDeform","nvalue1","nvalue2","SkeletonBounds","SkeletonBoundsBase","SkeletonJson","json","root","skeletonMap","boneMap","parentName","getValue","slotMap","constraintMap","targetName","skinMap","entryName","eventMap","animationMap","map","scaledVertices","timelineName","timelineMap","keyMap","nextMap","newColor","readCurve","color2","newColor2","constraintIndex","deformName","deformMap","outMap","outMap2","innerMapName","attachmentsName","attachmentsMap","slotMapName","attachmentMapName","attachmentMap","timelineMapName","verticesValue","lastDelay","drawOrderMap","offsets","offsetMap","keys","defaultValue","name1","name2","property","Spine","SpineBase","spineData"],"mappings":"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"}