/*!
 * @pixi-spine/runtime-4.1 - v4.0.3
 * Compiled Thu, 11 Apr 2024 10:02:14 UTC
 *
 * @pixi-spine/runtime-4.1 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2024, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{Utils as B,AttachmentType as et,Color as L,MathUtils as M,StringSet as Ue,MixBlend as Y,MixDirection as st,Pool as rs,settings as Xt,TransformMode as nt,PositionMode as bt,RotateMode as Tt,Vector2 as Kt,BinaryInput as is,SkeletonBoundsBase as os,SpineBase as hs}from"@pixi-spine/base";import{Matrix as ls}from"pixi.js";class Jt{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Oe=class extends Jt{constructor(n){super(n),this.id=Oe.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(n,t){this.computeWorldVertices(n,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(n,t,a,e,r,i){a=r+(a>>1)*i;const d=n.bone.skeleton,l=n.deform;let s=this.vertices;const o=this.bones;if(!o){l.length>0&&(s=l);const m=n.bone.matrix,f=m.tx,x=m.ty,b=m.a,k=m.c,g=m.b,y=m.d;for(let w=t,p=r;p<a;w+=2,p+=i){const S=s[w],A=s[w+1];e[p]=S*b+A*k+f,e[p+1]=S*g+A*y+x}return}let h=0,c=0;for(let m=0;m<t;m+=2){const f=o[h];h+=f+1,c+=f}const u=d.bones;if(l.length==0)for(let m=r,f=c*3;m<a;m+=i){let x=0,b=0,k=o[h++];for(k+=h;h<k;h++,f+=3){const g=u[o[h]].matrix,y=s[f],w=s[f+1],p=s[f+2];x+=(y*g.a+w*g.c+g.tx)*p,b+=(y*g.b+w*g.d+g.ty)*p}e[m]=x,e[m+1]=b}else{const m=l;for(let f=r,x=c*3,b=c<<1;f<a;f+=i){let k=0,g=0,y=o[h++];for(y+=h;h<y;h++,x+=3,b+=2){const w=u[o[h]].matrix,p=s[x]+m[b],S=s[x+1]+m[b+1],A=s[x+2];k+=(p*w.a+S*w.c+w.tx)*A,g+=(p*w.b+S*w.d+w.ty)*A}e[f]=k,e[f+1]=g}}}copyTo(n){this.bones?(n.bones=new Array(this.bones.length),B.arrayCopy(this.bones,0,n.bones,0,this.bones.length)):n.bones=null,this.vertices&&(n.vertices=B.newFloatArray(this.vertices.length),B.arrayCopy(this.vertices,0,n.vertices,0,this.vertices.length)),n.worldVerticesLength=this.worldVerticesLength,n.timelineAttachment=this.timelineAttachment}};let rt=Oe;rt.nextID=0;class zt extends rt{constructor(t){super(t),this.type=et.BoundingBox,this.color=new L(1,1,1,1)}copy(){const t=new zt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class _t extends rt{constructor(t){super(t),this.type=et.Clipping,this.endSlot=null,this.color=new L(.2275,.2275,.8078,1)}copy(){const t=new _t(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class At extends rt{constructor(t,a){super(t),this.type=et.Mesh,this.region=null,this.triangles=[],this.color=new L(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new L(0,0,0,0),this.path=a}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new At(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),B.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),B.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),B.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,a,e,r,i,d){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,a,e,r,i,d)}newLinkedMesh(){const t=new At(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class St extends rt{constructor(t){super(t),this.type=et.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new L(1,1,1,1)}copy(){const t=new St(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),B.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class jt extends rt{constructor(t){super(t),this.type=et.Point,this.x=0,this.y=0,this.rotation=0,this.color=new L(.38,.94,0,1)}computeWorldPosition(t,a){const e=t.matrix;return a.x=this.x*e.a+this.y*e.c+t.worldX,a.y=this.x*e.b+this.y*e.d+t.worldY,a}computeWorldRotation(t){const a=t.matrix,e=M.cosDeg(this.rotation),r=M.sinDeg(this.rotation),i=e*a.a+r*a.c,d=e*a.b+r*a.d;return Math.atan2(d,i)*M.radDeg}copy(){const t=new jt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const ze=class extends Jt{constructor(n,t){super(n),this.type=et.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new L(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=B.newFloatArray(8),this.uvs=B.newFloatArray(8),this.tempColor=new L(1,1,1,1),this.path=t}updateRegion(){if(!this.region)throw new Error("Region not set.");const n=this.region,t=this.width/this.region.originalWidth*this.scaleX,a=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,r=-this.height/2*this.scaleY+this.region.offsetY*a,i=e+this.region.width*t,d=r+this.region.height*a,l=this.rotation*Math.PI/180,s=Math.cos(l),o=Math.sin(l),h=this.x,c=this.y,u=e*s+h,m=e*o,f=r*s+c,x=r*o,b=i*s+h,k=i*o,g=d*s+c,y=d*o,w=this.offset;w[0]=u-x,w[1]=f+m,w[2]=u-y,w[3]=g+m,w[4]=b-y,w[5]=g+k,w[6]=b-x,w[7]=f+k;const p=this.uvs;n.degrees==90?(p[2]=n.u,p[3]=n.v2,p[4]=n.u,p[5]=n.v,p[6]=n.u2,p[7]=n.v,p[0]=n.u2,p[1]=n.v2):(p[0]=n.u,p[1]=n.v2,p[2]=n.u,p[3]=n.v,p[4]=n.u2,p[5]=n.v,p[6]=n.u2,p[7]=n.v2)}computeWorldVertices(n,t,a,e){this.sequence!=null&&this.sequence.apply(n,this);const r=n.bone,i=this.offset,d=r.matrix,l=d.tx,s=d.ty,o=d.a,h=d.c,c=d.b,u=d.d;let m=0,f=0;m=i[0],f=i[1],t[a]=m*o+f*h+l,t[a+1]=m*c+f*u+s,a+=e,m=i[2],f=i[3],t[a]=m*o+f*h+l,t[a+1]=m*c+f*u+s,a+=e,m=i[4],f=i[5],t[a]=m*o+f*h+l,t[a+1]=m*c+f*u+s,a+=e,m=i[6],f=i[7],t[a]=m*o+f*h+l,t[a+1]=m*c+f*u+s}copy(){const n=new ze(this.name,this.path);return n.region=this.region,n.rendererObject=this.rendererObject,n.x=this.x,n.y=this.y,n.scaleX=this.scaleX,n.scaleY=this.scaleY,n.rotation=this.rotation,n.width=this.width,n.height=this.height,B.arrayCopy(this.uvs,0,n.uvs,0,8),B.arrayCopy(this.offset,0,n.offset,0,8),n.color.setFromColor(this.color),n.sequence=this.sequence!=null?this.sequence.copy():null,n}};let N=ze;N.X1=0,N.Y1=1,N.C1R=2,N.C1G=3,N.C1B=4,N.C1A=5,N.U1=6,N.V1=7,N.X2=8,N.Y2=9,N.C2R=10,N.C2G=11,N.C2B=12,N.C2A=13,N.U2=14,N.V2=15,N.X3=16,N.Y3=17,N.C3R=18,N.C3G=19,N.C3B=20,N.C3A=21,N.U3=22,N.V3=23,N.X4=24,N.Y4=25,N.C4R=26,N.C4G=27,N.C4B=28,N.C4A=29,N.U4=30,N.V4=31;const Pt=class{constructor(t){this.id=Pt.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(t)}copy(){const t=new Pt(this.regions.length);return B.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,a){let e=t.sequenceIndex;e==-1&&(e=this.setupIndex),e>=this.regions.length&&(e=this.regions.length-1);const r=this.regions[e];a.region!=r&&(a.region=r)}getPath(t,a){let e=t;const r=(this.start+a).toString();for(let i=this.digits-r.length;i>0;i--)e+="0";return e+=r,e}static nextID(){return Pt._nextID++}};let qt=Pt;qt._nextID=0;var ct=(n=>(n[n.hold=0]="hold",n[n.once=1]="once",n[n.loop=2]="loop",n[n.pingpong=3]="pingpong",n[n.onceReverse=4]="onceReverse",n[n.loopReverse=5]="loopReverse",n[n.pingpongReverse=6]="pingpongReverse",n))(ct||{});const Qt=[0,1,2,3,4,5,6];class Lt{constructor(t,a,e){if(this.timelines=[],this.timelineIds=new Ue,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(a),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let a=0;a<t.length;a++)this.timelineIds.addAll(t[a].getPropertyIds())}hasTimeline(t){for(let a=0;a<t.length;a++)if(this.timelineIds.contains(t[a]))return!0;return!1}apply(t,a,e,r,i,d,l,s){if(!t)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,a>0&&(a%=this.duration));const o=this.timelines;for(let h=0,c=o.length;h<c;h++)o[h].apply(t,a,e,i,d,l,s)}}const z={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class G{constructor(t,a){this.propertyIds=a,this.frames=B.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,a){const e=t.length;for(let r=1;r<e;r++)if(t[r]>a)return r-1;return e-1}static search(t,a,e){const r=t.length;for(let i=e;i<r;i+=e)if(t[i]>a)return i-e;return r-e}}class it extends G{constructor(t,a,e){super(t,e),this.curves=B.newFloatArray(t+a*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const a=this.getFrameCount()+t*18;if(this.curves.length>a){const e=B.newFloatArray(a);B.arrayCopy(this.curves,0,e,0,a),this.curves=e}}setBezier(t,a,e,r,i,d,l,s,o,h,c){const u=this.curves;let m=this.getFrameCount()+t*18;e==0&&(u[a]=2+m);const f=(r-d*2+s)*.03,x=(i-l*2+o)*.03,b=((d-s)*3-r+h)*.006,k=((l-o)*3-i+c)*.006;let g=f*2+b,y=x*2+k,w=(d-r)*.3+f+b*.16666667,p=(l-i)*.3+x+k*.16666667,S=r+w,A=i+p;for(let C=m+18;m<C;m+=2)u[m]=S,u[m+1]=A,w+=g,p+=y,g+=b,y+=k,S+=w,A+=p}getBezierValue(t,a,e,r){const i=this.curves;if(i[r]>t){const o=this.frames[a],h=this.frames[a+e];return h+(t-o)/(i[r]-o)*(i[r+1]-h)}const d=r+18;for(r+=2;r<d;r+=2)if(i[r]>=t){const o=i[r-2],h=i[r-1];return h+(t-o)/(i[r]-o)*(i[r+1]-h)}a+=this.getFrameEntries();const l=i[d-2],s=i[d-1];return s+(t-l)/(this.frames[a]-l)*(this.frames[a+e]-s)}}class ot extends it{constructor(t,a,e){super(t,a,[e])}getFrameEntries(){return 2}setFrame(t,a,e){t<<=1,this.frames[t]=a,this.frames[t+1]=e}getCurveValue(t){const a=this.frames;let e=a.length-2;for(let i=2;i<=e;i+=2)if(a[i]>t){e=i-2;break}const r=this.curves[e>>1];switch(r){case 0:const i=a[e],d=a[e+1];return d+(t-i)/(a[e+2]-i)*(a[e+2+1]-d);case 1:return a[e+1]}return this.getBezierValue(t,e,1,r-2)}}class Wt extends it{constructor(t,a,e,r){super(t,a,[e,r])}getFrameEntries(){return 3}setFrame(t,a,e,r){t*=3,this.frames[t]=a,this.frames[t+1]=e,this.frames[t+2]=r}}class Bt extends ot{constructor(t,a,e){super(t,a,`${z.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.rotation=s.data.rotation;return;case Y.first:s.rotation+=(s.data.rotation-s.rotation)*i}return}let h=this.getCurveValue(e);switch(d){case Y.setup:s.rotation=s.data.rotation+h*i;break;case Y.first:case Y.replace:h+=s.data.rotation-s.rotation;case Y.add:s.rotation+=h*i}}}class Zt extends Wt{constructor(t,a,e){super(t,a,`${z.x}|${e}`,`${z.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.x=s.data.x,s.y=s.data.y;return;case Y.first:s.x+=(s.data.x-s.x)*i,s.y+=(s.data.y-s.y)*i}return}let h=0,c=0;const u=G.search(o,e,3),m=this.curves[u/3];switch(m){case 0:const f=o[u];h=o[u+1],c=o[u+2];const x=(e-f)/(o[u+3]-f);h+=(o[u+3+1]-h)*x,c+=(o[u+3+2]-c)*x;break;case 1:h=o[u+1],c=o[u+2];break;default:h=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}switch(d){case Y.setup:s.x=s.data.x+h*i,s.y=s.data.y+c*i;break;case Y.first:case Y.replace:s.x+=(s.data.x+h-s.x)*i,s.y+=(s.data.y+c-s.y)*i;break;case Y.add:s.x+=h*i,s.y+=c*i}}}class te extends ot{constructor(t,a,e){super(t,a,`${z.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.x=s.data.x;return;case Y.first:s.x+=(s.data.x-s.x)*i}return}const h=this.getCurveValue(e);switch(d){case Y.setup:s.x=s.data.x+h*i;break;case Y.first:case Y.replace:s.x+=(s.data.x+h-s.x)*i;break;case Y.add:s.x+=h*i}}}class ee extends ot{constructor(t,a,e){super(t,a,`${z.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.y=s.data.y;return;case Y.first:s.y+=(s.data.y-s.y)*i}return}const h=this.getCurveValue(e);switch(d){case Y.setup:s.y=s.data.y+h*i;break;case Y.first:case Y.replace:s.y+=(s.data.y+h-s.y)*i;break;case Y.add:s.y+=h*i}}}class se extends Wt{constructor(t,a,e){super(t,a,`${z.scaleX}|${e}`,`${z.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.scaleX=s.data.scaleX,s.scaleY=s.data.scaleY;return;case Y.first:s.scaleX+=(s.data.scaleX-s.scaleX)*i,s.scaleY+=(s.data.scaleY-s.scaleY)*i}return}let h,c;const u=G.search(o,e,3),m=this.curves[u/3];switch(m){case 0:const f=o[u];h=o[u+1],c=o[u+2];const x=(e-f)/(o[u+3]-f);h+=(o[u+3+1]-h)*x,c+=(o[u+3+2]-c)*x;break;case 1:h=o[u+1],c=o[u+2];break;default:h=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}if(h*=s.data.scaleX,c*=s.data.scaleY,i==1)d==Y.add?(s.scaleX+=h-s.data.scaleX,s.scaleY+=c-s.data.scaleY):(s.scaleX=h,s.scaleY=c);else{let f=0,x=0;if(l==st.mixOut)switch(d){case Y.setup:f=s.data.scaleX,x=s.data.scaleY,s.scaleX=f+(Math.abs(h)*M.signum(f)-f)*i,s.scaleY=x+(Math.abs(c)*M.signum(x)-x)*i;break;case Y.first:case Y.replace:f=s.scaleX,x=s.scaleY,s.scaleX=f+(Math.abs(h)*M.signum(f)-f)*i,s.scaleY=x+(Math.abs(c)*M.signum(x)-x)*i;break;case Y.add:s.scaleX+=(h-s.data.scaleX)*i,s.scaleY+=(c-s.data.scaleY)*i}else switch(d){case Y.setup:f=Math.abs(s.data.scaleX)*M.signum(h),x=Math.abs(s.data.scaleY)*M.signum(c),s.scaleX=f+(h-f)*i,s.scaleY=x+(c-x)*i;break;case Y.first:case Y.replace:f=Math.abs(s.scaleX)*M.signum(h),x=Math.abs(s.scaleY)*M.signum(c),s.scaleX=f+(h-f)*i,s.scaleY=x+(c-x)*i;break;case Y.add:s.scaleX+=(h-s.data.scaleX)*i,s.scaleY+=(c-s.data.scaleY)*i}}}}class ne extends ot{constructor(t,a,e){super(t,a,`${z.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.scaleX=s.data.scaleX;return;case Y.first:s.scaleX+=(s.data.scaleX-s.scaleX)*i}return}const h=this.getCurveValue(e)*s.data.scaleX;if(i==1)d==Y.add?s.scaleX+=h-s.data.scaleX:s.scaleX=h;else{let c=0;if(l==st.mixOut)switch(d){case Y.setup:c=s.data.scaleX,s.scaleX=c+(Math.abs(h)*M.signum(c)-c)*i;break;case Y.first:case Y.replace:c=s.scaleX,s.scaleX=c+(Math.abs(h)*M.signum(c)-c)*i;break;case Y.add:s.scaleX+=(h-s.data.scaleX)*i}else switch(d){case Y.setup:c=Math.abs(s.data.scaleX)*M.signum(h),s.scaleX=c+(h-c)*i;break;case Y.first:case Y.replace:c=Math.abs(s.scaleX)*M.signum(h),s.scaleX=c+(h-c)*i;break;case Y.add:s.scaleX+=(h-s.data.scaleX)*i}}}}class ae extends ot{constructor(t,a,e){super(t,a,`${z.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.scaleY=s.data.scaleY;return;case Y.first:s.scaleY+=(s.data.scaleY-s.scaleY)*i}return}const h=this.getCurveValue(e)*s.data.scaleY;if(i==1)d==Y.add?s.scaleY+=h-s.data.scaleY:s.scaleY=h;else{let c=0;if(l==st.mixOut)switch(d){case Y.setup:c=s.data.scaleY,s.scaleY=c+(Math.abs(h)*M.signum(c)-c)*i;break;case Y.first:case Y.replace:c=s.scaleY,s.scaleY=c+(Math.abs(h)*M.signum(c)-c)*i;break;case Y.add:s.scaleY+=(h-s.data.scaleY)*i}else switch(d){case Y.setup:c=Math.abs(s.data.scaleY)*M.signum(h),s.scaleY=c+(h-c)*i;break;case Y.first:case Y.replace:c=Math.abs(s.scaleY)*M.signum(h),s.scaleY=c+(h-c)*i;break;case Y.add:s.scaleY+=(h-s.data.scaleY)*i}}}}class re extends Wt{constructor(t,a,e){super(t,a,`${z.shearX}|${e}`,`${z.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.shearX=s.data.shearX,s.shearY=s.data.shearY;return;case Y.first:s.shearX+=(s.data.shearX-s.shearX)*i,s.shearY+=(s.data.shearY-s.shearY)*i}return}let h=0,c=0;const u=G.search(o,e,3),m=this.curves[u/3];switch(m){case 0:const f=o[u];h=o[u+1],c=o[u+2];const x=(e-f)/(o[u+3]-f);h+=(o[u+3+1]-h)*x,c+=(o[u+3+2]-c)*x;break;case 1:h=o[u+1],c=o[u+2];break;default:h=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}switch(d){case Y.setup:s.shearX=s.data.shearX+h*i,s.shearY=s.data.shearY+c*i;break;case Y.first:case Y.replace:s.shearX+=(s.data.shearX+h-s.shearX)*i,s.shearY+=(s.data.shearY+c-s.shearY)*i;break;case Y.add:s.shearX+=h*i,s.shearY+=c*i}}}class ie extends ot{constructor(t,a,e){super(t,a,`${z.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.shearX=s.data.shearX;return;case Y.first:s.shearX+=(s.data.shearX-s.shearX)*i}return}const h=this.getCurveValue(e);switch(d){case Y.setup:s.shearX=s.data.shearX+h*i;break;case Y.first:case Y.replace:s.shearX+=(s.data.shearX+h-s.shearX)*i;break;case Y.add:s.shearX+=h*i}}}class oe extends ot{constructor(t,a,e){super(t,a,`${z.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,a,e,r,i,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.shearY=s.data.shearY;return;case Y.first:s.shearY+=(s.data.shearY-s.shearY)*i}return}const h=this.getCurveValue(e);switch(d){case Y.setup:s.shearY=s.data.shearY+h*i;break;case Y.first:case Y.replace:s.shearY+=(s.data.shearY+h-s.shearY)*i;break;case Y.add:s.shearY+=h*i}}}class he extends it{constructor(t,a,e){super(t,a,[`${z.rgb}|${e}`,`${z.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,a,e,r,i,d){t*=5,this.frames[t]=a,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=d}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const o=this.frames,h=s.color;if(e<o[0]){const k=s.data.color;switch(d){case Y.setup:h.setFromColor(k);return;case Y.first:h.add((k.r-h.r)*i,(k.g-h.g)*i,(k.b-h.b)*i,(k.a-h.a)*i)}return}let c=0,u=0,m=0,f=0;const x=G.search(o,e,5),b=this.curves[x/5];switch(b){case 0:const k=o[x];c=o[x+1],u=o[x+2],m=o[x+3],f=o[x+4];const g=(e-k)/(o[x+5]-k);c+=(o[x+5+1]-c)*g,u+=(o[x+5+2]-u)*g,m+=(o[x+5+3]-m)*g,f+=(o[x+5+4]-f)*g;break;case 1:c=o[x+1],u=o[x+2],m=o[x+3],f=o[x+4];break;default:c=this.getBezierValue(e,x,1,b-2),u=this.getBezierValue(e,x,2,b+18-2),m=this.getBezierValue(e,x,3,b+18*2-2),f=this.getBezierValue(e,x,4,b+18*3-2)}i==1?h.set(c,u,m,f):(d==Y.setup&&h.setFromColor(s.data.color),h.add((c-h.r)*i,(u-h.g)*i,(m-h.b)*i,(f-h.a)*i))}}class le extends it{constructor(t,a,e){super(t,a,[`${z.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,a,e,r,i){t<<=2,this.frames[t]=a,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const o=this.frames,h=s.color;if(e<o[0]){const b=s.data.color;switch(d){case Y.setup:h.r=b.r,h.g=b.g,h.b=b.b;return;case Y.first:h.r+=(b.r-h.r)*i,h.g+=(b.g-h.g)*i,h.b+=(b.b-h.b)*i}return}let c=0,u=0,m=0;const f=G.search(o,e,4),x=this.curves[f>>2];switch(x){case 0:const b=o[f];c=o[f+1],u=o[f+2],m=o[f+3];const k=(e-b)/(o[f+4]-b);c+=(o[f+4+1]-c)*k,u+=(o[f+4+2]-u)*k,m+=(o[f+4+3]-m)*k;break;case 1:c=o[f+1],u=o[f+2],m=o[f+3];break;default:c=this.getBezierValue(e,f,1,x-2),u=this.getBezierValue(e,f,2,x+18-2),m=this.getBezierValue(e,f,3,x+18*2-2)}if(i==1)h.r=c,h.g=u,h.b=m;else{if(d==Y.setup){const b=s.data.color;h.r=b.r,h.g=b.g,h.b=b.b}h.r+=(c-h.r)*i,h.g+=(u-h.g)*i,h.b+=(m-h.b)*i}}}class ce extends ot{constructor(t,a,e){super(t,a,`${z.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const o=s.color;if(e<this.frames[0]){const c=s.data.color;switch(d){case Y.setup:o.a=c.a;return;case Y.first:o.a+=(c.a-o.a)*i}return}const h=this.getCurveValue(e);i==1?o.a=h:(d==Y.setup&&(o.a=s.data.color.a),o.a+=(h-o.a)*i)}}class de extends it{constructor(t,a,e){super(t,a,[`${z.rgb}|${e}`,`${z.alpha}|${e}`,`${z.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,a,e,r,i,d,l,s,o){t<<=3,this.frames[t]=a,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=d,this.frames[t+5]=l,this.frames[t+6]=s,this.frames[t+7]=o}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const o=this.frames,h=s.color,c=s.darkColor;if(e<o[0]){const p=s.data.color,S=s.data.darkColor;switch(d){case Y.setup:h.setFromColor(p),c.r=S.r,c.g=S.g,c.b=S.b;return;case Y.first:h.add((p.r-h.r)*i,(p.g-h.g)*i,(p.b-h.b)*i,(p.a-h.a)*i),c.r+=(S.r-c.r)*i,c.g+=(S.g-c.g)*i,c.b+=(S.b-c.b)*i}return}let u=0,m=0,f=0,x=0,b=0,k=0,g=0;const y=G.search(o,e,8),w=this.curves[y>>3];switch(w){case 0:const p=o[y];u=o[y+1],m=o[y+2],f=o[y+3],x=o[y+4],b=o[y+5],k=o[y+6],g=o[y+7];const S=(e-p)/(o[y+8]-p);u+=(o[y+8+1]-u)*S,m+=(o[y+8+2]-m)*S,f+=(o[y+8+3]-f)*S,x+=(o[y+8+4]-x)*S,b+=(o[y+8+5]-b)*S,k+=(o[y+8+6]-k)*S,g+=(o[y+8+7]-g)*S;break;case 1:u=o[y+1],m=o[y+2],f=o[y+3],x=o[y+4],b=o[y+5],k=o[y+6],g=o[y+7];break;default:u=this.getBezierValue(e,y,1,w-2),m=this.getBezierValue(e,y,2,w+18-2),f=this.getBezierValue(e,y,3,w+18*2-2),x=this.getBezierValue(e,y,4,w+18*3-2),b=this.getBezierValue(e,y,5,w+18*4-2),k=this.getBezierValue(e,y,6,w+18*5-2),g=this.getBezierValue(e,y,7,w+18*6-2)}if(i==1)h.set(u,m,f,x),c.r=b,c.g=k,c.b=g;else{if(d==Y.setup){h.setFromColor(s.data.color);const p=s.data.darkColor;c.r=p.r,c.g=p.g,c.b=p.b}h.add((u-h.r)*i,(m-h.g)*i,(f-h.b)*i,(x-h.a)*i),c.r+=(b-c.r)*i,c.g+=(k-c.g)*i,c.b+=(g-c.b)*i}}}class me extends it{constructor(t,a,e){super(t,a,[`${z.rgb}|${e}`,`${z.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,a,e,r,i,d,l,s){t*=7,this.frames[t]=a,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=d,this.frames[t+5]=l,this.frames[t+6]=s}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const o=this.frames,h=s.color,c=s.darkColor;if(e<o[0]){const w=s.data.color,p=s.data.darkColor;switch(d){case Y.setup:h.r=w.r,h.g=w.g,h.b=w.b,c.r=p.r,c.g=p.g,c.b=p.b;return;case Y.first:h.r+=(w.r-h.r)*i,h.g+=(w.g-h.g)*i,h.b+=(w.b-h.b)*i,c.r+=(p.r-c.r)*i,c.g+=(p.g-c.g)*i,c.b+=(p.b-c.b)*i}return}let u=0,m=0,f=0,x=0,b=0,k=0;const g=G.search(o,e,7),y=this.curves[g/7];switch(y){case 0:const w=o[g];u=o[g+1],m=o[g+2],f=o[g+3],x=o[g+4],b=o[g+5],k=o[g+6];const p=(e-w)/(o[g+7]-w);u+=(o[g+7+1]-u)*p,m+=(o[g+7+2]-m)*p,f+=(o[g+7+3]-f)*p,x+=(o[g+7+4]-x)*p,b+=(o[g+7+5]-b)*p,k+=(o[g+7+6]-k)*p;break;case 1:u=o[g+1],m=o[g+2],f=o[g+3],x=o[g+4],b=o[g+5],k=o[g+6];break;default:u=this.getBezierValue(e,g,1,y-2),m=this.getBezierValue(e,g,2,y+18-2),f=this.getBezierValue(e,g,3,y+18*2-2),x=this.getBezierValue(e,g,4,y+18*3-2),b=this.getBezierValue(e,g,5,y+18*4-2),k=this.getBezierValue(e,g,6,y+18*5-2)}if(i==1)h.r=u,h.g=m,h.b=f,c.r=x,c.g=b,c.b=k;else{if(d==Y.setup){const w=s.data.color,p=s.data.darkColor;h.r=w.r,h.g=w.g,h.b=w.b,c.r=p.r,c.g=p.g,c.b=p.b}h.r+=(u-h.r)*i,h.g+=(m-h.g)*i,h.b+=(f-h.b)*i,c.r+=(x-c.r)*i,c.g+=(b-c.g)*i,c.b+=(k-c.b)*i}}}class kt extends G{constructor(t,a){super(t,[`${z.attachment}|${a}`]),this.slotIndex=0,this.slotIndex=a,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,a,e){this.frames[t]=a,this.attachmentNames[t]=e}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(s.bone.active){if(l==st.mixOut){d==Y.setup&&this.setAttachment(t,s,s.data.attachmentName);return}if(e<this.frames[0]){(d==Y.setup||d==Y.first)&&this.setAttachment(t,s,s.data.attachmentName);return}this.setAttachment(t,s,this.attachmentNames[G.search1(this.frames,e)])}}setAttachment(t,a,e){a.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class ue extends it{constructor(t,a,e,r){super(t,a,[`${z.deform}|${e}|${r.id}`]),this.slotIndex=0,this.slotIndex=e,this.attachment=r,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,a,e){this.frames[t]=a,this.vertices[t]=e}setBezier(t,a,e,r,i,d,l,s,o,h,c){const u=this.curves;let m=this.getFrameCount()+t*18;e==0&&(u[a]=2+m);const f=(r-d*2+s)*.03,x=o*.03-l*.06,b=((d-s)*3-r+h)*.006,k=(l-o+.33333333)*.018;let g=f*2+b,y=x*2+k,w=(d-r)*.3+f+b*.16666667,p=l*.3+x+k*.16666667,S=r+w,A=p;for(let C=m+18;m<C;m+=2)u[m]=S,u[m+1]=A,w+=g,p+=y,g+=b,y+=k,S+=w,A+=p}getCurvePercent(t,a){const e=this.curves;let r=e[a];switch(r){case 0:const s=this.frames[a];return(t-s)/(this.frames[a+this.getFrameEntries()]-s);case 1:return 0}if(r-=2,e[r]>t){const s=this.frames[a];return e[r+1]*(t-s)/(e[r]-s)}const i=r+18;for(r+=2;r<i;r+=2)if(e[r]>=t){const s=e[r-2],o=e[r-1];return o+(t-s)/(e[r]-s)*(e[r+1]-o)}const d=e[i-2],l=e[i-1];return l+(1-l)*(t-d)/(this.frames[a+this.getFrameEntries()]-d)}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const o=s.getAttachment();if(!o||!(o instanceof rt)||o.timelineAttachment!=this.attachment)return;const h=s.deform;h.length==0&&(d=Y.setup);const c=this.vertices,u=c[0].length,m=this.frames;if(e<m[0]){switch(d){case Y.setup:h.length=0;return;case Y.first:if(i==1){h.length=0;return}h.length=u;const g=o;if(g.bones){i=1-i;for(let y=0;y<u;y++)h[y]*=i}else{const y=g.vertices;for(let w=0;w<u;w++)h[w]+=(y[w]-h[w])*i}}return}if(h.length=u,e>=m[m.length-1]){const g=c[m.length-1];if(i==1)if(d==Y.add){const y=o;if(y.bones)for(let w=0;w<u;w++)h[w]+=g[w];else{const w=y.vertices;for(let p=0;p<u;p++)h[p]+=g[p]-w[p]}}else B.arrayCopy(g,0,h,0,u);else switch(d){case Y.setup:{const w=o;if(w.bones)for(let p=0;p<u;p++)h[p]=g[p]*i;else{const p=w.vertices;for(let S=0;S<u;S++){const A=p[S];h[S]=A+(g[S]-A)*i}}break}case Y.first:case Y.replace:for(let w=0;w<u;w++)h[w]+=(g[w]-h[w])*i;break;case Y.add:const y=o;if(y.bones)for(let w=0;w<u;w++)h[w]+=g[w]*i;else{const w=y.vertices;for(let p=0;p<u;p++)h[p]+=(g[p]-w[p])*i}}return}const f=G.search1(m,e),x=this.getCurvePercent(e,f),b=c[f],k=c[f+1];if(i==1)if(d==Y.add){const g=o;if(g.bones)for(let y=0;y<u;y++){const w=b[y];h[y]+=w+(k[y]-w)*x}else{const y=g.vertices;for(let w=0;w<u;w++){const p=b[w];h[w]+=p+(k[w]-p)*x-y[w]}}}else for(let g=0;g<u;g++){const y=b[g];h[g]=y+(k[g]-y)*x}else switch(d){case Y.setup:{const y=o;if(y.bones)for(let w=0;w<u;w++){const p=b[w];h[w]=(p+(k[w]-p)*x)*i}else{const w=y.vertices;for(let p=0;p<u;p++){const S=b[p],A=w[p];h[p]=A+(S+(k[p]-S)*x-A)*i}}break}case Y.first:case Y.replace:for(let y=0;y<u;y++){const w=b[y];h[y]+=(w+(k[y]-w)*x-h[y])*i}break;case Y.add:const g=o;if(g.bones)for(let y=0;y<u;y++){const w=b[y];h[y]+=(w+(k[y]-w)*x)*i}else{const y=g.vertices;for(let w=0;w<u;w++){const p=b[w];h[w]+=(p+(k[w]-p)*x-y[w])*i}}}}}const _e=class extends G{constructor(t){super(t,_e.propertyIds),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,a){this.frames[t]=a.time,this.events[t]=a}apply(t,a,e,r,i,d,l){if(!r)return;const s=this.frames,o=this.frames.length;if(a>e)this.apply(t,a,Number.MAX_VALUE,r,i,d,l),a=-1;else if(a>=s[o-1])return;if(e<s[0])return;let h=0;if(a<s[0])h=0;else{h=G.search1(s,a)+1;const c=s[h];for(;h>0&&s[h-1]==c;)h--}for(;h<o&&e>=s[h];h++)r.push(this.events[h])}};let Et=_e;Et.propertyIds=[`${z.event}`];const je=class extends G{constructor(t){super(t,je.propertyIds),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,a,e){this.frames[t]=a,this.drawOrders[t]=e}apply(t,a,e,r,i,d,l){if(l==st.mixOut){d==Y.setup&&B.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(e<this.frames[0]){(d==Y.setup||d==Y.first)&&B.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const s=G.search1(this.frames,e),o=this.drawOrders[s];if(!o)B.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const h=t.drawOrder,c=t.slots;for(let u=0,m=o.length;u<m;u++)h[u]=c[o[u]]}}};let yt=je;yt.propertyIds=[`${z.drawOrder}`];class fe extends it{constructor(t,a,e){super(t,a,[`${z.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,a,e,r,i,d,l){t*=6,this.frames[t]=a,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=i,this.frames[t+4]=d?1:0,this.frames[t+5]=l?1:0}apply(t,a,e,r,i,d,l){const s=t.ikConstraints[this.ikConstraintIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.mix=s.data.mix,s.softness=s.data.softness,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch;return;case Y.first:s.mix+=(s.data.mix-s.mix)*i,s.softness+=(s.data.softness-s.softness)*i,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}return}let h=0,c=0;const u=G.search(o,e,6),m=this.curves[u/6];switch(m){case 0:const f=o[u];h=o[u+1],c=o[u+2];const x=(e-f)/(o[u+6]-f);h+=(o[u+6+1]-h)*x,c+=(o[u+6+2]-c)*x;break;case 1:h=o[u+1],c=o[u+2];break;default:h=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}d==Y.setup?(s.mix=s.data.mix+(h-s.data.mix)*i,s.softness=s.data.softness+(c-s.data.softness)*i,l==st.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=o[u+3],s.compress=o[u+4]!=0,s.stretch=o[u+5]!=0)):(s.mix+=(h-s.mix)*i,s.softness+=(c-s.softness)*i,l==st.mixIn&&(s.bendDirection=o[u+3],s.compress=o[u+4]!=0,s.stretch=o[u+5]!=0))}}class ge extends it{constructor(t,a,e){super(t,a,[`${z.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,a,e,r,i,d,l,s){const o=this.frames;t*=7,o[t]=a,o[t+1]=e,o[t+2]=r,o[t+3]=i,o[t+4]=d,o[t+5]=l,o[t+6]=s}apply(t,a,e,r,i,d,l){const s=t.transformConstraints[this.transformConstraintIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){const g=s.data;switch(d){case Y.setup:s.mixRotate=g.mixRotate,s.mixX=g.mixX,s.mixY=g.mixY,s.mixScaleX=g.mixScaleX,s.mixScaleY=g.mixScaleY,s.mixShearY=g.mixShearY;return;case Y.first:s.mixRotate+=(g.mixRotate-s.mixRotate)*i,s.mixX+=(g.mixX-s.mixX)*i,s.mixY+=(g.mixY-s.mixY)*i,s.mixScaleX+=(g.mixScaleX-s.mixScaleX)*i,s.mixScaleY+=(g.mixScaleY-s.mixScaleY)*i,s.mixShearY+=(g.mixShearY-s.mixShearY)*i}return}let h,c,u,m,f,x;const b=G.search(o,e,7),k=this.curves[b/7];switch(k){case 0:const g=o[b];h=o[b+1],c=o[b+2],u=o[b+3],m=o[b+4],f=o[b+5],x=o[b+6];const y=(e-g)/(o[b+7]-g);h+=(o[b+7+1]-h)*y,c+=(o[b+7+2]-c)*y,u+=(o[b+7+3]-u)*y,m+=(o[b+7+4]-m)*y,f+=(o[b+7+5]-f)*y,x+=(o[b+7+6]-x)*y;break;case 1:h=o[b+1],c=o[b+2],u=o[b+3],m=o[b+4],f=o[b+5],x=o[b+6];break;default:h=this.getBezierValue(e,b,1,k-2),c=this.getBezierValue(e,b,2,k+18-2),u=this.getBezierValue(e,b,3,k+18*2-2),m=this.getBezierValue(e,b,4,k+18*3-2),f=this.getBezierValue(e,b,5,k+18*4-2),x=this.getBezierValue(e,b,6,k+18*5-2)}if(d==Y.setup){const g=s.data;s.mixRotate=g.mixRotate+(h-g.mixRotate)*i,s.mixX=g.mixX+(c-g.mixX)*i,s.mixY=g.mixY+(u-g.mixY)*i,s.mixScaleX=g.mixScaleX+(m-g.mixScaleX)*i,s.mixScaleY=g.mixScaleY+(f-g.mixScaleY)*i,s.mixShearY=g.mixShearY+(x-g.mixShearY)*i}else s.mixRotate+=(h-s.mixRotate)*i,s.mixX+=(c-s.mixX)*i,s.mixY+=(u-s.mixY)*i,s.mixScaleX+=(m-s.mixScaleX)*i,s.mixScaleY+=(f-s.mixScaleY)*i,s.mixShearY+=(x-s.mixShearY)*i}}class pe extends ot{constructor(t,a,e){super(t,a,`${z.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,a,e,r,i,d,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.position=s.data.position;return;case Y.first:s.position+=(s.data.position-s.position)*i}return}const h=this.getCurveValue(e);d==Y.setup?s.position=s.data.position+(h-s.data.position)*i:s.position+=(h-s.position)*i}}class xe extends ot{constructor(t,a,e){super(t,a,`${z.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,a,e,r,i,d,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.spacing=s.data.spacing;return;case Y.first:s.spacing+=(s.data.spacing-s.spacing)*i}return}const h=this.getCurveValue(e);d==Y.setup?s.spacing=s.data.spacing+(h-s.data.spacing)*i:s.spacing+=(h-s.spacing)*i}}class be extends it{constructor(t,a,e){super(t,a,[`${z.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,a,e,r,i){const d=this.frames;t<<=2,d[t]=a,d[t+1]=e,d[t+2]=r,d[t+3]=i}apply(t,a,e,r,i,d,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const o=this.frames;if(e<o[0]){switch(d){case Y.setup:s.mixRotate=s.data.mixRotate,s.mixX=s.data.mixX,s.mixY=s.data.mixY;return;case Y.first:s.mixRotate+=(s.data.mixRotate-s.mixRotate)*i,s.mixX+=(s.data.mixX-s.mixX)*i,s.mixY+=(s.data.mixY-s.mixY)*i}return}let h,c,u;const m=G.search(o,e,4),f=this.curves[m>>2];switch(f){case 0:const x=o[m];h=o[m+1],c=o[m+2],u=o[m+3];const b=(e-x)/(o[m+4]-x);h+=(o[m+4+1]-h)*b,c+=(o[m+4+2]-c)*b,u+=(o[m+4+3]-u)*b;break;case 1:h=o[m+1],c=o[m+2],u=o[m+3];break;default:h=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2),u=this.getBezierValue(e,m,3,f+18*2-2)}if(d==Y.setup){const x=s.data;s.mixRotate=x.mixRotate+(h-x.mixRotate)*i,s.mixX=x.mixX+(c-x.mixX)*i,s.mixY=x.mixY+(u-x.mixY)*i}else s.mixRotate+=(h-s.mixRotate)*i,s.mixX+=(c-s.mixX)*i,s.mixY+=(u-s.mixY)*i}}const wt=class extends G{constructor(t,a,e){super(t,[`${z.sequence}|${a}|${e.sequence.id}`]),this.slotIndex=a,this.attachment=e}getFrameEntries(){return wt.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,a,e,r,i){const d=this.frames;t*=wt.ENTRIES,d[t]=a,d[t+wt.MODE]=e|r<<4,d[t+wt.DELAY]=i}apply(t,a,e,r,i,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const o=s.attachment,h=this.attachment;if(o!=h&&(!(o instanceof rt)||o.timelineAttachment!=h))return;const c=this.frames;if(e<c[0]){(d==Y.setup||d==Y.first)&&(s.sequenceIndex=-1);return}const u=G.search(c,e,wt.ENTRIES),m=c[u],f=c[u+wt.MODE],x=c[u+wt.DELAY];if(!this.attachment.sequence)return;let b=f>>4;const k=this.attachment.sequence.regions.length,g=Qt[f&15];if(g!=ct.hold)switch(b+=(e-m)/x+1e-5|0,g){case ct.once:b=Math.min(k-1,b);break;case ct.loop:b%=k;break;case ct.pingpong:{const y=(k<<1)-2;b=y==0?0:b%y,b>=k&&(b=y-b);break}case ct.onceReverse:b=Math.max(k-1-b,0);break;case ct.loopReverse:b=k-1-b%k;break;case ct.pingpongReverse:{const y=(k<<1)-2;b=y==0?0:(b+k-1)%y,b>=k&&(b=y-b)}}s.sequenceIndex=b}};let vt=wt;vt.ENTRIES=3,vt.MODE=1,vt.DELAY=2;const dt=class{constructor(n){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Ge(this),this.propertyIDs=new Ue,this.animationsChanged=!1,this.trackEntryPool=new rs(()=>new Nt),this.data=n}static emptyAnimation(){return dt._emptyAnimation}update(n){n*=this.timeScale;const t=this.tracks;for(let a=0,e=t.length;a<e;a++){const r=t[a];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let i=n*r.timeScale;if(r.delay>0){if(r.delay-=i,r.delay>0)continue;i=-r.delay,r.delay=0}let d=r.next;if(d){const l=r.trackLast-d.delay;if(l>=0){for(d.delay=0,d.trackTime+=r.timeScale==0?0:(l/r.timeScale+n)*d.timeScale,r.trackTime+=i,this.setCurrent(a,d,!0);d.mixingFrom;)d.mixTime+=n,d=d.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){t[a]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,n)){let l=r.mixingFrom;for(r.mixingFrom=null,l&&(l.mixingTo=null);l;)this.queue.end(l),l=l.mixingFrom}r.trackTime+=i}this.queue.drain()}updateMixingFrom(n,t){const a=n.mixingFrom;if(!a)return!0;const e=this.updateMixingFrom(a,t);return a.animationLast=a.nextAnimationLast,a.trackLast=a.nextTrackLast,n.mixTime>0&&n.mixTime>=n.mixDuration?((a.totalAlpha==0||n.mixDuration==0)&&(n.mixingFrom=a.mixingFrom,a.mixingFrom&&(a.mixingFrom.mixingTo=n),n.interruptAlpha=a.interruptAlpha,this.queue.end(a)),e):(a.trackTime+=t*a.timeScale,n.mixTime+=t,!1)}apply(n){if(!n)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,a=this.tracks;let e=!1;for(let d=0,l=a.length;d<l;d++){const s=a[d];if(!s||s.delay>0)continue;e=!0;const o=d==0?Y.first:s.mixBlend;let h=s.alpha;s.mixingFrom?h*=this.applyMixingFrom(s,n,o):s.trackTime>=s.trackEnd&&!s.next&&(h=0);const c=s.animationLast,u=s.getAnimationTime();let m=u,f=t;s.reverse&&(m=s.animation.duration-m,f=null);const x=s.animation.timelines,b=x.length;if(d==0&&h==1||o==Y.add)for(let k=0;k<b;k++){B.webkit602BugfixHelper(h,o);const g=x[k];g instanceof kt?this.applyAttachmentTimeline(g,n,m,o,!0):g.apply(n,c,m,f,h,o,st.mixIn)}else{const k=s.timelineMode,g=s.shortestRotation,y=!g&&s.timelinesRotation.length!=b<<1;y&&(s.timelinesRotation.length=b<<1);for(let w=0;w<b;w++){const p=x[w],S=k[w]==we?o:Y.setup;!g&&p instanceof Bt?this.applyRotateTimeline(p,n,m,h,S,s.timelinesRotation,w<<1,y):p instanceof kt?this.applyAttachmentTimeline(p,n,m,o,!0):(B.webkit602BugfixHelper(h,o),p.apply(n,c,m,f,h,S,st.mixIn))}}this.queueEvents(s,u),t.length=0,s.nextAnimationLast=u,s.nextTrackLast=s.trackTime}const r=this.unkeyedState+Je,i=n.slots;for(let d=0,l=n.slots.length;d<l;d++){const s=i[d];if(s.attachmentState==r){const o=s.data.attachmentName;s.setAttachment(o?n.getAttachment(s.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(n,t,a){const e=n.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,a);let r=0;n.mixDuration==0?(r=1,a==Y.first&&(a=Y.setup)):(r=n.mixTime/n.mixDuration,r>1&&(r=1),a!=Y.first&&(a=e.mixBlend));const i=r<e.attachmentThreshold,d=r<e.drawOrderThreshold,l=e.animation.timelines,s=l.length,o=e.alpha*n.interruptAlpha,h=o*(1-r),c=e.animationLast,u=e.getAnimationTime();let m=u,f=null;if(e.reverse?m=e.animation.duration-m:r<e.eventThreshold&&(f=this.events),a==Y.add)for(let x=0;x<s;x++)l[x].apply(t,c,m,f,h,a,st.mixOut);else{const x=e.timelineMode,b=e.timelineHoldMix,k=e.shortestRotation,g=!k&&e.timelinesRotation.length!=s<<1;g&&(e.timelinesRotation.length=s<<1),e.totalAlpha=0;for(let y=0;y<s;y++){const w=l[y];let p=st.mixOut,S,A=0;switch(x[y]){case we:if(!d&&w instanceof yt)continue;S=a,A=h;break;case He:S=Y.setup,A=h;break;case Ke:S=a,A=o;break;case ke:S=Y.setup,A=o;break;default:S=Y.setup;const C=b[y];A=o*Math.max(0,1-C.mixTime/C.mixDuration);break}e.totalAlpha+=A,!k&&w instanceof Bt?this.applyRotateTimeline(w,t,m,A,S,e.timelinesRotation,y<<1,g):w instanceof kt?this.applyAttachmentTimeline(w,t,m,S,i):(B.webkit602BugfixHelper(A,a),d&&w instanceof yt&&S==Y.setup&&(p=st.mixIn),w.apply(t,c,m,f,A,S,p))}}return n.mixDuration>0&&this.queueEvents(e,u),this.events.length=0,e.nextAnimationLast=u,e.nextTrackLast=e.trackTime,r}applyAttachmentTimeline(n,t,a,e,r){const i=t.slots[n.slotIndex];i.bone.active&&(a<n.frames[0]?(e==Y.setup||e==Y.first)&&this.setAttachment(t,i,i.data.attachmentName,r):this.setAttachment(t,i,n.attachmentNames[G.search1(n.frames,a)],r),i.attachmentState<=this.unkeyedState&&(i.attachmentState=this.unkeyedState+Je))}setAttachment(n,t,a,e){t.setAttachment(a?n.getAttachment(t.data.index,a):null),e&&(t.attachmentState=this.unkeyedState+ms)}applyRotateTimeline(n,t,a,e,r,i,d,l){if(l&&(i[d]=0),e==1){n.apply(t,0,a,null,1,r,st.mixIn);return}const s=t.bones[n.boneIndex];if(!s.active)return;const o=n.frames;let h=0,c=0;if(a<o[0])switch(r){case Y.setup:s.rotation=s.data.rotation;default:return;case Y.first:h=s.rotation,c=s.data.rotation}else h=r==Y.setup?s.data.rotation:s.rotation,c=s.data.rotation+n.getCurveValue(a);let u=0,m=c-h;if(m-=(16384-(16384.499999999996-m/360|0))*360,m==0)u=i[d];else{let f=0,x=0;l?(f=0,x=m):(f=i[d],x=i[d+1]);const b=m>0;let k=f>=0;M.signum(x)!=M.signum(m)&&Math.abs(x)<=90&&(Math.abs(f)>180&&(f+=360*M.signum(f)),k=b),u=m+f-f%360,k!=b&&(u+=360*M.signum(f)),i[d]=u}i[d+1]=m,s.rotation=h+u*e}queueEvents(n,t){const a=n.animationStart,e=n.animationEnd,r=e-a,i=n.trackLast%r,d=this.events;let l=0;const s=d.length;for(;l<s;l++){const h=d[l];if(h.time<i)break;h.time>e||this.queue.event(n,h)}let o=!1;for(n.loop?o=r==0||i>n.trackTime%r:o=t>=e&&n.animationLast<e,o&&this.queue.complete(n);l<s;l++){const h=d[l];h.time<a||this.queue.event(n,h)}}clearTracks(){const n=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,a=this.tracks.length;t<a;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=n,this.queue.drain()}clearTrack(n){if(n>=this.tracks.length)return;const t=this.tracks[n];if(!t)return;this.queue.end(t),this.clearNext(t);let a=t;for(;;){const e=a.mixingFrom;if(!e)break;this.queue.end(e),a.mixingFrom=null,a.mixingTo=null,a=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(n,t,a){const e=this.expandToIndex(n);this.tracks[n]=t,t.previous=null,e&&(a&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(n,t,a=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(n,e,a)}setAnimationWith(n,t,a=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,r=this.expandToIndex(n);r&&(r.nextTrackLast==-1?(this.tracks[n]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,e=!1):this.clearNext(r));const i=this.trackEntry(n,t,a,r);return this.setCurrent(n,i,e),this.queue.drain(),i}addAnimation(n,t,a=!1,e=0){const r=this.data.skeletonData.findAnimation(t);if(!r)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(n,r,a,e)}addAnimationWith(n,t,a=!1,e=0){if(!t)throw new Error("animation cannot be null.");let r=this.expandToIndex(n);if(r)for(;r.next;)r=r.next;const i=this.trackEntry(n,t,a,r);return r?(r.next=i,i.previous=r,e<=0&&(e+=r.getTrackComplete()-i.mixDuration)):(this.setCurrent(n,i,!0),this.queue.drain()),i.delay=e,i}setEmptyAnimation(n,t=0){const a=this.setAnimationWith(n,dt.emptyAnimation(),!1);return a.mixDuration=t,a.trackEnd=t,a}addEmptyAnimation(n,t=0,a=0){const e=this.addAnimationWith(n,dt.emptyAnimation(),!1,a);return a<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(n=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let a=0,e=this.tracks.length;a<e;a++){const r=this.tracks[a];r&&this.setEmptyAnimation(r.trackIndex,n)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(n){return n<this.tracks.length?this.tracks[n]:(B.ensureArrayCapacity(this.tracks,n+1,null),this.tracks.length=n+1,null)}trackEntry(n,t,a,e){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=n,r.animation=t,r.loop=a,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=e?this.data.getMix(e.animation,t):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=Y.replace,r}clearNext(n){let t=n.next;for(;t;)this.queue.dispose(t),t=t.next;n.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const n=this.tracks;for(let t=0,a=n.length;t<a;t++){let e=n[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=Y.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(n){const t=n.mixingTo,a=n.animation.timelines,e=n.animation.timelines.length,r=n.timelineMode;r.length=e;const i=n.timelineHoldMix;i.length=0;const d=this.propertyIDs;if(t&&t.holdPrevious){for(let l=0;l<e;l++)r[l]=d.addAll(a[l].getPropertyIds())?ke:Ke;return}t:for(let l=0;l<e;l++){const s=a[l],o=s.getPropertyIds();if(!d.addAll(o))r[l]=we;else if(!t||s instanceof kt||s instanceof yt||s instanceof Et||!t.animation.hasTimeline(o))r[l]=He;else{for(let h=t.mixingTo;h;h=h.mixingTo)if(!h.animation.hasTimeline(o)){if(n.mixDuration>0){r[l]=ds,i[l]=h;continue t}break}r[l]=ke}}}getCurrent(n){return n>=this.tracks.length?null:this.tracks[n]}addListener(n){if(!n)throw new Error("listener cannot be null.");this.listeners.push(n)}removeListener(n){const t=this.listeners.indexOf(n);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(n,t,a){dt.deprecatedWarning1||(dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(n,t,a)}addAnimationByName(n,t,a,e){dt.deprecatedWarning2||(dt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(n,t,a,e)}hasAnimation(n){return this.data.skeletonData.findAnimation(n)!==null}hasAnimationByName(n){return dt.deprecatedWarning3||(dt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(n)}};let Ct=dt;Ct._emptyAnimation=new Lt("<empty>",[],0),Ct.deprecatedWarning1=!1,Ct.deprecatedWarning2=!1,Ct.deprecatedWarning3=!1;const gt=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=Y.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return gt.deprecatedWarning1||(gt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){gt.deprecatedWarning1||(gt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return gt.deprecatedWarning2||(gt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){gt.deprecatedWarning2||(gt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Nt=gt;Nt.deprecatedWarning1=!1,Nt.deprecatedWarning2=!1;class Ge{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(Z.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(Z.interrupt),this.objects.push(t)}end(t){this.objects.push(Z.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(Z.dispose),this.objects.push(t)}complete(t){this.objects.push(Z.complete),this.objects.push(t)}event(t,a){this.objects.push(Z.event),this.objects.push(t),this.objects.push(a)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,a=this.animState.listeners;for(let e=0;e<t.length;e+=2){const r=t[e],i=t[e+1];switch(r){case Z.start:i.listener&&i.listener.start&&i.listener.start(i);for(let l=0;l<a.length;l++){const s=a[l];s.start&&s.start(i)}break;case Z.interrupt:i.listener&&i.listener.interrupt&&i.listener.interrupt(i);for(let l=0;l<a.length;l++){const s=a[l];s.interrupt&&s.interrupt(i)}break;case Z.end:i.listener&&i.listener.end&&i.listener.end(i);for(let l=0;l<a.length;l++){const s=a[l];s.end&&s.end(i)}case Z.dispose:i.listener&&i.listener.dispose&&i.listener.dispose(i);for(let l=0;l<a.length;l++){const s=a[l];s.dispose&&s.dispose(i)}this.animState.trackEntryPool.free(i);break;case Z.complete:i.listener&&i.listener.complete&&i.listener.complete(i);for(let l=0;l<a.length;l++){const s=a[l];s.complete&&s.complete(i)}break;case Z.event:const d=t[e+++2];i.listener&&i.listener.event&&i.listener.event(i,d);for(let l=0;l<a.length;l++){const s=a[l];s.event&&s.event(i,d)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var Z=(n=>(n[n.start=0]="start",n[n.interrupt=1]="interrupt",n[n.end=2]="end",n[n.dispose=3]="dispose",n[n.complete=4]="complete",n[n.event=5]="event",n))(Z||{});class cs{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,a){}}const we=0,He=1,Ke=2,ke=3,ds=4,Je=1,ms=2;class Qe{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,a,e){const r=this.skeletonData.findAnimation(t);if(!r)throw new Error(`Animation not found: ${t}`);const i=this.skeletonData.findAnimation(a);if(!i)throw new Error(`Animation not found: ${a}`);this.setMixWith(r,i,e)}setMixWith(t,a,e){if(!t)throw new Error("from cannot be null.");if(!a)throw new Error("to cannot be null.");const r=`${t.name}.${a.name}`;this.animationToMixTime[r]=e}getMix(t,a){const e=`${t.name}.${a.name}`,r=this.animationToMixTime[e];return r===void 0?this.defaultMix:r}}class us{constructor(t){this.atlas=t}loadSequence(t,a,e){const r=e.regions;for(let i=0,d=r.length;i<d;i++){const l=e.getPath(a,i),s=this.atlas.findRegion(l);if(s==null)throw new Error(`Region not found in atlas: ${l} (sequence: ${t})`);r[i]=s,r[i].renderObject=r[i]}}newRegionAttachment(t,a,e,r){const i=new N(a,e);if(r!=null)this.loadSequence(a,e,r);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (region attachment: ${a})`);d.renderObject=d,i.region=d}return i}newMeshAttachment(t,a,e,r){const i=new At(a,e);if(r!=null)this.loadSequence(a,e,r);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${a})`);d.renderObject=d,i.region=d}return i}newBoundingBoxAttachment(t,a){return new zt(a)}newPathAttachment(t,a){return new St(a)}newPointAttachment(t,a){return new jt(a)}newClippingAttachment(t,a){return new _t(a)}}class ye{constructor(t,a,e){if(this.matrix=new ls,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!a)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=a,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,a,e,r,i,d,l){this.ax=t,this.ay=a,this.arotation=e,this.ascaleX=r,this.ascaleY=i,this.ashearX=d,this.ashearY=l;const s=this.parent,o=this.matrix,h=this.skeleton.scaleX,c=Xt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!s){const b=this.skeleton,k=e+90+l;o.a=M.cosDeg(e+d)*r*h,o.c=M.cosDeg(k)*i*h,o.b=M.sinDeg(e+d)*r*c,o.d=M.sinDeg(k)*i*c,o.tx=t*h+b.x,o.ty=a*c+b.y;return}let u=s.matrix.a,m=s.matrix.c,f=s.matrix.b,x=s.matrix.d;switch(o.tx=u*t+m*a+s.matrix.tx,o.ty=f*t+x*a+s.matrix.ty,this.data.transformMode){case nt.Normal:{const b=e+90+l,k=M.cosDeg(e+d)*r,g=M.cosDeg(b)*i,y=M.sinDeg(e+d)*r,w=M.sinDeg(b)*i;o.a=u*k+m*y,o.c=u*g+m*w,o.b=f*k+x*y,o.d=f*g+x*w;return}case nt.OnlyTranslation:{const b=e+90+l;o.a=M.cosDeg(e+d)*r,o.c=M.cosDeg(b)*i,o.b=M.sinDeg(e+d)*r,o.d=M.sinDeg(b)*i;break}case nt.NoRotationOrReflection:{let b=u*u+f*f,k=0;b>1e-4?(b=Math.abs(u*x-m*f)/b,u/=h,f/=c,m=f*b,x=u*b,k=Math.atan2(f,u)*M.radDeg):(u=0,f=0,k=90-Math.atan2(x,m)*M.radDeg);const g=e+d-k,y=e+l-k+90,w=M.cosDeg(g)*r,p=M.cosDeg(y)*i,S=M.sinDeg(g)*r,A=M.sinDeg(y)*i;o.a=u*w-m*S,o.c=u*p-m*A,o.b=f*w+x*S,o.d=f*p+x*A;break}case nt.NoScale:case nt.NoScaleOrReflection:{const b=M.cosDeg(e),k=M.sinDeg(e);let g=(u*b+m*k)/h,y=(f*b+x*k)/c,w=Math.sqrt(g*g+y*y);w>1e-5&&(w=1/w),g*=w,y*=w,w=Math.sqrt(g*g+y*y),this.data.transformMode==nt.NoScale&&u*x-m*f<0!=(h<0!=c<0)&&(w=-w);const p=Math.PI/2+Math.atan2(y,g),S=Math.cos(p)*w,A=Math.sin(p)*w,C=M.cosDeg(d)*r,v=M.cosDeg(90+l)*i,F=M.sinDeg(d)*r,X=M.sinDeg(90+l)*i;o.a=g*C+S*F,o.c=g*v+S*X,o.b=y*C+A*F,o.d=y*v+A*X;break}}o.a*=h,o.c*=h,o.b*=c,o.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*M.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*M.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,a=this.matrix;if(!t){this.ax=a.tx-this.skeleton.x,this.ay=a.ty-this.skeleton.y,this.arotation=Math.atan2(a.b,a.a)*M.radDeg,this.ascaleX=Math.sqrt(a.a*a.a+a.b*a.b),this.ascaleY=Math.sqrt(a.c*a.c+a.d*a.d),this.ashearX=0,this.ashearY=Math.atan2(a.a*a.c+a.b*a.d,a.a*a.d-a.b*a.c)*M.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),i=a.tx-e.tx,d=a.ty-e.ty;this.ax=i*e.d*r-d*e.c*r,this.ay=d*e.a*r-i*e.b*r;const l=r*e.d,s=r*e.a,o=r*e.c,h=r*e.b,c=l*a.a-o*a.b,u=l*a.c-o*a.d,m=s*a.b-h*a.a,f=s*a.d-h*a.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+m*m),this.ascaleX>1e-4){const x=c*f-u*m;this.ascaleY=x/this.ascaleX,this.ashearY=Math.atan2(c*u+m*f,x)*M.radDeg,this.arotation=Math.atan2(m,c)*M.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,u)*M.radDeg}worldToLocal(t){const a=this.matrix,e=a.a,r=a.c,i=a.b,d=a.d,l=1/(e*d-r*i),s=t.x-a.tx,o=t.y-a.ty;return t.x=s*d*l-o*r*l,t.y=o*e*l-s*i*l,t}localToWorld(t){const a=this.matrix,e=t.x,r=t.y;return t.x=e*a.a+r*a.c+a.tx,t.y=e*a.b+r*a.d+a.ty,t}worldToLocalRotation(t){const a=M.sinDeg(t),e=M.cosDeg(t),r=this.matrix;return Math.atan2(r.a*a-r.b*e,r.d*e-r.c*a)*M.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const a=M.sinDeg(t),e=M.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+a*r.d,e*r.a+a*r.c)*M.radDeg}rotateWorld(t){const a=this.matrix,e=a.a,r=a.c,i=a.b,d=a.d,l=M.cosDeg(t),s=M.sinDeg(t);a.a=l*e-s*i,a.c=l*r-s*d,a.b=s*e+l*i,a.d=s*r+l*d}}class Se{constructor(t,a,e){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=nt.Normal,this.skinRequired=!1,this.color=new L,t<0)throw new Error("index must be >= 0.");if(!a)throw new Error("name cannot be null.");this.index=t,this.name=a,this.parent=e}}class Ut{constructor(t,a,e){this.name=t,this.order=a,this.skinRequired=e}}class Ae{constructor(t,a){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!a)throw new Error("data cannot be null.");this.time=t,this.data=a}}class Ie{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class Ze{constructor(t,a){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!a)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let r=0;r<t.bones.length;r++){const i=a.findBone(t.bones[r].name);if(!i)throw new Error(`Couldn't find bone ${t.bones[r].name}`);this.bones.push(i)}const e=a.findBone(t.target.name);if(!e)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=e}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,a=this.bones;switch(a.length){case 1:this.apply1(a[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(a[0],a[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,a,e,r,i,d,l){const s=t.parent.matrix;if(!s)throw new Error("IK bone must have parent.");const o=s.a;let h=s.c;const c=s.b;let u=s.d,m=-t.ashearX-t.arotation,f=0,x=0;const b=t.skeleton.scaleX,k=Xt.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case nt.OnlyTranslation:f=a-t.worldX,x=e-t.worldY,Xt.yDown&&(x=-x);break;case nt.NoRotationOrReflection:const w=Math.abs(o*u-h*c)/(o*o+c*c),p=o/b,S=c/k;h=-S*w*b,u=p*w*k,m+=Math.atan2(S,p)*M.radDeg;default:const A=a-s.tx,C=e-s.ty,v=o*u-h*c;f=(A*u-C*h)/v-t.ax,x=(C*o-A*c)/v-t.ay}m+=Math.atan2(x,f)*M.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let g=t.ascaleX,y=t.ascaleY;if(r||i){switch(t.data.transformMode){case nt.NoScale:case nt.NoScaleOrReflection:f=a-t.worldX,x=e-t.worldY}const w=t.data.length*g,p=Math.sqrt(f*f+x*x);if(r&&p<w||i&&p>w&&w>1e-4){const S=(p/w-1)*l+1;g*=S,d&&(y*=S)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*l,g,y,t.ashearX,t.ashearY)}apply2(t,a,e,r,i,d,l,s,o){const h=t.ax,c=t.ay;let u=t.ascaleX,m=t.ascaleY,f=u,x=m,b=a.ascaleX;const k=t.matrix;let g=0,y=0,w=0;u<0?(u=-u,g=180,w=-1):(g=0,w=1),m<0&&(m=-m,w=-w),b<0?(b=-b,y=180):y=0;const p=a.ax;let S=0,A=0,C=0,v=k.a,F=k.c,X=k.b,T=k.d;const R=Math.abs(u-m)<=1e-4;!R||d?(S=0,A=v*p+k.tx,C=X*p+k.ty):(S=a.ay,A=v*p+F*S+k.tx,C=X*p+T*S+k.ty);const E=t.parent.matrix;if(!E)throw new Error("IK parent must itself have a parent.");v=E.a,F=E.c,X=E.b,T=E.d;const O=1/(v*T-F*X);let V=A-E.tx,D=C-E.ty;const $=(V*T-D*F)*O-h,H=(D*v-V*X)*O-c,j=Math.sqrt($*$+H*H);let J=a.data.length*b,P,q;if(j<1e-4){this.apply1(t,e,r,!1,d,!1,o),a.updateWorldTransformWith(p,S,0,a.ascaleX,a.ascaleY,a.ashearX,a.ashearY);return}V=e-E.tx,D=r-E.ty;let _=(V*T-D*F)*O-h,tt=(D*v-V*X)*O-c,at=_*_+tt*tt;if(s!=0){s*=u*(b+1)*.5;const Q=Math.sqrt(at),ut=Q-j-J*u+s;if(ut>0){let ft=Math.min(1,ut/(s*2))-1;ft=(ut-s*(1-ft*ft))/Q,_-=ft*_,tt-=ft*tt,at=_*_+tt*tt}}t:if(R){J*=u;let Q=(at-j*j-J*J)/(2*j*J);Q<-1?(Q=-1,q=Math.PI*i):Q>1?(Q=1,q=0,d&&(v=(Math.sqrt(at)/(j+J)-1)*o+1,f*=v,l&&(x*=v))):q=Math.acos(Q)*i,v=j+J*Q,F=J*Math.sin(q),P=Math.atan2(tt*v-_*F,_*v+tt*F)}else{v=u*J,F=m*J;const Q=v*v,ut=F*F,ft=Math.atan2(tt,_);X=ut*j*j+Q*at-Q*ut;const Dt=-2*ut*j,Ve=ut-Q;if(T=Dt*Dt-4*Ve*X,T>=0){let It=Math.sqrt(T);Dt<0&&(It=-It),It=-(Dt+It)*.5;const We=It/Ve,Ne=X/It,Yt=Math.abs(We)<Math.abs(Ne)?We:Ne;if(Yt*Yt<=at){D=Math.sqrt(at-Yt*Yt)*i,P=ft-Math.atan2(D,Yt),q=Math.atan2(D/m,(Yt-j)/u);break t}}let $e=M.PI,Vt=j-v,Gt=Vt*Vt,Pe=0,qe=0,$t=j+v,Ht=$t*$t,Le=0;X=-v*j/(Q-ut),X>=-1&&X<=1&&(X=Math.acos(X),V=v*Math.cos(X)+j,D=F*Math.sin(X),T=V*V+D*D,T<Gt&&($e=X,Gt=T,Vt=V,Pe=D),T>Ht&&(qe=X,Ht=T,$t=V,Le=D)),at<=(Gt+Ht)*.5?(P=ft-Math.atan2(Pe*i,Vt),q=$e*i):(P=ft-Math.atan2(Le*i,$t),q=qe*i)}const De=Math.atan2(S,p)*w;let Mt=t.arotation;P=(P-De)*M.radDeg+g-Mt,P>180?P-=360:P<-180&&(P+=360),t.updateWorldTransformWith(h,c,Mt+P*o,f,x,0,0),Mt=a.arotation,q=((q+De)*M.radDeg-a.ashearX)*w+y-Mt,q>180?q-=360:q<-180&&(q+=360),a.updateWorldTransformWith(p,S,Mt+q*o,a.ascaleX,a.ascaleY,a.ashearX,a.ashearY)}}class Ye extends Ut{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class ve extends Ut{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=bt.Fixed,this.spacingMode=K.Fixed,this.rotateMode=Tt.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var K=(n=>(n[n.Length=0]="Length",n[n.Fixed=1]="Fixed",n[n.Percent=2]="Percent",n[n.Proportional=3]="Proportional",n))(K||{});const pt=class{constructor(n,t){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!n)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=n,this.bones=new Array;for(let e=0,r=n.bones.length;e<r;e++){const i=t.findBone(n.bones[e].name);if(!i)throw new Error(`Couldn't find bone ${n.bones[e].name}.`);this.bones.push(i)}const a=t.findSlot(n.target.name);if(!a)throw new Error(`Couldn't find target bone ${n.target.name}`);this.target=a,this.position=n.position,this.spacing=n.spacing,this.mixRotate=n.mixRotate,this.mixX=n.mixX,this.mixY=n.mixY}isActive(){return this.active}update(){const n=this.target.getAttachment();if(!(n instanceof St))return;const t=this.mixRotate,a=this.mixX,e=this.mixY;if(t==0&&a==0&&e==0)return;const r=this.data,i=r.rotateMode==Tt.Tangent,d=r.rotateMode==Tt.ChainScale,l=this.bones,s=l.length,o=i?s:s+1,h=B.setArraySize(this.spaces,o),c=d?this.lengths=B.setArraySize(this.lengths,s):[],u=this.spacing;switch(r.spacingMode){case K.Percent:if(d)for(let w=0,p=o-1;w<p;w++){const S=l[w],A=S.data.length;if(A<pt.epsilon)c[w]=0;else{const C=A*S.matrix.a,v=A*S.matrix.b;c[w]=Math.sqrt(C*C+v*v)}}B.arrayFill(h,1,o,u);break;case K.Proportional:let g=0;for(let w=0,p=o-1;w<p;){const S=l[w],A=S.data.length;if(A<pt.epsilon)d&&(c[w]=0),h[++w]=u;else{const C=A*S.matrix.a,v=A*S.matrix.b,F=Math.sqrt(C*C+v*v);d&&(c[w]=F),h[++w]=F,g+=F}}if(g>0){g=o/g*u;for(let w=1;w<o;w++)h[w]*=g}break;default:const y=r.spacingMode==K.Length;for(let w=0,p=o-1;w<p;){const S=l[w],A=S.data.length;if(A<pt.epsilon)d&&(c[w]=0),h[++w]=u;else{const C=A*S.matrix.a,v=A*S.matrix.b,F=Math.sqrt(C*C+v*v);d&&(c[w]=F),h[++w]=(y?A+u:u)*F/A}}}const m=this.computeWorldPositions(n,o,i);let f=m[0],x=m[1],b=r.offsetRotation,k=!1;if(b==0)k=r.rotateMode==Tt.Chain;else{k=!1;const g=this.target.bone.matrix;b*=g.a*g.d-g.b*g.c>0?M.degRad:-M.degRad}for(let g=0,y=3;g<s;g++,y+=3){const w=l[g],p=w.matrix;p.tx+=(f-p.tx)*a,p.ty+=(x-p.ty)*e;const S=m[y],A=m[y+1],C=S-f,v=A-x;if(d){const F=c[g];if(F!=0){const X=(Math.sqrt(C*C+v*v)/F-1)*t+1;p.a*=X,p.b*=X}}if(f=S,x=A,t>0){const F=p.a,X=p.c,T=p.b,R=p.d;let E=0,O=0,V=0;if(i?E=m[y-1]:h[g+1]==0?E=m[y+2]:E=Math.atan2(v,C),E-=Math.atan2(T,F),k){O=Math.cos(E),V=Math.sin(E);const D=w.data.length;f+=(D*(O*F-V*T)-C)*t,x+=(D*(V*F+O*T)-v)*t}else E+=b;E>M.PI?E-=M.PI2:E<-M.PI&&(E+=M.PI2),E*=t,O=Math.cos(E),V=Math.sin(E),p.a=O*F-V*T,p.c=O*X-V*R,p.b=V*F+O*T,p.d=V*X+O*R}w.updateAppliedTransform()}}computeWorldPositions(n,t,a){const e=this.target;let r=this.position;const i=this.spaces,d=B.setArraySize(this.positions,t*3+2);let l=this.world;const s=n.closed;let o=n.worldVerticesLength,h=o/6,c=pt.NONE;if(!n.constantSpeed){const D=n.lengths;h-=s?1:2;const $=D[h];this.data.positionMode==bt.Percent&&(r*=$);let H;switch(this.data.spacingMode){case K.Percent:H=$;break;case K.Proportional:H=$/t;break;default:H=1}l=B.setArraySize(this.world,8);for(let j=0,J=0,P=0;j<t;j++,J+=3){const q=i[j]*H;r+=q;let _=r;if(s)_%=$,_<0&&(_+=$),P=0;else if(_<0){c!=pt.BEFORE&&(c=pt.BEFORE,n.computeWorldVertices(e,2,4,l,0,2)),this.addBeforePosition(_,l,0,d,J);continue}else if(_>$){c!=pt.AFTER&&(c=pt.AFTER,n.computeWorldVertices(e,o-6,4,l,0,2)),this.addAfterPosition(_-$,l,0,d,J);continue}for(;;P++){const tt=D[P];if(!(_>tt)){if(P==0)_/=tt;else{const at=D[P-1];_=(_-at)/(tt-at)}break}}P!=c&&(c=P,s&&P==h?(n.computeWorldVertices(e,o-4,4,l,0,2),n.computeWorldVertices(e,0,4,l,4,2)):n.computeWorldVertices(e,P*6+2,8,l,0,2)),this.addCurvePosition(_,l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],d,J,a||j>0&&q==0)}return d}s?(o+=2,l=B.setArraySize(this.world,o),n.computeWorldVertices(e,2,o-4,l,0,2),n.computeWorldVertices(e,0,2,l,o-4,2),l[o-2]=l[0],l[o-1]=l[1]):(h--,o-=4,l=B.setArraySize(this.world,o),n.computeWorldVertices(e,2,o,l,0,2));const u=B.setArraySize(this.curves,h);let m=0,f=l[0],x=l[1],b=0,k=0,g=0,y=0,w=0,p=0,S=0,A=0,C=0,v=0,F=0,X=0,T=0,R=0;for(let D=0,$=2;D<h;D++,$+=6)b=l[$],k=l[$+1],g=l[$+2],y=l[$+3],w=l[$+4],p=l[$+5],S=(f-b*2+g)*.1875,A=(x-k*2+y)*.1875,C=((b-g)*3-f+w)*.09375,v=((k-y)*3-x+p)*.09375,F=S*2+C,X=A*2+v,T=(b-f)*.75+S+C*.16666667,R=(k-x)*.75+A+v*.16666667,m+=Math.sqrt(T*T+R*R),T+=F,R+=X,F+=C,X+=v,m+=Math.sqrt(T*T+R*R),T+=F,R+=X,m+=Math.sqrt(T*T+R*R),T+=F+C,R+=X+v,m+=Math.sqrt(T*T+R*R),u[D]=m,f=w,x=p;this.data.positionMode==bt.Percent&&(r*=m);let E;switch(this.data.spacingMode){case K.Percent:E=m;break;case K.Proportional:E=m/t;break;default:E=1}const O=this.segments;let V=0;for(let D=0,$=0,H=0,j=0;D<t;D++,$+=3){const J=i[D]*E;r+=J;let P=r;if(s)P%=m,P<0&&(P+=m),H=0;else if(P<0){this.addBeforePosition(P,l,0,d,$);continue}else if(P>m){this.addAfterPosition(P-m,l,o-4,d,$);continue}for(;;H++){const q=u[H];if(!(P>q)){if(H==0)P/=q;else{const _=u[H-1];P=(P-_)/(q-_)}break}}if(H!=c){c=H;let q=H*6;for(f=l[q],x=l[q+1],b=l[q+2],k=l[q+3],g=l[q+4],y=l[q+5],w=l[q+6],p=l[q+7],S=(f-b*2+g)*.03,A=(x-k*2+y)*.03,C=((b-g)*3-f+w)*.006,v=((k-y)*3-x+p)*.006,F=S*2+C,X=A*2+v,T=(b-f)*.3+S+C*.16666667,R=(k-x)*.3+A+v*.16666667,V=Math.sqrt(T*T+R*R),O[0]=V,q=1;q<8;q++)T+=F,R+=X,F+=C,X+=v,V+=Math.sqrt(T*T+R*R),O[q]=V;T+=F,R+=X,V+=Math.sqrt(T*T+R*R),O[8]=V,T+=F+C,R+=X+v,V+=Math.sqrt(T*T+R*R),O[9]=V,j=0}for(P*=V;;j++){const q=O[j];if(!(P>q)){if(j==0)P/=q;else{const _=O[j-1];P=j+(P-_)/(q-_)}break}}this.addCurvePosition(P*.1,f,x,b,k,g,y,w,p,d,$,a||D>0&&J==0)}return d}addBeforePosition(n,t,a,e,r){const i=t[a],d=t[a+1],l=t[a+2]-i,s=t[a+3]-d,o=Math.atan2(s,l);e[r]=i+n*Math.cos(o),e[r+1]=d+n*Math.sin(o),e[r+2]=o}addAfterPosition(n,t,a,e,r){const i=t[a+2],d=t[a+3],l=i-t[a],s=d-t[a+1],o=Math.atan2(s,l);e[r]=i+n*Math.cos(o),e[r+1]=d+n*Math.sin(o),e[r+2]=o}addCurvePosition(n,t,a,e,r,i,d,l,s,o,h,c){if(n==0||isNaN(n)){o[h]=t,o[h+1]=a,o[h+2]=Math.atan2(r-a,e-t);return}const u=n*n,m=u*n,f=1-n,x=f*f,b=x*f,k=f*n,g=k*3,y=f*g,w=g*n,p=t*b+e*y+i*w+l*m,S=a*b+r*y+d*w+s*m;o[h]=p,o[h+1]=S,c&&(n<.001?o[h+2]=Math.atan2(r-a,e-t):o[h+2]=Math.atan2(S-(a*x+r*k*2+d*u),p-(t*x+e*k*2+i*u)))}};let Ft=pt;Ft.NONE=-1,Ft.BEFORE=-2,Ft.AFTER=-3,Ft.epsilon=1e-5;class ts{constructor(t,a){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!a)throw new Error("bone cannot be null.");this.data=t,this.bone=a,this.color=new L,this.darkColor=t.darkColor?new L:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof rt)||!(this.attachment instanceof rt)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class es{constructor(t,a){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new Kt,this.active=!1,!t)throw new Error("data cannot be null.");if(!a)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let r=0;r<t.bones.length;r++){const i=a.findBone(t.bones[r].name);if(!i)throw new Error(`Couldn't find bone ${t.bones[r].name}.`);this.bones.push(i)}const e=a.findBone(t.target.name);if(!e)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=e}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,a=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,d=this.mixShearY,l=a!=0||e!=0,s=this.target,o=s.matrix,h=o.a,c=o.c,u=o.b,m=o.d,f=h*m-c*u>0?M.degRad:-M.degRad,x=this.data.offsetRotation*f,b=this.data.offsetShearY*f,k=this.bones;for(let g=0,y=k.length;g<y;g++){const w=k[g],p=w.matrix;if(t!=0){const S=p.a,A=p.c,C=p.b,v=p.d;let F=Math.atan2(u,h)-Math.atan2(C,S)+x;F>M.PI?F-=M.PI2:F<-M.PI&&(F+=M.PI2),F*=t;const X=Math.cos(F),T=Math.sin(F);p.a=X*S-T*C,p.c=X*A-T*v,p.b=T*S+X*C,p.d=T*A+X*v}if(l){const S=this.temp;s.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),p.tx+=(S.x-p.tx)*a,p.ty+=(S.y-p.ty)*e}if(r!=0){let S=Math.sqrt(p.a*p.a+p.b*p.b);S!=0&&(S=(S+(Math.sqrt(h*h+u*u)-S+this.data.offsetScaleX)*r)/S),p.a*=S,p.b*=S}if(i!=0){let S=Math.sqrt(p.c*p.c+p.d*p.d);S!=0&&(S=(S+(Math.sqrt(c*c+m*m)-S+this.data.offsetScaleY)*i)/S),p.c*=S,p.d*=S}if(d>0){const S=p.c,A=p.d,C=Math.atan2(A,S);let v=Math.atan2(m,c)-Math.atan2(u,h)-(C-Math.atan2(p.b,p.a));v>M.PI?v-=M.PI2:v<-M.PI&&(v+=M.PI2),v=C+(v+b)*d;const F=Math.sqrt(S*S+A*A);p.c=Math.cos(v)*F,p.d=Math.sin(v)*F}w.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,a=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,d=this.mixShearY,l=a!=0||e!=0,s=this.target,o=s.matrix,h=o.a,c=o.c,u=o.b,m=o.d,f=h*m-c*u>0?M.degRad:-M.degRad,x=this.data.offsetRotation*f,b=this.data.offsetShearY*f,k=this.bones;for(let g=0,y=k.length;g<y;g++){const w=k[g],p=w.matrix;if(t!=0){const S=p.a,A=p.c,C=p.b,v=p.d;let F=Math.atan2(u,h)+x;F>M.PI?F-=M.PI2:F<-M.PI&&(F+=M.PI2),F*=t;const X=Math.cos(F),T=Math.sin(F);p.a=X*S-T*C,p.c=X*A-T*v,p.b=T*S+X*C,p.d=T*A+X*v}if(l){const S=this.temp;s.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),p.tx+=S.x*a,p.ty+=S.y*e}if(r!=0){const S=(Math.sqrt(h*h+u*u)-1+this.data.offsetScaleX)*r+1;p.a*=S,p.b*=S}if(i!=0){const S=(Math.sqrt(c*c+m*m)-1+this.data.offsetScaleY)*i+1;p.c*=S,p.d*=S}if(d>0){let S=Math.atan2(m,c)-Math.atan2(u,h);S>M.PI?S-=M.PI2:S<-M.PI&&(S+=M.PI2);const A=p.c,C=p.d;S=Math.atan2(C,A)+(S-M.PI/2+b)*d;const v=Math.sqrt(A*A+C*C);p.c=Math.cos(S)*v,p.d=Math.sin(S)*v}w.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,a=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,d=this.mixShearY,l=this.target,s=this.bones;for(let o=0,h=s.length;o<h;o++){const c=s[o];let u=c.arotation;if(t!=0){let g=l.arotation-u+this.data.offsetRotation;g-=(16384-(16384.499999999996-g/360|0))*360,u+=g*t}let m=c.ax,f=c.ay;m+=(l.ax-m+this.data.offsetX)*a,f+=(l.ay-f+this.data.offsetY)*e;let x=c.ascaleX,b=c.ascaleY;r!=0&&x!=0&&(x=(x+(l.ascaleX-x+this.data.offsetScaleX)*r)/x),i!=0&&b!=0&&(b=(b+(l.ascaleY-b+this.data.offsetScaleY)*i)/b);let k=c.ashearY;if(d!=0){let g=l.ashearY-k+this.data.offsetShearY;g-=(16384-(16384.499999999996-g/360|0))*360,k+=g*d}c.updateWorldTransformWith(m,f,u,x,b,c.ashearX,k)}}applyRelativeLocal(){const t=this.mixRotate,a=this.mixX,e=this.mixY,r=this.mixScaleX,i=this.mixScaleY,d=this.mixShearY,l=this.target,s=this.bones;for(let o=0,h=s.length;o<h;o++){const c=s[o],u=c.arotation+(l.arotation+this.data.offsetRotation)*t,m=c.ax+(l.ax+this.data.offsetX)*a,f=c.ay+(l.ay+this.data.offsetY)*e,x=c.ascaleX*((l.ascaleX-1+this.data.offsetScaleX)*r+1),b=c.ascaleY*((l.ascaleY-1+this.data.offsetScaleY)*i+1),k=c.ashearY+(l.ashearY+this.data.offsetShearY)*d;c.updateWorldTransformWith(m,f,u,x,b,c.ashearX,k)}}}const Rt=class{constructor(n){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!n)throw new Error("data cannot be null.");this.data=n,this.bones=new Array;for(let t=0;t<n.bones.length;t++){const a=n.bones[t];let e;if(!a.parent)e=new ye(a,this,null);else{const r=this.bones[a.parent.index];e=new ye(a,this,r),r.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<n.slots.length;t++){const a=n.slots[t],e=this.bones[a.boneData.index],r=new ts(a,e);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<n.ikConstraints.length;t++){const a=n.ikConstraints[t];this.ikConstraints.push(new Ze(a,this))}this.transformConstraints=new Array;for(let t=0;t<n.transformConstraints.length;t++){const a=n.transformConstraints[t];this.transformConstraints.push(new es(a,this))}this.pathConstraints=new Array;for(let t=0;t<n.pathConstraints.length;t++){const a=n.pathConstraints[t];this.pathConstraints.push(new Ft(a,this))}this.color=new L(1,1,1,1),this.updateCache()}updateCache(){const n=this._updateCache;n.length=0;const t=this.bones;for(let o=0,h=t.length;o<h;o++){const c=t[o];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){const o=this.skin.bones;for(let h=0,c=this.skin.bones.length;h<c;h++){let u=this.bones[o[h].index];do u.sorted=!1,u.active=!0,u=u.parent;while(u)}}const a=this.ikConstraints,e=this.transformConstraints,r=this.pathConstraints,i=a.length,d=e.length,l=r.length,s=i+d+l;t:for(let o=0;o<s;o++){for(let h=0;h<i;h++){const c=a[h];if(c.data.order==o){this.sortIkConstraint(c);continue t}}for(let h=0;h<d;h++){const c=e[h];if(c.data.order==o){this.sortTransformConstraint(c);continue t}}for(let h=0;h<l;h++){const c=r[h];if(c.data.order==o){this.sortPathConstraint(c);continue t}}}for(let o=0,h=t.length;o<h;o++)this.sortBone(t[o])}sortIkConstraint(n){if(n.active=n.target.isActive()&&(!n.data.skinRequired||this.skin&&B.contains(this.skin.constraints,n.data,!0)),!n.active)return;const t=n.target;this.sortBone(t);const a=n.bones,e=a[0];if(this.sortBone(e),a.length==1)this._updateCache.push(n),this.sortReset(e.children);else{const r=a[a.length-1];this.sortBone(r),this._updateCache.push(n),this.sortReset(e.children),r.sorted=!0}}sortPathConstraint(n){if(n.active=n.target.bone.isActive()&&(!n.data.skinRequired||this.skin&&B.contains(this.skin.constraints,n.data,!0)),!n.active)return;const t=n.target,a=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,a,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,a,e);for(let l=0,s=this.data.skins.length;l<s;l++)this.sortPathConstraintAttachment(this.data.skins[l],a,e);const r=t.getAttachment();r instanceof St&&this.sortPathConstraintAttachmentWith(r,e);const i=n.bones,d=i.length;for(let l=0;l<d;l++)this.sortBone(i[l]);this._updateCache.push(n);for(let l=0;l<d;l++)this.sortReset(i[l].children);for(let l=0;l<d;l++)i[l].sorted=!0}sortTransformConstraint(n){if(n.active=n.target.isActive()&&(!n.data.skinRequired||this.skin&&B.contains(this.skin.constraints,n.data,!0)),!n.active)return;this.sortBone(n.target);const t=n.bones,a=t.length;if(n.data.local)for(let e=0;e<a;e++){const r=t[e];this.sortBone(r.parent),this.sortBone(r)}else for(let e=0;e<a;e++)this.sortBone(t[e]);this._updateCache.push(n);for(let e=0;e<a;e++)this.sortReset(t[e].children);for(let e=0;e<a;e++)t[e].sorted=!0}sortPathConstraintAttachment(n,t,a){const e=n.attachments[t];if(e)for(const r in e)this.sortPathConstraintAttachmentWith(e[r],a)}sortPathConstraintAttachmentWith(n,t){if(!(n instanceof St))return;const a=n.bones;if(!a)this.sortBone(t);else{const e=this.bones;for(let r=0,i=a.length;r<i;){let d=a[r++];for(d+=r;r<d;)this.sortBone(e[a[r++]])}}}sortBone(n){if(!n||n.sorted)return;const t=n.parent;t&&this.sortBone(t),n.sorted=!0,this._updateCache.push(n)}sortReset(n){for(let t=0,a=n.length;t<a;t++){const e=n[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const n=this.bones;for(let a=0,e=n.length;a<e;a++){const r=n[a];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const t=this._updateCache;for(let a=0,e=t.length;a<e;a++)t[a].update()}updateWorldTransformWith(n){const t=this.getRootBone(),a=n.matrix.a,e=n.matrix.c,r=n.matrix.b,i=n.matrix.d;t.matrix.tx=a*this.x+e*this.y+n.worldX,t.matrix.ty=r*this.x+i*this.y+n.worldY;const d=t.rotation+90+t.shearY,l=M.cosDeg(t.rotation+t.shearX)*t.scaleX,s=M.cosDeg(d)*t.scaleY,o=M.sinDeg(t.rotation+t.shearX)*t.scaleX,h=M.sinDeg(d)*t.scaleY,c=this.scaleX,u=Xt.yDown?-this.scaleY:this.scaleY;t.matrix.a=(a*l+e*o)*c,t.matrix.c=(a*s+e*h)*c,t.matrix.b=(r*l+i*o)*u,t.matrix.d=(r*s+i*h)*u;const m=this._updateCache;for(let f=0,x=m.length;f<x;f++){const b=m[f];b!=t&&b.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const n=this.bones;for(let r=0,i=n.length;r<i;r++)n[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,i=t.length;r<i;r++){const d=t[r];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const a=this.transformConstraints;for(let r=0,i=a.length;r<i;r++){const d=a[r],l=d.data;d.mixRotate=l.mixRotate,d.mixX=l.mixX,d.mixY=l.mixY,d.mixScaleX=l.mixScaleX,d.mixScaleY=l.mixScaleY,d.mixShearY=l.mixShearY}const e=this.pathConstraints;for(let r=0,i=e.length;r<i;r++){const d=e[r],l=d.data;d.position=l.position,d.spacing=l.spacing,d.mixRotate=l.mixRotate,d.mixX=l.mixX,d.mixY=l.mixY}}setSlotsToSetupPose(){const n=this.slots;B.arrayCopy(n,0,this.drawOrder,0,n.length);for(let t=0,a=n.length;t<a;t++)n[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(n){if(!n)throw new Error("boneName cannot be null.");const t=this.bones;for(let a=0,e=t.length;a<e;a++){const r=t[a];if(r.data.name==n)return r}return null}findBoneIndex(n){if(!n)throw new Error("boneName cannot be null.");const t=this.bones;for(let a=0,e=t.length;a<e;a++)if(t[a].data.name==n)return a;return-1}findSlot(n){if(!n)throw new Error("slotName cannot be null.");const t=this.slots;for(let a=0,e=t.length;a<e;a++){const r=t[a];if(r.data.name==n)return r}return null}findSlotIndex(n){if(!n)throw new Error("slotName cannot be null.");const t=this.slots;for(let a=0,e=t.length;a<e;a++)if(t[a].data.name==n)return a;return-1}setSkinByName(n){const t=this.data.findSkin(n);if(!t)throw new Error(`Skin not found: ${n}`);this.setSkin(t)}setSkin(n){if(n!=this.skin){if(n)if(this.skin)n.attachAll(this,this.skin);else{const t=this.slots;for(let a=0,e=t.length;a<e;a++){const r=t[a],i=r.data.attachmentName;if(i){const d=n.getAttachment(a,i);d&&r.setAttachment(d)}}}this.skin=n,this.updateCache()}}getAttachmentByName(n,t){const a=this.data.findSlot(n);if(!a)throw new Error(`Can't find slot with name ${n}`);return this.getAttachment(a.index,t)}getAttachment(n,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const a=this.skin.getAttachment(n,t);if(a)return a}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(n,t):null}setAttachment(n,t){if(!n)throw new Error("slotName cannot be null.");const a=this.slots;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.data.name==n){let d=null;if(t&&(d=this.getAttachment(e,t),!d))throw new Error(`Attachment not found: ${t}, for slot: ${n}`);i.setAttachment(d);return}}throw new Error(`Slot not found: ${n}`)}findIkConstraint(n){if(!n)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let a=0,e=t.length;a<e;a++){const r=t[a];if(r.data.name==n)return r}return null}findTransformConstraint(n){if(!n)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let a=0,e=t.length;a<e;a++){const r=t[a];if(r.data.name==n)return r}return null}findPathConstraint(n){if(!n)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let a=0,e=t.length;a<e;a++){const r=t[a];if(r.data.name==n)return r}return null}getBoundsRect(){const n=new Kt,t=new Kt;return this.getBounds(n,t),{x:n.x,y:n.y,width:t.x,height:t.y}}getBounds(n,t,a=new Array(2)){if(!n)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let r=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let s=0,o=e.length;s<o;s++){const h=e[s];if(!h.bone.active)continue;let c=0,u=null;const m=h.getAttachment();if(m instanceof N)c=8,u=B.setArraySize(a,c,0),m.computeWorldVertices(h,u,0,2);else if(m instanceof At){const f=m;c=f.worldVerticesLength,u=B.setArraySize(a,c,0),f.computeWorldVertices(h,0,c,u,0,2)}if(u)for(let f=0,x=u.length;f<x;f+=2){const b=u[f],k=u[f+1];r=Math.min(r,b),i=Math.min(i,k),d=Math.max(d,b),l=Math.max(l,k)}}n.set(r,i),t.set(d-r,l-i)}get flipX(){return this.scaleX==-1}set flipX(n){Rt.deprecatedWarning1||(Rt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=n?1:-1}get flipY(){return this.scaleY==-1}set flipY(n){Rt.deprecatedWarning1||(Rt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=n?1:-1}};let Ce=Rt;Ce.deprecatedWarning1=!1;class Fe{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const a=this.bones;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const a=this.bones;for(let e=0,r=a.length;e<r;e++)if(a[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const a=this.slots;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const a=this.slots;for(let e=0,r=a.length;e<r;e++)if(a[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const a=this.skins;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const a=this.events;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const a=this.animations;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const a=this.ikConstraints;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const a=this.transformConstraints;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const a=this.pathConstraints;for(let e=0,r=a.length;e<r;e++){const i=a[e];if(i.name==t)return i}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const a=this.pathConstraints;for(let e=0,r=a.length;e<r;e++)if(a[e].name==t)return e;return-1}}class Me{constructor(t,a,e){if(this.index=0,this.color=new L(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode="normal",t<0)throw new Error("index must be >= 0.");if(!a)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=a,this.boneData=e}}class Xe extends Ut{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Te{constructor(t,a,e){this.slotIndex=t,this.name=a,this.attachment=e}}class Ot{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,a,e){if(!e)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][a]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){i=!0;break}i||this.constraints.push(r)}const a=t.getAttachments();for(let e=0;e<a.length;e++){const r=a[e];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let i=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){i=!0;break}i||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let i=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){i=!0;break}i||this.constraints.push(r)}const a=t.getAttachments();for(let e=0;e<a.length;e++){const r=a[e];r.attachment&&(r.attachment instanceof At?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,a){const e=this.attachments[t];return e?e[a]:null}removeAttachment(t,a){const e=this.attachments[t];e&&delete e[a]}getAttachments(){const t=new Array;for(let a=0;a<this.attachments.length;a++){const e=this.attachments[a];if(e)for(const r in e){const i=e[r];i&&t.push(new Te(a,r,i))}}return t}getAttachmentsForSlot(t,a){const e=this.attachments[t];if(e)for(const r in e){const i=e[r];i&&a.push(new Te(t,r,i))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,a){let e=0;for(let r=0;r<t.slots.length;r++){const i=t.slots[r],d=i.getAttachment();if(d&&e<a.attachments.length){const l=a.attachments[e];for(const s in l){const o=l[s];if(d==o){const h=this.getAttachment(e,s);h&&i.setAttachment(h);break}}}e++}}}const ss=class{constructor(n){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=n}readSkeletonData(n){const t=this.scale,a=new Fe;a.name="";const e=new is(n),r=e.readInt32(),i=e.readInt32();a.hash=i==0&&r==0?null:i.toString(16)+r.toString(16),a.version=e.readString();const d=a.version.substr(0,3);if(d!=="4.0"&&d!=="4.1"){const h=`Spine 4.1 loader cant load version ${a.version}. Please configure your pixi-spine bundle`;console.error(h)}this.ver40=d==="4.0",a.x=e.readFloat(),a.y=e.readFloat(),a.width=e.readFloat(),a.height=e.readFloat();const l=e.readBoolean();l&&(a.fps=e.readFloat(),a.imagesPath=e.readString(),a.audioPath=e.readString());let s=0;s=e.readInt(!0);for(let h=0;h<s;h++){const c=e.readString();if(!c)throw new Error("String in string table must not be null.");e.strings.push(c)}s=e.readInt(!0);for(let h=0;h<s;h++){const c=e.readString();if(!c)throw new Error("Bone name must not be null.");const u=h==0?null:a.bones[e.readInt(!0)],m=new Se(h,c,u);m.rotation=e.readFloat(),m.x=e.readFloat()*t,m.y=e.readFloat()*t,m.scaleX=e.readFloat(),m.scaleY=e.readFloat(),m.shearX=e.readFloat(),m.shearY=e.readFloat(),m.length=e.readFloat()*t,m.transformMode=e.readInt(!0),m.skinRequired=e.readBoolean(),l&&L.rgba8888ToColor(m.color,e.readInt32()),a.bones.push(m)}s=e.readInt(!0);for(let h=0;h<s;h++){const c=e.readString();if(!c)throw new Error("Slot name must not be null.");const u=a.bones[e.readInt(!0)],m=new Me(h,c,u);L.rgba8888ToColor(m.color,e.readInt32());const f=e.readInt32();f!=-1&&L.rgb888ToColor(m.darkColor=new L,f),m.attachmentName=e.readStringRef(),m.blendMode=ss.blendModeFromNumber(e.readInt(!0)),a.slots.push(m)}s=e.readInt(!0);for(let h=0,c;h<s;h++){const u=e.readString();if(!u)throw new Error("IK constraint data name must not be null.");const m=new Ye(u);m.order=e.readInt(!0),m.skinRequired=e.readBoolean(),c=e.readInt(!0);for(let f=0;f<c;f++)m.bones.push(a.bones[e.readInt(!0)]);m.target=a.bones[e.readInt(!0)],m.mix=e.readFloat(),m.softness=e.readFloat()*t,m.bendDirection=e.readByte(),m.compress=e.readBoolean(),m.stretch=e.readBoolean(),m.uniform=e.readBoolean(),a.ikConstraints.push(m)}s=e.readInt(!0);for(let h=0,c;h<s;h++){const u=e.readString();if(!u)throw new Error("Transform constraint data name must not be null.");const m=new Xe(u);m.order=e.readInt(!0),m.skinRequired=e.readBoolean(),c=e.readInt(!0);for(let f=0;f<c;f++)m.bones.push(a.bones[e.readInt(!0)]);m.target=a.bones[e.readInt(!0)],m.local=e.readBoolean(),m.relative=e.readBoolean(),m.offsetRotation=e.readFloat(),m.offsetX=e.readFloat()*t,m.offsetY=e.readFloat()*t,m.offsetScaleX=e.readFloat(),m.offsetScaleY=e.readFloat(),m.offsetShearY=e.readFloat(),m.mixRotate=e.readFloat(),m.mixX=e.readFloat(),m.mixY=e.readFloat(),m.mixScaleX=e.readFloat(),m.mixScaleY=e.readFloat(),m.mixShearY=e.readFloat(),a.transformConstraints.push(m)}s=e.readInt(!0);for(let h=0,c;h<s;h++){const u=e.readString();if(!u)throw new Error("Path constraint data name must not be null.");const m=new ve(u);m.order=e.readInt(!0),m.skinRequired=e.readBoolean(),c=e.readInt(!0);for(let f=0;f<c;f++)m.bones.push(a.bones[e.readInt(!0)]);m.target=a.slots[e.readInt(!0)],m.positionMode=e.readInt(!0),m.spacingMode=e.readInt(!0),m.rotateMode=e.readInt(!0),m.offsetRotation=e.readFloat(),m.position=e.readFloat(),m.positionMode==bt.Fixed&&(m.position*=t),m.spacing=e.readFloat(),(m.spacingMode==K.Length||m.spacingMode==K.Fixed)&&(m.spacing*=t),m.mixRotate=e.readFloat(),m.mixX=e.readFloat(),m.mixY=e.readFloat(),a.pathConstraints.push(m)}const o=this.readSkin(e,a,!0,l);o&&(a.defaultSkin=o,a.skins.push(o));{let h=a.skins.length;for(B.setArraySize(a.skins,s=h+e.readInt(!0));h<s;h++){const c=this.readSkin(e,a,!1,l);if(!c)throw new Error("readSkin() should not have returned null.");a.skins[h]=c}}s=this.linkedMeshes.length;for(let h=0;h<s;h++){const c=this.linkedMeshes[h],u=c.skin?a.findSkin(c.skin):a.defaultSkin;if(!u)throw new Error("Not skin found for linked mesh.");if(!c.parent)throw new Error("Linked mesh parent must not be null");const m=u.getAttachment(c.slotIndex,c.parent);if(!m)throw new Error(`Parent mesh not found: ${c.parent}`);c.mesh.timelineAttachment=c.inheritTimeline?m:c.mesh,c.mesh.setParentMesh(m)}this.linkedMeshes.length=0,s=e.readInt(!0);for(let h=0;h<s;h++){const c=e.readStringRef();if(!c)throw new Error;const u=new Ie(c);u.intValue=e.readInt(!1),u.floatValue=e.readFloat(),u.stringValue=e.readString(),u.audioPath=e.readString(),u.audioPath&&(u.volume=e.readFloat(),u.balance=e.readFloat()),a.events.push(u)}s=e.readInt(!0);for(let h=0;h<s;h++){const c=e.readString();if(!c)throw new Error("Animatio name must not be null.");a.animations.push(this.readAnimation(e,c,a))}return a}readSkin(n,t,a,e){let r=null,i=0;if(a){if(i=n.readInt(!0),i==0)return null;r=new Ot("default")}else{const d=n.readStringRef();if(!d)throw new Error("Skin name must not be null.");r=new Ot(d),r.bones.length=n.readInt(!0);for(let l=0,s=r.bones.length;l<s;l++)r.bones[l]=t.bones[n.readInt(!0)];for(let l=0,s=n.readInt(!0);l<s;l++)r.constraints.push(t.ikConstraints[n.readInt(!0)]);for(let l=0,s=n.readInt(!0);l<s;l++)r.constraints.push(t.transformConstraints[n.readInt(!0)]);for(let l=0,s=n.readInt(!0);l<s;l++)r.constraints.push(t.pathConstraints[n.readInt(!0)]);i=n.readInt(!0)}for(let d=0;d<i;d++){const l=n.readInt(!0);for(let s=0,o=n.readInt(!0);s<o;s++){const h=n.readStringRef();if(!h)throw new Error("Attachment name must not be null");const c=this.readAttachment(n,t,r,l,h,e);c&&r.setAttachment(l,h,c)}}return r}readAttachment(n,t,a,e,r,i){const d=this.scale;let l=n.readStringRef();switch(l||(l=r),n.readByte()){case et.Region:{let s=n.readStringRef();const o=n.readFloat(),h=n.readFloat(),c=n.readFloat(),u=n.readFloat(),m=n.readFloat(),f=n.readFloat(),x=n.readFloat(),b=n.readInt32(),k=this.readSequence(n);s||(s=l);const g=this.attachmentLoader.newRegionAttachment(a,l,s,k);return g?(g.path=s,g.x=h*d,g.y=c*d,g.scaleX=u,g.scaleY=m,g.rotation=o,g.width=f*d,g.height=x*d,L.rgba8888ToColor(g.color,b),g.sequence=k,k==null&&g.updateRegion(),g):null}case et.BoundingBox:{const s=n.readInt(!0),o=this.readVertices(n,s),h=i?n.readInt32():0,c=this.attachmentLoader.newBoundingBoxAttachment(a,l);return c?(c.worldVerticesLength=s<<1,c.vertices=o.vertices,c.bones=o.bones,i&&L.rgba8888ToColor(c.color,h),c):null}case et.Mesh:{let s=n.readStringRef();const o=n.readInt32(),h=n.readInt(!0),c=this.readFloatArray(n,h<<1,1),u=this.readShortArray(n),m=this.readVertices(n,h),f=n.readInt(!0),x=this.readSequence(n);let b=[],k=0,g=0;i&&(b=this.readShortArray(n),k=n.readFloat(),g=n.readFloat()),s||(s=l);const y=this.attachmentLoader.newMeshAttachment(a,l,s,x);return y?(y.path=s,L.rgba8888ToColor(y.color,o),y.bones=m.bones,y.vertices=m.vertices,y.worldVerticesLength=h<<1,y.triangles=u,y.regionUVs=new Float32Array(c),y.hullLength=f<<1,y.sequence=x,i&&(y.edges=b,y.width=k*d,y.height=g*d),y):null}case et.LinkedMesh:{let s=n.readStringRef();const o=n.readInt32(),h=n.readStringRef(),c=n.readStringRef(),u=n.readBoolean(),m=this.readSequence(n);let f=0,x=0;i&&(f=n.readFloat(),x=n.readFloat()),s||(s=l);const b=this.attachmentLoader.newMeshAttachment(a,l,s,m);return b?(b.path=s,L.rgba8888ToColor(b.color,o),b.sequence=m,i&&(b.width=f*d,b.height=x*d),this.linkedMeshes.push(new fs(b,h,e,c,u)),b):null}case et.Path:{const s=n.readBoolean(),o=n.readBoolean(),h=n.readInt(!0),c=this.readVertices(n,h),u=B.newArray(h/3,0);for(let x=0,b=u.length;x<b;x++)u[x]=n.readFloat()*d;const m=i?n.readInt32():0,f=this.attachmentLoader.newPathAttachment(a,l);return f?(f.closed=s,f.constantSpeed=o,f.worldVerticesLength=h<<1,f.vertices=c.vertices,f.bones=c.bones,f.lengths=u,i&&L.rgba8888ToColor(f.color,m),f):null}case et.Point:{const s=n.readFloat(),o=n.readFloat(),h=n.readFloat(),c=i?n.readInt32():0,u=this.attachmentLoader.newPointAttachment(a,l);return u?(u.x=o*d,u.y=h*d,u.rotation=s,i&&L.rgba8888ToColor(u.color,c),u):null}case et.Clipping:{const s=n.readInt(!0),o=n.readInt(!0),h=this.readVertices(n,o),c=i?n.readInt32():0,u=this.attachmentLoader.newClippingAttachment(a,l);return u?(u.endSlot=t.slots[s],u.worldVerticesLength=o<<1,u.vertices=h.vertices,u.bones=h.bones,i&&L.rgba8888ToColor(u.color,c),u):null}}return null}readSequence(n){if(this.ver40||!n.readBoolean())return null;const t=new qt(n.readInt(!0));return t.start=n.readInt(!0),t.digits=n.readInt(!0),t.setupIndex=n.readInt(!0),t}readDeformTimelineType(n){return this.ver40?as:n.readByte()}readVertices(n,t){const a=this.scale,e=t<<1,r=new gs;if(!n.readBoolean())return r.vertices=this.readFloatArray(n,e,a),r;const i=new Array,d=new Array;for(let l=0;l<t;l++){const s=n.readInt(!0);d.push(s);for(let o=0;o<s;o++)d.push(n.readInt(!0)),i.push(n.readFloat()*a),i.push(n.readFloat()*a),i.push(n.readFloat())}return r.vertices=B.toFloatArray(i),r.bones=d,r}readFloatArray(n,t,a){const e=new Array(t);if(a==1)for(let r=0;r<t;r++)e[r]=n.readFloat();else for(let r=0;r<t;r++)e[r]=n.readFloat()*a;return e}readShortArray(n){const t=n.readInt(!0),a=new Array(t);for(let e=0;e<t;e++)a[e]=n.readShort();return a}readAnimation(n,t,a){n.readInt(!0);const e=new Array,r=this.scale;for(let s=0,o=n.readInt(!0);s<o;s++){const h=n.readInt(!0);for(let c=0,u=n.readInt(!0);c<u;c++){const m=n.readByte(),f=n.readInt(!0),x=f-1;switch(m){case vs:{const b=new kt(f,h);for(let k=0;k<f;k++)b.setFrame(k,n.readFloat(),n.readStringRef());e.push(b);break}case Cs:{const b=n.readInt(!0),k=new he(f,b,h);let g=n.readFloat(),y=n.readUnsignedByte()/255,w=n.readUnsignedByte()/255,p=n.readUnsignedByte()/255,S=n.readUnsignedByte()/255;for(let A=0,C=0;k.setFrame(A,g,y,w,p,S),A!=x;A++){const v=n.readFloat(),F=n.readUnsignedByte()/255,X=n.readUnsignedByte()/255,T=n.readUnsignedByte()/255,R=n.readUnsignedByte()/255;switch(n.readByte()){case ht:k.setStepped(A);break;case lt:W(n,k,C++,A,0,g,v,y,F,1),W(n,k,C++,A,1,g,v,w,X,1),W(n,k,C++,A,2,g,v,p,T,1),W(n,k,C++,A,3,g,v,S,R,1)}g=v,y=F,w=X,p=T,S=R}e.push(k);break}case Fs:{const b=n.readInt(!0),k=new le(f,b,h);let g=n.readFloat(),y=n.readUnsignedByte()/255,w=n.readUnsignedByte()/255,p=n.readUnsignedByte()/255;for(let S=0,A=0;k.setFrame(S,g,y,w,p),S!=x;S++){const C=n.readFloat(),v=n.readUnsignedByte()/255,F=n.readUnsignedByte()/255,X=n.readUnsignedByte()/255;switch(n.readByte()){case ht:k.setStepped(S);break;case lt:W(n,k,A++,S,0,g,C,y,v,1),W(n,k,A++,S,1,g,C,w,F,1),W(n,k,A++,S,2,g,C,p,X,1)}g=C,y=v,w=F,p=X}e.push(k);break}case Ms:{const b=n.readInt(!0),k=new de(f,b,h);let g=n.readFloat(),y=n.readUnsignedByte()/255,w=n.readUnsignedByte()/255,p=n.readUnsignedByte()/255,S=n.readUnsignedByte()/255,A=n.readUnsignedByte()/255,C=n.readUnsignedByte()/255,v=n.readUnsignedByte()/255;for(let F=0,X=0;k.setFrame(F,g,y,w,p,S,A,C,v),F!=x;F++){const T=n.readFloat(),R=n.readUnsignedByte()/255,E=n.readUnsignedByte()/255,O=n.readUnsignedByte()/255,V=n.readUnsignedByte()/255,D=n.readUnsignedByte()/255,$=n.readUnsignedByte()/255,H=n.readUnsignedByte()/255;switch(n.readByte()){case ht:k.setStepped(F);break;case lt:W(n,k,X++,F,0,g,T,y,R,1),W(n,k,X++,F,1,g,T,w,E,1),W(n,k,X++,F,2,g,T,p,O,1),W(n,k,X++,F,3,g,T,S,V,1),W(n,k,X++,F,4,g,T,A,D,1),W(n,k,X++,F,5,g,T,C,$,1),W(n,k,X++,F,6,g,T,v,H,1)}g=T,y=R,w=E,p=O,S=V,A=D,C=$,v=H}e.push(k);break}case Xs:{const b=n.readInt(!0),k=new me(f,b,h);let g=n.readFloat(),y=n.readUnsignedByte()/255,w=n.readUnsignedByte()/255,p=n.readUnsignedByte()/255,S=n.readUnsignedByte()/255,A=n.readUnsignedByte()/255,C=n.readUnsignedByte()/255;for(let v=0,F=0;k.setFrame(v,g,y,w,p,S,A,C),v!=x;v++){const X=n.readFloat(),T=n.readUnsignedByte()/255,R=n.readUnsignedByte()/255,E=n.readUnsignedByte()/255,O=n.readUnsignedByte()/255,V=n.readUnsignedByte()/255,D=n.readUnsignedByte()/255;switch(n.readByte()){case ht:k.setStepped(v);break;case lt:W(n,k,F++,v,0,g,X,y,T,1),W(n,k,F++,v,1,g,X,w,R,1),W(n,k,F++,v,2,g,X,p,E,1),W(n,k,F++,v,3,g,X,S,O,1),W(n,k,F++,v,4,g,X,A,V,1),W(n,k,F++,v,5,g,X,C,D,1)}g=X,y=T,w=R,p=E,S=O,A=V,C=D}e.push(k);break}case Ts:{const b=new ce(f,n.readInt(!0),h);let k=n.readFloat(),g=n.readUnsignedByte()/255;for(let y=0,w=0;b.setFrame(y,k,g),y!=x;y++){const p=n.readFloat(),S=n.readUnsignedByte()/255;switch(n.readByte()){case ht:b.setStepped(y);break;case lt:W(n,b,w++,y,0,k,p,g,S,1)}k=p,g=S}e.push(b)}}}}for(let s=0,o=n.readInt(!0);s<o;s++){const h=n.readInt(!0);for(let c=0,u=n.readInt(!0);c<u;c++){const m=n.readByte(),f=n.readInt(!0),x=n.readInt(!0);switch(m){case ps:e.push(xt(n,new Bt(f,x,h),1));break;case xs:e.push(Be(n,new Zt(f,x,h),r));break;case bs:e.push(xt(n,new te(f,x,h),r));break;case ws:e.push(xt(n,new ee(f,x,h),r));break;case ks:e.push(Be(n,new se(f,x,h),1));break;case ys:e.push(xt(n,new ne(f,x,h),1));break;case Ss:e.push(xt(n,new ae(f,x,h),1));break;case As:e.push(Be(n,new re(f,x,h),1));break;case Is:e.push(xt(n,new ie(f,x,h),1));break;case Ys:e.push(xt(n,new oe(f,x,h),1))}}}for(let s=0,o=n.readInt(!0);s<o;s++){const h=n.readInt(!0),c=n.readInt(!0),u=c-1,m=new fe(c,n.readInt(!0),h);let f=n.readFloat(),x=n.readFloat(),b=n.readFloat()*r;for(let k=0,g=0;m.setFrame(k,f,x,b,n.readByte(),n.readBoolean(),n.readBoolean()),k!=u;k++){const y=n.readFloat(),w=n.readFloat(),p=n.readFloat()*r;switch(n.readByte()){case ht:m.setStepped(k);break;case lt:W(n,m,g++,k,0,f,y,x,w,1),W(n,m,g++,k,1,f,y,b,p,r)}f=y,x=w,b=p}e.push(m)}for(let s=0,o=n.readInt(!0);s<o;s++){const h=n.readInt(!0),c=n.readInt(!0),u=c-1,m=new ge(c,n.readInt(!0),h);let f=n.readFloat(),x=n.readFloat(),b=n.readFloat(),k=n.readFloat(),g=n.readFloat(),y=n.readFloat(),w=n.readFloat();for(let p=0,S=0;m.setFrame(p,f,x,b,k,g,y,w),p!=u;p++){const A=n.readFloat(),C=n.readFloat(),v=n.readFloat(),F=n.readFloat(),X=n.readFloat(),T=n.readFloat(),R=n.readFloat();switch(n.readByte()){case ht:m.setStepped(p);break;case lt:W(n,m,S++,p,0,f,A,x,C,1),W(n,m,S++,p,1,f,A,b,v,1),W(n,m,S++,p,2,f,A,k,F,1),W(n,m,S++,p,3,f,A,g,X,1),W(n,m,S++,p,4,f,A,y,T,1),W(n,m,S++,p,5,f,A,w,R,1)}f=A,x=C,b=v,k=F,g=X,y=T,w=R}e.push(m)}for(let s=0,o=n.readInt(!0);s<o;s++){const h=n.readInt(!0),c=a.pathConstraints[h];for(let u=0,m=n.readInt(!0);u<m;u++)switch(n.readByte()){case Es:e.push(xt(n,new pe(n.readInt(!0),n.readInt(!0),h),c.positionMode==bt.Fixed?r:1));break;case Rs:e.push(xt(n,new xe(n.readInt(!0),n.readInt(!0),h),c.spacingMode==K.Length||c.spacingMode==K.Fixed?r:1));break;case Ds:const f=new be(n.readInt(!0),n.readInt(!0),h);let x=n.readFloat(),b=n.readFloat(),k=n.readFloat(),g=n.readFloat();for(let y=0,w=0,p=f.getFrameCount()-1;f.setFrame(y,x,b,k,g),y!=p;y++){const S=n.readFloat(),A=n.readFloat(),C=n.readFloat(),v=n.readFloat();switch(n.readByte()){case ht:f.setStepped(y);break;case lt:W(n,f,w++,y,0,x,S,b,A,1),W(n,f,w++,y,1,x,S,k,C,1),W(n,f,w++,y,2,x,S,g,v,1)}x=S,b=A,k=C,g=v}e.push(f)}}for(let s=0,o=n.readInt(!0);s<o;s++){const h=a.skins[n.readInt(!0)];for(let c=0,u=n.readInt(!0);c<u;c++){const m=n.readInt(!0);for(let f=0,x=n.readInt(!0);f<x;f++){const b=n.readStringRef();if(!b)throw new Error("attachmentName must not be null.");const k=h.getAttachment(m,b),g=this.readDeformTimelineType(n),y=n.readInt(!0),w=y-1;switch(g){case as:{const p=k,S=p.bones,A=p.vertices,C=S?A.length/3*2:A.length,v=n.readInt(!0),F=new ue(y,v,m,p);let X=n.readFloat();for(let T=0,R=0;;T++){let E,O=n.readInt(!0);if(O==0)E=S?B.newFloatArray(C):A;else{E=B.newFloatArray(C);const D=n.readInt(!0);if(O+=D,r==1)for(let $=D;$<O;$++)E[$]=n.readFloat();else for(let $=D;$<O;$++)E[$]=n.readFloat()*r;if(!S)for(let $=0,H=E.length;$<H;$++)E[$]+=A[$]}if(F.setFrame(T,X,E),T==w)break;const V=n.readFloat();switch(n.readByte()){case ht:F.setStepped(T);break;case lt:W(n,F,R++,T,0,X,V,0,1,1)}X=V}e.push(F);break}case Bs:{const p=new vt(y,m,k);for(let S=0;S<y;S++){const A=n.readFloat(),C=n.readInt32();p.setFrame(S,A,Qt[C&15],C>>4,n.readFloat())}e.push(p);break}}}}}const i=n.readInt(!0);if(i>0){const s=new yt(i),o=a.slots.length;for(let h=0;h<i;h++){const c=n.readFloat(),u=n.readInt(!0),m=B.newArray(o,0);for(let k=o-1;k>=0;k--)m[k]=-1;const f=B.newArray(o-u,0);let x=0,b=0;for(let k=0;k<u;k++){const g=n.readInt(!0);for(;x!=g;)f[b++]=x++;m[x+n.readInt(!0)]=x++}for(;x<o;)f[b++]=x++;for(let k=o-1;k>=0;k--)m[k]==-1&&(m[k]=f[--b]);s.setFrame(h,c,m)}e.push(s)}const d=n.readInt(!0);if(d>0){const s=new Et(d);for(let o=0;o<d;o++){const h=n.readFloat(),c=a.events[n.readInt(!0)],u=new Ae(h,c);u.intValue=n.readInt(!1),u.floatValue=n.readFloat(),u.stringValue=n.readBoolean()?n.readString():c.stringValue,u.data.audioPath&&(u.volume=n.readFloat(),u.balance=n.readFloat()),s.setFrame(o,u)}e.push(s)}let l=0;for(let s=0,o=e.length;s<o;s++)l=Math.max(l,e[s].getDuration());return new Lt(t,e,l)}static blendModeFromNumber(n){if(n==0)return"normal";if(n==1)return"add";if(n==2)return"multiply";if(n==3)return"screen";throw new Error(`Unknown blend mode: ${n}`)}};let ns=ss;ns.BlendModeValues=["normal","add","multiply","screen"];class fs{constructor(t,a,e,r,i){this.mesh=t,this.skin=a,this.slotIndex=e,this.parent=r,this.inheritTimeline=i}}class gs{constructor(t=null,a=null){this.bones=t,this.vertices=a}}function xt(n,t,a){let e=n.readFloat(),r=n.readFloat()*a;for(let i=0,d=0,l=t.getFrameCount()-1;t.setFrame(i,e,r),i!=l;i++){const s=n.readFloat(),o=n.readFloat()*a;switch(n.readByte()){case ht:t.setStepped(i);break;case lt:W(n,t,d++,i,0,e,s,r,o,a)}e=s,r=o}return t}function Be(n,t,a){let e=n.readFloat(),r=n.readFloat()*a,i=n.readFloat()*a;for(let d=0,l=0,s=t.getFrameCount()-1;t.setFrame(d,e,r,i),d!=s;d++){const o=n.readFloat(),h=n.readFloat()*a,c=n.readFloat()*a;switch(n.readByte()){case ht:t.setStepped(d);break;case lt:W(n,t,l++,d,0,e,o,r,h,a),W(n,t,l++,d,1,e,o,i,c,a)}e=o,r=h,i=c}return t}function W(n,t,a,e,r,i,d,l,s,o){t.setBezier(a,e,r,i,l,n.readFloat(),n.readFloat()*o,n.readFloat(),n.readFloat()*o,d,s)}const ps=0,xs=1,bs=2,ws=3,ks=4,ys=5,Ss=6,As=7,Is=8,Ys=9,vs=0,Cs=1,Fs=2,Ms=3,Xs=4,Ts=5,as=0,Bs=1,Es=0,Rs=1,Ds=2,ht=1,lt=2;class Vs extends os{}class Re{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const a=this.scale,e=new Fe,r=typeof t=="string"?JSON.parse(t):t,i=r.skeleton;if(i){e.hash=i.hash,e.version=i.spine;const d=e.version.substr(0,3);if(d!=="4.0"&&d!=="4.1"){const l=`Spine 4.1 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;console.error(l)}e.x=i.x,e.y=i.y,e.width=i.width,e.height=i.height,e.fps=i.fps,e.imagesPath=i.images}if(r.bones)for(let d=0;d<r.bones.length;d++){const l=r.bones[d];let s=null;const o=I(l,"parent",null);if(o!=null&&(s=e.findBone(o),s==null))throw new Error(`Parent bone not found: ${o}`);const h=new Se(e.bones.length,l.name,s);h.length=I(l,"length",0)*a,h.x=I(l,"x",0)*a,h.y=I(l,"y",0)*a,h.rotation=I(l,"rotation",0),h.scaleX=I(l,"scaleX",1),h.scaleY=I(l,"scaleY",1),h.shearX=I(l,"shearX",0),h.shearY=I(l,"shearY",0),h.transformMode=B.enumValue(nt,I(l,"transform","Normal")),h.skinRequired=I(l,"skin",!1);const c=I(l,"color",null);c&&h.color.setFromString(c),e.bones.push(h)}if(r.slots)for(let d=0;d<r.slots.length;d++){const l=r.slots[d],s=e.findBone(l.bone);if(!s)throw new Error(`Couldn't find bone ${l.bone} for slot ${l.name}`);const o=new Me(e.slots.length,l.name,s),h=I(l,"color",null);h&&o.color.setFromString(h);const c=I(l,"dark",null);c&&(o.darkColor=L.fromString(c)),o.attachmentName=I(l,"attachment",null),o.blendMode=Re.blendModeFromString(I(l,"blend","normal")),e.slots.push(o)}if(r.ik)for(let d=0;d<r.ik.length;d++){const l=r.ik[d],s=new Ye(l.name);s.order=I(l,"order",0),s.skinRequired=I(l,"skin",!1);for(let o=0;o<l.bones.length;o++){const h=l.bones[o],c=e.findBone(h);if(c==null)throw new Error(`IK bone not found: ${h}`);s.bones.push(c)}s.target=e.findBone(l.target),s.mix=I(l,"mix",1),s.softness=I(l,"softness",0)*a,s.bendDirection=I(l,"bendPositive",!0)?1:-1,s.compress=I(l,"compress",!1),s.stretch=I(l,"stretch",!1),s.uniform=I(l,"uniform",!1),e.ikConstraints.push(s)}if(r.transform)for(let d=0;d<r.transform.length;d++){const l=r.transform[d],s=new Xe(l.name);s.order=I(l,"order",0),s.skinRequired=I(l,"skin",!1);for(let c=0;c<l.bones.length;c++){const u=l.bones[c],m=e.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for transform constraint ${l.name}.`);s.bones.push(m)}const o=l.target,h=e.findBone(o);if(!h)throw new Error(`Couldn't find target bone ${o} for transform constraint ${l.name}.`);s.target=h,s.local=I(l,"local",!1),s.relative=I(l,"relative",!1),s.offsetRotation=I(l,"rotation",0),s.offsetX=I(l,"x",0)*a,s.offsetY=I(l,"y",0)*a,s.offsetScaleX=I(l,"scaleX",0),s.offsetScaleY=I(l,"scaleY",0),s.offsetShearY=I(l,"shearY",0),s.mixRotate=I(l,"mixRotate",1),s.mixX=I(l,"mixX",1),s.mixY=I(l,"mixY",s.mixX),s.mixScaleX=I(l,"mixScaleX",1),s.mixScaleY=I(l,"mixScaleY",s.mixScaleX),s.mixShearY=I(l,"mixShearY",1),e.transformConstraints.push(s)}if(r.path)for(let d=0;d<r.path.length;d++){const l=r.path[d],s=new ve(l.name);s.order=I(l,"order",0),s.skinRequired=I(l,"skin",!1);for(let c=0;c<l.bones.length;c++){const u=l.bones[c],m=e.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for path constraint ${l.name}.`);s.bones.push(m)}const o=l.target,h=e.findSlot(o);if(!h)throw new Error(`Couldn't find target slot ${o} for path constraint ${l.name}.`);s.target=h,s.positionMode=B.enumValue(bt,I(l,"positionMode","Percent")),s.spacingMode=B.enumValue(K,I(l,"spacingMode","Length")),s.rotateMode=B.enumValue(Tt,I(l,"rotateMode","Tangent")),s.offsetRotation=I(l,"rotation",0),s.position=I(l,"position",0),s.positionMode==bt.Fixed&&(s.position*=a),s.spacing=I(l,"spacing",0),(s.spacingMode==K.Length||s.spacingMode==K.Fixed)&&(s.spacing*=a),s.mixRotate=I(l,"mixRotate",1),s.mixX=I(l,"mixX",1),s.mixY=I(l,"mixY",s.mixX),e.pathConstraints.push(s)}if(r.skins)for(let d=0;d<r.skins.length;d++){const l=r.skins[d],s=new Ot(l.name);if(l.bones)for(let o=0;o<l.bones.length;o++){const h=l.bones[o],c=e.findBone(h);if(!c)throw new Error(`Couldn't find bone ${h} for skin ${l.name}.`);s.bones.push(c)}if(l.ik)for(let o=0;o<l.ik.length;o++){const h=l.ik[o],c=e.findIkConstraint(h);if(!c)throw new Error(`Couldn't find IK constraint ${h} for skin ${l.name}.`);s.constraints.push(c)}if(l.transform)for(let o=0;o<l.transform.length;o++){const h=l.transform[o],c=e.findTransformConstraint(h);if(!c)throw new Error(`Couldn't find transform constraint ${h} for skin ${l.name}.`);s.constraints.push(c)}if(l.path)for(let o=0;o<l.path.length;o++){const h=l.path[o],c=e.findPathConstraint(h);if(!c)throw new Error(`Couldn't find path constraint ${h} for skin ${l.name}.`);s.constraints.push(c)}for(const o in l.attachments){const h=e.findSlot(o);if(!h)throw new Error(`Couldn't find slot ${o} for skin ${l.name}.`);const c=l.attachments[o];for(const u in c){const m=this.readAttachment(c[u],s,h.index,u,e);m&&s.setAttachment(h.index,u,m)}}e.skins.push(s),s.name=="default"&&(e.defaultSkin=s)}for(let d=0,l=this.linkedMeshes.length;d<l;d++){const s=this.linkedMeshes[d],o=s.skin?e.findSkin(s.skin):e.defaultSkin;if(!o)throw new Error(`Skin not found: ${s.skin}`);const h=o.getAttachment(s.slotIndex,s.parent);if(!h)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.timelineAttachment=s.inheritTimeline?h:s.mesh,s.mesh.setParentMesh(h)}if(this.linkedMeshes.length=0,r.events)for(const d in r.events){const l=r.events[d],s=new Ie(d);s.intValue=I(l,"int",0),s.floatValue=I(l,"float",0),s.stringValue=I(l,"string",""),s.audioPath=I(l,"audio",null),s.audioPath&&(s.volume=I(l,"volume",1),s.balance=I(l,"balance",0)),e.events.push(s)}if(r.animations)for(const d in r.animations){const l=r.animations[d];this.readAnimation(l,d,e)}return e}readAttachment(t,a,e,r,i){const d=this.scale;switch(r=I(t,"name",r),I(t,"type","region")){case"region":{const l=I(t,"path",r),s=this.readSequence(I(t,"sequence",null)),o=this.attachmentLoader.newRegionAttachment(a,r,l,s);if(!o)return null;o.path=l,o.x=I(t,"x",0)*d,o.y=I(t,"y",0)*d,o.scaleX=I(t,"scaleX",1),o.scaleY=I(t,"scaleY",1),o.rotation=I(t,"rotation",0),o.width=t.width*d,o.height=t.height*d,o.sequence=s;const h=I(t,"color",null);return h&&o.color.setFromString(h),o}case"boundingbox":{const l=this.attachmentLoader.newBoundingBoxAttachment(a,r);if(!l)return null;this.readVertices(t,l,t.vertexCount<<1);const s=I(t,"color",null);return s&&l.color.setFromString(s),l}case"mesh":case"linkedmesh":{const l=I(t,"path",r),s=this.readSequence(I(t,"sequence",null)),o=this.attachmentLoader.newMeshAttachment(a,r,l,s);if(!o)return null;o.path=l;const h=I(t,"color",null);h&&o.color.setFromString(h),o.width=I(t,"width",0)*d,o.height=I(t,"height",0)*d,o.sequence=s;const c=I(t,"parent",null);if(c)return this.linkedMeshes.push(new $s(o,I(t,"skin",null),e,c,I(t,"timelines",!0))),o;const u=t.uvs;return this.readVertices(t,o,u.length),o.triangles=t.triangles,o.regionUVs=new Float32Array(u),o.edges=I(t,"edges",null),o.hullLength=I(t,"hull",0)*2,o}case"path":{const l=this.attachmentLoader.newPathAttachment(a,r);if(!l)return null;l.closed=I(t,"closed",!1),l.constantSpeed=I(t,"constantSpeed",!0);const s=t.vertexCount;this.readVertices(t,l,s<<1);const o=B.newArray(s/3,0);for(let c=0;c<t.lengths.length;c++)o[c]=t.lengths[c]*d;l.lengths=o;const h=I(t,"color",null);return h&&l.color.setFromString(h),l}case"point":{const l=this.attachmentLoader.newPointAttachment(a,r);if(!l)return null;l.x=I(t,"x",0)*d,l.y=I(t,"y",0)*d,l.rotation=I(t,"rotation",0);const s=I(t,"color",null);return s&&l.color.setFromString(s),l}case"clipping":{const l=this.attachmentLoader.newClippingAttachment(a,r);if(!l)return null;const s=I(t,"end",null);if(s!=null){const c=i.findSlot(s);if(c==null)throw new Error(`Clipping end slot not found: ${s}`);l.endSlot=c}const o=t.vertexCount;this.readVertices(t,l,o<<1);const h=I(t,"color",null);return h&&l.color.setFromString(h),l}}return null}readSequence(t){if(t==null)return null;const a=new qt(I(t,"count",0));return a.start=I(t,"start",1),a.digits=I(t,"digits",0),a.setupIndex=I(t,"setup",0),a}readVertices(t,a,e){const r=this.scale;a.worldVerticesLength=e;const i=t.vertices;if(e==i.length){const s=B.toFloatArray(i);if(r!=1)for(let o=0,h=i.length;o<h;o++)s[o]*=r;a.vertices=s;return}const d=new Array,l=new Array;for(let s=0,o=i.length;s<o;){const h=i[s++];l.push(h);for(let c=s+h*4;s<c;s+=4)l.push(i[s]),d.push(i[s+1]*r),d.push(i[s+2]*r),d.push(i[s+3])}a.bones=l,a.vertices=B.toFloatArray(d)}readAnimation(t,a,e){const r=this.scale,i=new Array;if(t.slots)for(const l in t.slots){const s=t.slots[l],o=e.findSlot(l);if(!o)throw new Error(`Slot not found: ${l}`);const h=o.index;for(const c in s){const u=s[c];if(!u)continue;const m=u.length;if(c=="attachment"){const f=new kt(m,h);for(let x=0;x<m;x++){const b=u[x];f.setFrame(x,I(b,"time",0),I(b,"name",null))}i.push(f)}else if(c=="rgba"){const f=new he(m,m<<2,h);let x=u[0],b=I(x,"time",0),k=L.fromString(x.color);for(let g=0,y=0;;g++){f.setFrame(g,b,k.r,k.g,k.b,k.a);const w=u[g+1];if(!w){f.shrink(y);break}const p=I(w,"time",0),S=L.fromString(w.color),A=x.curve;A&&(y=U(A,f,y,g,0,b,p,k.r,S.r,1),y=U(A,f,y,g,1,b,p,k.g,S.g,1),y=U(A,f,y,g,2,b,p,k.b,S.b,1),y=U(A,f,y,g,3,b,p,k.a,S.a,1)),b=p,k=S,x=w}i.push(f)}else if(c=="rgb"){const f=new le(m,m*3,h);let x=u[0],b=I(x,"time",0),k=L.fromString(x.color);for(let g=0,y=0;;g++){f.setFrame(g,b,k.r,k.g,k.b);const w=u[g+1];if(!w){f.shrink(y);break}const p=I(w,"time",0),S=L.fromString(w.color),A=x.curve;A&&(y=U(A,f,y,g,0,b,p,k.r,S.r,1),y=U(A,f,y,g,1,b,p,k.g,S.g,1),y=U(A,f,y,g,2,b,p,k.b,S.b,1)),b=p,k=S,x=w}i.push(f)}else if(c=="alpha")i.push(mt(u,new ce(m,m,h),0,1));else if(c=="rgba2"){const f=new de(m,m*7,h);let x=u[0],b=I(x,"time",0),k=L.fromString(x.light),g=L.fromString(x.dark);for(let y=0,w=0;;y++){f.setFrame(y,b,k.r,k.g,k.b,k.a,g.r,g.g,g.b);const p=u[y+1];if(!p){f.shrink(w);break}const S=I(p,"time",0),A=L.fromString(p.light),C=L.fromString(p.dark),v=x.curve;v&&(w=U(v,f,w,y,0,b,S,k.r,A.r,1),w=U(v,f,w,y,1,b,S,k.g,A.g,1),w=U(v,f,w,y,2,b,S,k.b,A.b,1),w=U(v,f,w,y,3,b,S,k.a,A.a,1),w=U(v,f,w,y,4,b,S,g.r,C.r,1),w=U(v,f,w,y,5,b,S,g.g,C.g,1),w=U(v,f,w,y,6,b,S,g.b,C.b,1)),b=S,k=A,g=C,x=p}i.push(f)}else if(c=="rgb2"){const f=new me(m,m*6,h);let x=u[0],b=I(x,"time",0),k=L.fromString(x.light),g=L.fromString(x.dark);for(let y=0,w=0;;y++){f.setFrame(y,b,k.r,k.g,k.b,g.r,g.g,g.b);const p=u[y+1];if(!p){f.shrink(w);break}const S=I(p,"time",0),A=L.fromString(p.light),C=L.fromString(p.dark),v=x.curve;v&&(w=U(v,f,w,y,0,b,S,k.r,A.r,1),w=U(v,f,w,y,1,b,S,k.g,A.g,1),w=U(v,f,w,y,2,b,S,k.b,A.b,1),w=U(v,f,w,y,3,b,S,g.r,C.r,1),w=U(v,f,w,y,4,b,S,g.g,C.g,1),w=U(v,f,w,y,5,b,S,g.b,C.b,1)),b=S,k=A,g=C,x=p}i.push(f)}}}if(t.bones)for(const l in t.bones){const s=t.bones[l],o=e.findBone(l);if(!o)throw new Error(`Bone not found: ${l}`);const h=o.index;for(const c in s){const u=s[c],m=u.length;if(m!=0){if(c==="rotate")i.push(mt(u,new Bt(m,m,h),0,1));else if(c==="translate"){const f=new Zt(m,m<<1,h);i.push(Ee(u,f,"x","y",0,r))}else if(c==="translatex"){const f=new te(m,m,h);i.push(mt(u,f,0,r))}else if(c==="translatey"){const f=new ee(m,m,h);i.push(mt(u,f,0,r))}else if(c==="scale"){const f=new se(m,m<<1,h);i.push(Ee(u,f,"x","y",1,1))}else if(c==="scalex"){const f=new ne(m,m,h);i.push(mt(u,f,1,1))}else if(c==="scaley"){const f=new ae(m,m,h);i.push(mt(u,f,1,1))}else if(c==="shear"){const f=new re(m,m<<1,h);i.push(Ee(u,f,"x","y",0,1))}else if(c==="shearx"){const f=new ie(m,m,h);i.push(mt(u,f,0,1))}else if(c==="sheary"){const f=new oe(m,m,h);i.push(mt(u,f,0,1))}}}}if(t.ik)for(const l in t.ik){const s=t.ik[l];let o=s[0];if(!o)continue;const h=e.findIkConstraint(l);if(!h)throw new Error(`IK Constraint not found: ${l}`);const c=e.ikConstraints.indexOf(h),u=new fe(s.length,s.length<<1,c);let m=I(o,"time",0),f=I(o,"mix",1),x=I(o,"softness",0)*r;for(let b=0,k=0;;b++){u.setFrame(b,m,f,x,I(o,"bendPositive",!0)?1:-1,I(o,"compress",!1),I(o,"stretch",!1));const g=s[b+1];if(!g){u.shrink(k);break}const y=I(g,"time",0),w=I(g,"mix",1),p=I(g,"softness",0)*r,S=o.curve;S&&(k=U(S,u,k,b,0,m,y,f,w,1),k=U(S,u,k,b,1,m,y,x,p,r)),m=y,f=w,x=p,o=g}i.push(u)}if(t.transform)for(const l in t.transform){const s=t.transform[l];let o=s[0];if(!o)continue;const h=e.findTransformConstraint(l);if(!h)throw new Error(`Transform constraint not found: ${l}`);const c=e.transformConstraints.indexOf(h),u=new ge(s.length,s.length*6,c);let m=I(o,"time",0),f=I(o,"mixRotate",1),x=I(o,"mixX",1),b=I(o,"mixY",x),k=I(o,"mixScaleX",1),g=I(o,"mixScaleY",k);const y=I(o,"mixShearY",1);for(let w=0,p=0;;w++){u.setFrame(w,m,f,x,b,k,g,y);const S=s[w+1];if(!S){u.shrink(p);break}const A=I(S,"time",0),C=I(S,"mixRotate",1),v=I(S,"mixX",1),F=I(S,"mixY",v),X=I(S,"mixScaleX",1),T=I(S,"mixScaleY",X),R=I(S,"mixShearY",1),E=o.curve;E&&(p=U(E,u,p,w,0,m,A,f,C,1),p=U(E,u,p,w,1,m,A,x,v,1),p=U(E,u,p,w,2,m,A,b,F,1),p=U(E,u,p,w,3,m,A,k,X,1),p=U(E,u,p,w,4,m,A,g,T,1),p=U(E,u,p,w,5,m,A,y,R,1)),m=A,f=C,x=v,b=F,k=X,g=T,k=X,o=S}i.push(u)}if(t.path)for(const l in t.path){const s=t.path[l],o=e.findPathConstraint(l);if(!o)throw new Error(`Path constraint not found: ${l}`);const h=e.pathConstraints.indexOf(o);for(const c in s){const u=s[c];let m=u[0];if(!m)continue;const f=u.length;if(c==="position"){const x=new pe(f,f,h);i.push(mt(u,x,0,o.positionMode==bt.Fixed?r:1))}else if(c==="spacing"){const x=new xe(f,f,h);i.push(mt(u,x,0,o.spacingMode==K.Length||o.spacingMode==K.Fixed?r:1))}else if(c==="mix"){const x=new be(f,f*3,h);let b=I(m,"time",0),k=I(m,"mixRotate",1),g=I(m,"mixX",1),y=I(m,"mixY",g);for(let w=0,p=0;;w++){x.setFrame(w,b,k,g,y);const S=u[w+1];if(!S){x.shrink(p);break}const A=I(S,"time",0),C=I(S,"mixRotate",1),v=I(S,"mixX",1),F=I(S,"mixY",v),X=m.curve;X&&(p=U(X,x,p,w,0,b,A,k,C,1),p=U(X,x,p,w,1,b,A,g,v,1),p=U(X,x,p,w,2,b,A,y,F,1)),b=A,k=C,g=v,y=F,m=S}i.push(x)}}}if(t.deform){t.attachments={};for(const l in t.deform){const s=t.deform[l],o=t.attachments[l]={};for(const h in s){const c=s[h],u=o[h]={};for(const m in c)u[m]={deform:c[m]}}}}if(t.attachments)for(const l in t.attachments){const s=t.attachments[l],o=e.findSkin(l);if(o==null){if(Xt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${l}`);continue}for(const h in s){const c=s[h],u=e.findSlot(h);if(!u)throw new Error(`Slot not found: ${h}`);const m=u.index;for(const f in c){const x=c[f],b=o.getAttachment(m,f);for(const k in x){const g=x[k];let y=g[0];if(y){if(k=="deform"){const w=b.bones,p=b.vertices,S=w?p.length/3*2:p.length,A=new ue(g.length,g.length,m,b);let C=I(y,"time",0);for(let v=0,F=0;;v++){let X;const T=I(y,"vertices",null);if(!T)X=w?B.newFloatArray(S):p;else{X=B.newFloatArray(S);const V=I(y,"offset",0);if(B.arrayCopy(T,0,X,V,T.length),r!=1)for(let D=V,$=D+T.length;D<$;D++)X[D]*=r;if(!w)for(let D=0;D<S;D++)X[D]+=p[D]}A.setFrame(v,C,X);const R=g[v+1];if(!R){A.shrink(F);break}const E=I(R,"time",0),O=y.curve;O&&(F=U(O,A,F,v,0,C,E,0,1,1)),C=E,y=R}i.push(A)}else if(k=="sequence"){const w=new vt(g.length,m,b);let p=0;for(let S=0;S<g.length;S++){const A=I(y,"delay",p),C=I(y,"time",0),v=ct[I(y,"mode","hold")],F=I(y,"index",0);w.setFrame(S,C,v,F,A),p=A,y=g[S+1]}i.push(w)}}}}}}if(t.drawOrder){const l=new yt(t.drawOrder.length),s=e.slots.length;let o=0;for(let h=0;h<t.drawOrder.length;h++,o++){const c=t.drawOrder[h];let u=null;const m=I(c,"offsets",null);if(m){u=B.newArray(s,-1);const f=B.newArray(s-m.length,0);let x=0,b=0;for(let k=0;k<m.length;k++){const g=m[k],y=e.findSlot(g.slot);if(!y)throw new Error(`Slot not found: ${y}`);const w=y.index;for(;x!=w;)f[b++]=x++;u[x+g.offset]=x++}for(;x<s;)f[b++]=x++;for(let k=s-1;k>=0;k--)u[k]==-1&&(u[k]=f[--b])}l.setFrame(o,I(c,"time",0),u)}i.push(l)}if(t.events){const l=new Et(t.events.length);let s=0;for(let o=0;o<t.events.length;o++,s++){const h=t.events[o],c=e.findEvent(h.name);if(!c)throw new Error(`Event not found: ${h.name}`);const u=new Ae(B.toSinglePrecision(I(h,"time",0)),c);u.intValue=I(h,"int",c.intValue),u.floatValue=I(h,"float",c.floatValue),u.stringValue=I(h,"string",c.stringValue),u.data.audioPath&&(u.volume=I(h,"volume",1),u.balance=I(h,"balance",0)),l.setFrame(s,u)}i.push(l)}let d=0;for(let l=0,s=i.length;l<s;l++)d=Math.max(d,i[l].getDuration());if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Lt(a,i,d))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return"normal";if(t=="additive")return"add";if(t=="multiply")return"multiply";if(t=="screen")return"screen";throw new Error(`Unknown blend mode: ${t}`)}}class $s{constructor(t,a,e,r,i){this.mesh=t,this.skin=a,this.slotIndex=e,this.parent=r,this.inheritTimeline=i}}function mt(n,t,a,e){let r=n[0],i=I(r,"time",0),d=I(r,"value",a)*e,l=0;for(let s=0;;s++){t.setFrame(s,i,d);const o=n[s+1];if(!o)return t.shrink(l),t;const h=I(o,"time",0),c=I(o,"value",a)*e;r.curve&&(l=U(r.curve,t,l,s,0,i,h,d,c,e)),i=h,d=c,r=o}}function Ee(n,t,a,e,r,i){let d=n[0],l=I(d,"time",0),s=I(d,a,r)*i,o=I(d,e,r)*i,h=0;for(let c=0;;c++){t.setFrame(c,l,s,o);const u=n[c+1];if(!u)return t.shrink(h),t;const m=I(u,"time",0),f=I(u,a,r)*i,x=I(u,e,r)*i,b=d.curve;b&&(h=U(b,t,h,c,0,l,m,s,f,i),h=U(b,t,h,c,1,l,m,o,x,i)),l=m,s=f,o=x,d=u}}function U(n,t,a,e,r,i,d,l,s,o){if(n=="stepped")return t.setStepped(e),a;const h=r<<2,c=n[h],u=n[h+1]*o,m=n[h+2],f=n[h+3]*o;return t.setBezier(a,e,r,i,l,c,u,m,f,d,s),a+1}function I(n,t,a){return n[t]!==void 0?n[t]:a}class Ps extends hs{createSkeleton(t){this.skeleton=new Ce(t),this.skeleton.updateWorldTransform(),this.stateData=new Qe(t),this.state=new Ct(this.stateData)}}export{ce as AlphaTimeline,Lt as Animation,Ct as AnimationState,cs as AnimationStateAdapter,Qe as AnimationStateData,us as AtlasAttachmentLoader,Jt as Attachment,kt as AttachmentTimeline,ye as Bone,Se as BoneData,zt as BoundingBoxAttachment,_t as ClippingAttachment,Ut as ConstraintData,it as CurveTimeline,ot as CurveTimeline1,Wt as CurveTimeline2,ue as DeformTimeline,yt as DrawOrderTimeline,Ae as Event,Ie as EventData,Ge as EventQueue,Et as EventTimeline,Z as EventType,Ze as IkConstraint,Ye as IkConstraintData,fe as IkConstraintTimeline,At as MeshAttachment,St as PathAttachment,Ft as PathConstraint,ve as PathConstraintData,be as PathConstraintMixTimeline,pe as PathConstraintPositionTimeline,xe as PathConstraintSpacingTimeline,jt as PointAttachment,me as RGB2Timeline,de as RGBA2Timeline,he as RGBATimeline,le as RGBTimeline,N as RegionAttachment,Bt as RotateTimeline,se as ScaleTimeline,ne as ScaleXTimeline,ae as ScaleYTimeline,qt as Sequence,ct as SequenceMode,Qt as SequenceModeValues,vt as SequenceTimeline,re as ShearTimeline,ie as ShearXTimeline,oe as ShearYTimeline,Ce as Skeleton,ns as SkeletonBinary,Vs as SkeletonBounds,Fe as SkeletonData,Re as SkeletonJson,Ot as Skin,Te as SkinEntry,ts as Slot,Me as SlotData,K as SpacingMode,Ps as Spine,G as Timeline,Nt as TrackEntry,es as TransformConstraint,Xe as TransformConstraintData,ge as TransformConstraintTimeline,Zt as TranslateTimeline,te as TranslateXTimeline,ee as TranslateYTimeline,rt as VertexAttachment};
//# sourceMappingURL=runtime-4.1.mjs.map
