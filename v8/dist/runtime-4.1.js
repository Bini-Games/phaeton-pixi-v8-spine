/*!
 * @pixi-spine/runtime-4.1 - v4.0.3
 * Compiled Thu, 11 Apr 2024 10:02:14 UTC
 *
 * @pixi-spine/runtime-4.1 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2024, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine41=function(F,f,He){"use strict";class qt{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Ie=class extends qt{constructor(s){super(s),this.id=Ie.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(s,t){this.computeWorldVertices(s,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(s,t,i,e,a,r){i=a+(i>>1)*r;const d=s.bone.skeleton,h=s.deform;let n=this.vertices;const o=this.bones;if(!o){h.length>0&&(n=h);const m=s.bone.matrix,g=m.tx,w=m.ty,M=m.a,k=m.c,p=m.b,S=m.d;for(let y=t,x=a;x<i;y+=2,x+=r){const B=n[y],A=n[y+1];e[x]=B*M+A*k+g,e[x+1]=B*p+A*S+w}return}let l=0,c=0;for(let m=0;m<t;m+=2){const g=o[l];l+=g+1,c+=g}const u=d.bones;if(h.length==0)for(let m=a,g=c*3;m<i;m+=r){let w=0,M=0,k=o[l++];for(k+=l;l<k;l++,g+=3){const p=u[o[l]].matrix,S=n[g],y=n[g+1],x=n[g+2];w+=(S*p.a+y*p.c+p.tx)*x,M+=(S*p.b+y*p.d+p.ty)*x}e[m]=w,e[m+1]=M}else{const m=h;for(let g=a,w=c*3,M=c<<1;g<i;g+=r){let k=0,p=0,S=o[l++];for(S+=l;l<S;l++,w+=3,M+=2){const y=u[o[l]].matrix,x=n[w]+m[M],B=n[w+1]+m[M+1],A=n[w+2];k+=(x*y.a+B*y.c+y.tx)*A,p+=(x*y.b+B*y.d+y.ty)*A}e[g]=k,e[g+1]=p}}}copyTo(s){this.bones?(s.bones=new Array(this.bones.length),f.Utils.arrayCopy(this.bones,0,s.bones,0,this.bones.length)):s.bones=null,this.vertices&&(s.vertices=f.Utils.newFloatArray(this.vertices.length),f.Utils.arrayCopy(this.vertices,0,s.vertices,0,this.vertices.length)),s.worldVerticesLength=this.worldVerticesLength,s.timelineAttachment=this.timelineAttachment}};let Z=Ie;Z.nextID=0;class bt extends Z{constructor(t){super(t),this.type=f.AttachmentType.BoundingBox,this.color=new f.Color(1,1,1,1)}copy(){const t=new bt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Yt extends Z{constructor(t){super(t),this.type=f.AttachmentType.Clipping,this.endSlot=null,this.color=new f.Color(.2275,.2275,.8078,1)}copy(){const t=new Yt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class ft extends Z{constructor(t,i){super(t),this.type=f.AttachmentType.Mesh,this.region=null,this.triangles=[],this.color=new f.Color(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new f.Color(0,0,0,0),this.path=i}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new ft(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),f.Utils.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),f.Utils.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),f.Utils.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,i,e,a,r,d){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,i,e,a,r,d)}newLinkedMesh(){const t=new ft(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class gt extends Z{constructor(t){super(t),this.type=f.AttachmentType.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new f.Color(1,1,1,1)}copy(){const t=new gt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),f.Utils.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class vt extends Z{constructor(t){super(t),this.type=f.AttachmentType.Point,this.x=0,this.y=0,this.rotation=0,this.color=new f.Color(.38,.94,0,1)}computeWorldPosition(t,i){const e=t.matrix;return i.x=this.x*e.a+this.y*e.c+t.worldX,i.y=this.x*e.b+this.y*e.d+t.worldY,i}computeWorldRotation(t){const i=t.matrix,e=f.MathUtils.cosDeg(this.rotation),a=f.MathUtils.sinDeg(this.rotation),r=e*i.a+a*i.c,d=e*i.b+a*i.d;return Math.atan2(d,r)*f.MathUtils.radDeg}copy(){const t=new vt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const be=class extends qt{constructor(s,t){super(s),this.type=f.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new f.Color(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=f.Utils.newFloatArray(8),this.uvs=f.Utils.newFloatArray(8),this.tempColor=new f.Color(1,1,1,1),this.path=t}updateRegion(){if(!this.region)throw new Error("Region not set.");const s=this.region,t=this.width/this.region.originalWidth*this.scaleX,i=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,a=-this.height/2*this.scaleY+this.region.offsetY*i,r=e+this.region.width*t,d=a+this.region.height*i,h=this.rotation*Math.PI/180,n=Math.cos(h),o=Math.sin(h),l=this.x,c=this.y,u=e*n+l,m=e*o,g=a*n+c,w=a*o,M=r*n+l,k=r*o,p=d*n+c,S=d*o,y=this.offset;y[0]=u-w,y[1]=g+m,y[2]=u-S,y[3]=p+m,y[4]=M-S,y[5]=p+k,y[6]=M-w,y[7]=g+k;const x=this.uvs;s.degrees==90?(x[2]=s.u,x[3]=s.v2,x[4]=s.u,x[5]=s.v,x[6]=s.u2,x[7]=s.v,x[0]=s.u2,x[1]=s.v2):(x[0]=s.u,x[1]=s.v2,x[2]=s.u,x[3]=s.v,x[4]=s.u2,x[5]=s.v,x[6]=s.u2,x[7]=s.v2)}computeWorldVertices(s,t,i,e){this.sequence!=null&&this.sequence.apply(s,this);const a=s.bone,r=this.offset,d=a.matrix,h=d.tx,n=d.ty,o=d.a,l=d.c,c=d.b,u=d.d;let m=0,g=0;m=r[0],g=r[1],t[i]=m*o+g*l+h,t[i+1]=m*c+g*u+n,i+=e,m=r[2],g=r[3],t[i]=m*o+g*l+h,t[i+1]=m*c+g*u+n,i+=e,m=r[4],g=r[5],t[i]=m*o+g*l+h,t[i+1]=m*c+g*u+n,i+=e,m=r[6],g=r[7],t[i]=m*o+g*l+h,t[i+1]=m*c+g*u+n}copy(){const s=new be(this.name,this.path);return s.region=this.region,s.rendererObject=this.rendererObject,s.x=this.x,s.y=this.y,s.scaleX=this.scaleX,s.scaleY=this.scaleY,s.rotation=this.rotation,s.width=this.width,s.height=this.height,f.Utils.arrayCopy(this.uvs,0,s.uvs,0,8),f.Utils.arrayCopy(this.offset,0,s.offset,0,8),s.color.setFromColor(this.color),s.sequence=this.sequence!=null?this.sequence.copy():null,s}};let q=be;q.X1=0,q.Y1=1,q.C1R=2,q.C1G=3,q.C1B=4,q.C1A=5,q.U1=6,q.V1=7,q.X2=8,q.Y2=9,q.C2R=10,q.C2G=11,q.C2B=12,q.C2A=13,q.U2=14,q.V2=15,q.X3=16,q.Y3=17,q.C3R=18,q.C3G=19,q.C3B=20,q.C3A=21,q.U3=22,q.V3=23,q.X4=24,q.Y4=25,q.C4R=26,q.C4G=27,q.C4B=28,q.C4A=29,q.U4=30,q.V4=31;const Tt=class{constructor(t){this.id=Tt.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(t)}copy(){const t=new Tt(this.regions.length);return f.Utils.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,i){let e=t.sequenceIndex;e==-1&&(e=this.setupIndex),e>=this.regions.length&&(e=this.regions.length-1);const a=this.regions[e];i.region!=a&&(i.region=a)}getPath(t,i){let e=t;const a=(this.start+i).toString();for(let r=this.digits-a.length;r>0;r--)e+="0";return e+=a,e}static nextID(){return Tt._nextID++}};let Ft=Tt;Ft._nextID=0;var at=(s=>(s[s.hold=0]="hold",s[s.once=1]="once",s[s.loop=2]="loop",s[s.pingpong=3]="pingpong",s[s.onceReverse=4]="onceReverse",s[s.loopReverse=5]="loopReverse",s[s.pingpongReverse=6]="pingpongReverse",s))(at||{});const Lt=[0,1,2,3,4,5,6];class Xt{constructor(t,i,e){if(this.timelines=[],this.timelineIds=new f.StringSet,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(i),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let i=0;i<t.length;i++)this.timelineIds.addAll(t[i].getPropertyIds())}hasTimeline(t){for(let i=0;i<t.length;i++)if(this.timelineIds.contains(t[i]))return!0;return!1}apply(t,i,e,a,r,d,h,n){if(!t)throw new Error("skeleton cannot be null.");a&&this.duration!=0&&(e%=this.duration,i>0&&(i%=this.duration));const o=this.timelines;for(let l=0,c=o.length;l<c;l++)o[l].apply(t,i,e,r,d,h,n)}}const N={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class _{constructor(t,i){this.propertyIds=i,this.frames=f.Utils.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,i){const e=t.length;for(let a=1;a<e;a++)if(t[a]>i)return a-1;return e-1}static search(t,i,e){const a=t.length;for(let r=e;r<a;r+=e)if(t[r]>i)return r-e;return a-e}}class tt extends _{constructor(t,i,e){super(t,e),this.curves=f.Utils.newFloatArray(t+i*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const i=this.getFrameCount()+t*18;if(this.curves.length>i){const e=f.Utils.newFloatArray(i);f.Utils.arrayCopy(this.curves,0,e,0,i),this.curves=e}}setBezier(t,i,e,a,r,d,h,n,o,l,c){const u=this.curves;let m=this.getFrameCount()+t*18;e==0&&(u[i]=2+m);const g=(a-d*2+n)*.03,w=(r-h*2+o)*.03,M=((d-n)*3-a+l)*.006,k=((h-o)*3-r+c)*.006;let p=g*2+M,S=w*2+k,y=(d-a)*.3+g+M*.16666667,x=(h-r)*.3+w+k*.16666667,B=a+y,A=r+x;for(let b=m+18;m<b;m+=2)u[m]=B,u[m+1]=A,y+=p,x+=S,p+=M,S+=k,B+=y,A+=x}getBezierValue(t,i,e,a){const r=this.curves;if(r[a]>t){const o=this.frames[i],l=this.frames[i+e];return l+(t-o)/(r[a]-o)*(r[a+1]-l)}const d=a+18;for(a+=2;a<d;a+=2)if(r[a]>=t){const o=r[a-2],l=r[a-1];return l+(t-o)/(r[a]-o)*(r[a+1]-l)}i+=this.getFrameEntries();const h=r[d-2],n=r[d-1];return n+(t-h)/(this.frames[i]-h)*(this.frames[i+e]-n)}}class et extends tt{constructor(t,i,e){super(t,i,[e])}getFrameEntries(){return 2}setFrame(t,i,e){t<<=1,this.frames[t]=i,this.frames[t+1]=e}getCurveValue(t){const i=this.frames;let e=i.length-2;for(let r=2;r<=e;r+=2)if(i[r]>t){e=r-2;break}const a=this.curves[e>>1];switch(a){case 0:const r=i[e],d=i[e+1];return d+(t-r)/(i[e+2]-r)*(i[e+2+1]-d);case 1:return i[e+1]}return this.getBezierValue(t,e,1,a-2)}}class Ut extends tt{constructor(t,i,e,a){super(t,i,[e,a])}getFrameEntries(){return 3}setFrame(t,i,e,a){t*=3,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=a}}class Bt extends et{constructor(t,i,e){super(t,i,`${N.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.rotation=n.data.rotation;return;case f.MixBlend.first:n.rotation+=(n.data.rotation-n.rotation)*r}return}let l=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.rotation=n.data.rotation+l*r;break;case f.MixBlend.first:case f.MixBlend.replace:l+=n.data.rotation-n.rotation;case f.MixBlend.add:n.rotation+=l*r}}}class Wt extends Ut{constructor(t,i,e){super(t,i,`${N.x}|${e}`,`${N.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.x=n.data.x,n.y=n.data.y;return;case f.MixBlend.first:n.x+=(n.data.x-n.x)*r,n.y+=(n.data.y-n.y)*r}return}let l=0,c=0;const u=_.search(o,e,3),m=this.curves[u/3];switch(m){case 0:const g=o[u];l=o[u+1],c=o[u+2];const w=(e-g)/(o[u+3]-g);l+=(o[u+3+1]-l)*w,c+=(o[u+3+2]-c)*w;break;case 1:l=o[u+1],c=o[u+2];break;default:l=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}switch(d){case f.MixBlend.setup:n.x=n.data.x+l*r,n.y=n.data.y+c*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.x+=(n.data.x+l-n.x)*r,n.y+=(n.data.y+c-n.y)*r;break;case f.MixBlend.add:n.x+=l*r,n.y+=c*r}}}class Nt extends et{constructor(t,i,e){super(t,i,`${N.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.x=n.data.x;return;case f.MixBlend.first:n.x+=(n.data.x-n.x)*r}return}const l=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.x=n.data.x+l*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.x+=(n.data.x+l-n.x)*r;break;case f.MixBlend.add:n.x+=l*r}}}class Ot extends et{constructor(t,i,e){super(t,i,`${N.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.y=n.data.y;return;case f.MixBlend.first:n.y+=(n.data.y-n.y)*r}return}const l=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.y=n.data.y+l*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.y+=(n.data.y+l-n.y)*r;break;case f.MixBlend.add:n.y+=l*r}}}class zt extends Ut{constructor(t,i,e){super(t,i,`${N.scaleX}|${e}`,`${N.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.scaleX=n.data.scaleX,n.scaleY=n.data.scaleY;return;case f.MixBlend.first:n.scaleX+=(n.data.scaleX-n.scaleX)*r,n.scaleY+=(n.data.scaleY-n.scaleY)*r}return}let l,c;const u=_.search(o,e,3),m=this.curves[u/3];switch(m){case 0:const g=o[u];l=o[u+1],c=o[u+2];const w=(e-g)/(o[u+3]-g);l+=(o[u+3+1]-l)*w,c+=(o[u+3+2]-c)*w;break;case 1:l=o[u+1],c=o[u+2];break;default:l=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}if(l*=n.data.scaleX,c*=n.data.scaleY,r==1)d==f.MixBlend.add?(n.scaleX+=l-n.data.scaleX,n.scaleY+=c-n.data.scaleY):(n.scaleX=l,n.scaleY=c);else{let g=0,w=0;if(h==f.MixDirection.mixOut)switch(d){case f.MixBlend.setup:g=n.data.scaleX,w=n.data.scaleY,n.scaleX=g+(Math.abs(l)*f.MathUtils.signum(g)-g)*r,n.scaleY=w+(Math.abs(c)*f.MathUtils.signum(w)-w)*r;break;case f.MixBlend.first:case f.MixBlend.replace:g=n.scaleX,w=n.scaleY,n.scaleX=g+(Math.abs(l)*f.MathUtils.signum(g)-g)*r,n.scaleY=w+(Math.abs(c)*f.MathUtils.signum(w)-w)*r;break;case f.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*r,n.scaleY+=(c-n.data.scaleY)*r}else switch(d){case f.MixBlend.setup:g=Math.abs(n.data.scaleX)*f.MathUtils.signum(l),w=Math.abs(n.data.scaleY)*f.MathUtils.signum(c),n.scaleX=g+(l-g)*r,n.scaleY=w+(c-w)*r;break;case f.MixBlend.first:case f.MixBlend.replace:g=Math.abs(n.scaleX)*f.MathUtils.signum(l),w=Math.abs(n.scaleY)*f.MathUtils.signum(c),n.scaleX=g+(l-g)*r,n.scaleY=w+(c-w)*r;break;case f.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*r,n.scaleY+=(c-n.data.scaleY)*r}}}}class _t extends et{constructor(t,i,e){super(t,i,`${N.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.scaleX=n.data.scaleX;return;case f.MixBlend.first:n.scaleX+=(n.data.scaleX-n.scaleX)*r}return}const l=this.getCurveValue(e)*n.data.scaleX;if(r==1)d==f.MixBlend.add?n.scaleX+=l-n.data.scaleX:n.scaleX=l;else{let c=0;if(h==f.MixDirection.mixOut)switch(d){case f.MixBlend.setup:c=n.data.scaleX,n.scaleX=c+(Math.abs(l)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=n.scaleX,n.scaleX=c+(Math.abs(l)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*r}else switch(d){case f.MixBlend.setup:c=Math.abs(n.data.scaleX)*f.MathUtils.signum(l),n.scaleX=c+(l-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=Math.abs(n.scaleX)*f.MathUtils.signum(l),n.scaleX=c+(l-c)*r;break;case f.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*r}}}}class jt extends et{constructor(t,i,e){super(t,i,`${N.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.scaleY=n.data.scaleY;return;case f.MixBlend.first:n.scaleY+=(n.data.scaleY-n.scaleY)*r}return}const l=this.getCurveValue(e)*n.data.scaleY;if(r==1)d==f.MixBlend.add?n.scaleY+=l-n.data.scaleY:n.scaleY=l;else{let c=0;if(h==f.MixDirection.mixOut)switch(d){case f.MixBlend.setup:c=n.data.scaleY,n.scaleY=c+(Math.abs(l)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=n.scaleY,n.scaleY=c+(Math.abs(l)*f.MathUtils.signum(c)-c)*r;break;case f.MixBlend.add:n.scaleY+=(l-n.data.scaleY)*r}else switch(d){case f.MixBlend.setup:c=Math.abs(n.data.scaleY)*f.MathUtils.signum(l),n.scaleY=c+(l-c)*r;break;case f.MixBlend.first:case f.MixBlend.replace:c=Math.abs(n.scaleY)*f.MathUtils.signum(l),n.scaleY=c+(l-c)*r;break;case f.MixBlend.add:n.scaleY+=(l-n.data.scaleY)*r}}}}class Gt extends Ut{constructor(t,i,e){super(t,i,`${N.shearX}|${e}`,`${N.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX,n.shearY=n.data.shearY;return;case f.MixBlend.first:n.shearX+=(n.data.shearX-n.shearX)*r,n.shearY+=(n.data.shearY-n.shearY)*r}return}let l=0,c=0;const u=_.search(o,e,3),m=this.curves[u/3];switch(m){case 0:const g=o[u];l=o[u+1],c=o[u+2];const w=(e-g)/(o[u+3]-g);l+=(o[u+3+1]-l)*w,c+=(o[u+3+2]-c)*w;break;case 1:l=o[u+1],c=o[u+2];break;default:l=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX+l*r,n.shearY=n.data.shearY+c*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.shearX+=(n.data.shearX+l-n.shearX)*r,n.shearY+=(n.data.shearY+c-n.shearY)*r;break;case f.MixBlend.add:n.shearX+=l*r,n.shearY+=c*r}}}class Ht extends et{constructor(t,i,e){super(t,i,`${N.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX;return;case f.MixBlend.first:n.shearX+=(n.data.shearX-n.shearX)*r}return}const l=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.shearX=n.data.shearX+l*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.shearX+=(n.data.shearX+l-n.shearX)*r;break;case f.MixBlend.add:n.shearX+=l*r}}}class Kt extends et{constructor(t,i,e){super(t,i,`${N.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,a,r,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.shearY=n.data.shearY;return;case f.MixBlend.first:n.shearY+=(n.data.shearY-n.shearY)*r}return}const l=this.getCurveValue(e);switch(d){case f.MixBlend.setup:n.shearY=n.data.shearY+l*r;break;case f.MixBlend.first:case f.MixBlend.replace:n.shearY+=(n.data.shearY+l-n.shearY)*r;break;case f.MixBlend.add:n.shearY+=l*r}}}class Jt extends tt{constructor(t,i,e){super(t,i,[`${N.rgb}|${e}`,`${N.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,i,e,a,r,d){t*=5,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color;if(e<o[0]){const k=n.data.color;switch(d){case f.MixBlend.setup:l.setFromColor(k);return;case f.MixBlend.first:l.add((k.r-l.r)*r,(k.g-l.g)*r,(k.b-l.b)*r,(k.a-l.a)*r)}return}let c=0,u=0,m=0,g=0;const w=_.search(o,e,5),M=this.curves[w/5];switch(M){case 0:const k=o[w];c=o[w+1],u=o[w+2],m=o[w+3],g=o[w+4];const p=(e-k)/(o[w+5]-k);c+=(o[w+5+1]-c)*p,u+=(o[w+5+2]-u)*p,m+=(o[w+5+3]-m)*p,g+=(o[w+5+4]-g)*p;break;case 1:c=o[w+1],u=o[w+2],m=o[w+3],g=o[w+4];break;default:c=this.getBezierValue(e,w,1,M-2),u=this.getBezierValue(e,w,2,M+18-2),m=this.getBezierValue(e,w,3,M+18*2-2),g=this.getBezierValue(e,w,4,M+18*3-2)}r==1?l.set(c,u,m,g):(d==f.MixBlend.setup&&l.setFromColor(n.data.color),l.add((c-l.r)*r,(u-l.g)*r,(m-l.b)*r,(g-l.a)*r))}}class Qt extends tt{constructor(t,i,e){super(t,i,[`${N.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,i,e,a,r){t<<=2,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color;if(e<o[0]){const M=n.data.color;switch(d){case f.MixBlend.setup:l.r=M.r,l.g=M.g,l.b=M.b;return;case f.MixBlend.first:l.r+=(M.r-l.r)*r,l.g+=(M.g-l.g)*r,l.b+=(M.b-l.b)*r}return}let c=0,u=0,m=0;const g=_.search(o,e,4),w=this.curves[g>>2];switch(w){case 0:const M=o[g];c=o[g+1],u=o[g+2],m=o[g+3];const k=(e-M)/(o[g+4]-M);c+=(o[g+4+1]-c)*k,u+=(o[g+4+2]-u)*k,m+=(o[g+4+3]-m)*k;break;case 1:c=o[g+1],u=o[g+2],m=o[g+3];break;default:c=this.getBezierValue(e,g,1,w-2),u=this.getBezierValue(e,g,2,w+18-2),m=this.getBezierValue(e,g,3,w+18*2-2)}if(r==1)l.r=c,l.g=u,l.b=m;else{if(d==f.MixBlend.setup){const M=n.data.color;l.r=M.r,l.g=M.g,l.b=M.b}l.r+=(c-l.r)*r,l.g+=(u-l.g)*r,l.b+=(m-l.b)*r}}}class Zt extends et{constructor(t,i,e){super(t,i,`${N.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=n.color;if(e<this.frames[0]){const c=n.data.color;switch(d){case f.MixBlend.setup:o.a=c.a;return;case f.MixBlend.first:o.a+=(c.a-o.a)*r}return}const l=this.getCurveValue(e);r==1?o.a=l:(d==f.MixBlend.setup&&(o.a=n.data.color.a),o.a+=(l-o.a)*r)}}class te extends tt{constructor(t,i,e){super(t,i,[`${N.rgb}|${e}`,`${N.alpha}|${e}`,`${N.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,i,e,a,r,d,h,n,o){t<<=3,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d,this.frames[t+5]=h,this.frames[t+6]=n,this.frames[t+7]=o}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color,c=n.darkColor;if(e<o[0]){const x=n.data.color,B=n.data.darkColor;switch(d){case f.MixBlend.setup:l.setFromColor(x),c.r=B.r,c.g=B.g,c.b=B.b;return;case f.MixBlend.first:l.add((x.r-l.r)*r,(x.g-l.g)*r,(x.b-l.b)*r,(x.a-l.a)*r),c.r+=(B.r-c.r)*r,c.g+=(B.g-c.g)*r,c.b+=(B.b-c.b)*r}return}let u=0,m=0,g=0,w=0,M=0,k=0,p=0;const S=_.search(o,e,8),y=this.curves[S>>3];switch(y){case 0:const x=o[S];u=o[S+1],m=o[S+2],g=o[S+3],w=o[S+4],M=o[S+5],k=o[S+6],p=o[S+7];const B=(e-x)/(o[S+8]-x);u+=(o[S+8+1]-u)*B,m+=(o[S+8+2]-m)*B,g+=(o[S+8+3]-g)*B,w+=(o[S+8+4]-w)*B,M+=(o[S+8+5]-M)*B,k+=(o[S+8+6]-k)*B,p+=(o[S+8+7]-p)*B;break;case 1:u=o[S+1],m=o[S+2],g=o[S+3],w=o[S+4],M=o[S+5],k=o[S+6],p=o[S+7];break;default:u=this.getBezierValue(e,S,1,y-2),m=this.getBezierValue(e,S,2,y+18-2),g=this.getBezierValue(e,S,3,y+18*2-2),w=this.getBezierValue(e,S,4,y+18*3-2),M=this.getBezierValue(e,S,5,y+18*4-2),k=this.getBezierValue(e,S,6,y+18*5-2),p=this.getBezierValue(e,S,7,y+18*6-2)}if(r==1)l.set(u,m,g,w),c.r=M,c.g=k,c.b=p;else{if(d==f.MixBlend.setup){l.setFromColor(n.data.color);const x=n.data.darkColor;c.r=x.r,c.g=x.g,c.b=x.b}l.add((u-l.r)*r,(m-l.g)*r,(g-l.b)*r,(w-l.a)*r),c.r+=(M-c.r)*r,c.g+=(k-c.g)*r,c.b+=(p-c.b)*r}}}class ee extends tt{constructor(t,i,e){super(t,i,[`${N.rgb}|${e}`,`${N.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,i,e,a,r,d,h,n){t*=7,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d,this.frames[t+5]=h,this.frames[t+6]=n}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color,c=n.darkColor;if(e<o[0]){const y=n.data.color,x=n.data.darkColor;switch(d){case f.MixBlend.setup:l.r=y.r,l.g=y.g,l.b=y.b,c.r=x.r,c.g=x.g,c.b=x.b;return;case f.MixBlend.first:l.r+=(y.r-l.r)*r,l.g+=(y.g-l.g)*r,l.b+=(y.b-l.b)*r,c.r+=(x.r-c.r)*r,c.g+=(x.g-c.g)*r,c.b+=(x.b-c.b)*r}return}let u=0,m=0,g=0,w=0,M=0,k=0;const p=_.search(o,e,7),S=this.curves[p/7];switch(S){case 0:const y=o[p];u=o[p+1],m=o[p+2],g=o[p+3],w=o[p+4],M=o[p+5],k=o[p+6];const x=(e-y)/(o[p+7]-y);u+=(o[p+7+1]-u)*x,m+=(o[p+7+2]-m)*x,g+=(o[p+7+3]-g)*x,w+=(o[p+7+4]-w)*x,M+=(o[p+7+5]-M)*x,k+=(o[p+7+6]-k)*x;break;case 1:u=o[p+1],m=o[p+2],g=o[p+3],w=o[p+4],M=o[p+5],k=o[p+6];break;default:u=this.getBezierValue(e,p,1,S-2),m=this.getBezierValue(e,p,2,S+18-2),g=this.getBezierValue(e,p,3,S+18*2-2),w=this.getBezierValue(e,p,4,S+18*3-2),M=this.getBezierValue(e,p,5,S+18*4-2),k=this.getBezierValue(e,p,6,S+18*5-2)}if(r==1)l.r=u,l.g=m,l.b=g,c.r=w,c.g=M,c.b=k;else{if(d==f.MixBlend.setup){const y=n.data.color,x=n.data.darkColor;l.r=y.r,l.g=y.g,l.b=y.b,c.r=x.r,c.g=x.g,c.b=x.b}l.r+=(u-l.r)*r,l.g+=(m-l.g)*r,l.b+=(g-l.b)*r,c.r+=(w-c.r)*r,c.g+=(M-c.g)*r,c.b+=(k-c.b)*r}}}class pt extends _{constructor(t,i){super(t,[`${N.attachment}|${i}`]),this.slotIndex=0,this.slotIndex=i,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,i,e){this.frames[t]=i,this.attachmentNames[t]=e}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(n.bone.active){if(h==f.MixDirection.mixOut){d==f.MixBlend.setup&&this.setAttachment(t,n,n.data.attachmentName);return}if(e<this.frames[0]){(d==f.MixBlend.setup||d==f.MixBlend.first)&&this.setAttachment(t,n,n.data.attachmentName);return}this.setAttachment(t,n,this.attachmentNames[_.search1(this.frames,e)])}}setAttachment(t,i,e){i.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class ne extends tt{constructor(t,i,e,a){super(t,i,[`${N.deform}|${e}|${a.id}`]),this.slotIndex=0,this.slotIndex=e,this.attachment=a,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,i,e){this.frames[t]=i,this.vertices[t]=e}setBezier(t,i,e,a,r,d,h,n,o,l,c){const u=this.curves;let m=this.getFrameCount()+t*18;e==0&&(u[i]=2+m);const g=(a-d*2+n)*.03,w=o*.03-h*.06,M=((d-n)*3-a+l)*.006,k=(h-o+.33333333)*.018;let p=g*2+M,S=w*2+k,y=(d-a)*.3+g+M*.16666667,x=h*.3+w+k*.16666667,B=a+y,A=x;for(let b=m+18;m<b;m+=2)u[m]=B,u[m+1]=A,y+=p,x+=S,p+=M,S+=k,B+=y,A+=x}getCurvePercent(t,i){const e=this.curves;let a=e[i];switch(a){case 0:const n=this.frames[i];return(t-n)/(this.frames[i+this.getFrameEntries()]-n);case 1:return 0}if(a-=2,e[a]>t){const n=this.frames[i];return e[a+1]*(t-n)/(e[a]-n)}const r=a+18;for(a+=2;a<r;a+=2)if(e[a]>=t){const n=e[a-2],o=e[a-1];return o+(t-n)/(e[a]-n)*(e[a+1]-o)}const d=e[r-2],h=e[r-1];return h+(1-h)*(t-d)/(this.frames[i+this.getFrameEntries()]-d)}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=n.getAttachment();if(!o||!(o instanceof Z)||o.timelineAttachment!=this.attachment)return;const l=n.deform;l.length==0&&(d=f.MixBlend.setup);const c=this.vertices,u=c[0].length,m=this.frames;if(e<m[0]){switch(d){case f.MixBlend.setup:l.length=0;return;case f.MixBlend.first:if(r==1){l.length=0;return}l.length=u;const p=o;if(p.bones){r=1-r;for(let S=0;S<u;S++)l[S]*=r}else{const S=p.vertices;for(let y=0;y<u;y++)l[y]+=(S[y]-l[y])*r}}return}if(l.length=u,e>=m[m.length-1]){const p=c[m.length-1];if(r==1)if(d==f.MixBlend.add){const S=o;if(S.bones)for(let y=0;y<u;y++)l[y]+=p[y];else{const y=S.vertices;for(let x=0;x<u;x++)l[x]+=p[x]-y[x]}}else f.Utils.arrayCopy(p,0,l,0,u);else switch(d){case f.MixBlend.setup:{const y=o;if(y.bones)for(let x=0;x<u;x++)l[x]=p[x]*r;else{const x=y.vertices;for(let B=0;B<u;B++){const A=x[B];l[B]=A+(p[B]-A)*r}}break}case f.MixBlend.first:case f.MixBlend.replace:for(let y=0;y<u;y++)l[y]+=(p[y]-l[y])*r;break;case f.MixBlend.add:const S=o;if(S.bones)for(let y=0;y<u;y++)l[y]+=p[y]*r;else{const y=S.vertices;for(let x=0;x<u;x++)l[x]+=(p[x]-y[x])*r}}return}const g=_.search1(m,e),w=this.getCurvePercent(e,g),M=c[g],k=c[g+1];if(r==1)if(d==f.MixBlend.add){const p=o;if(p.bones)for(let S=0;S<u;S++){const y=M[S];l[S]+=y+(k[S]-y)*w}else{const S=p.vertices;for(let y=0;y<u;y++){const x=M[y];l[y]+=x+(k[y]-x)*w-S[y]}}}else for(let p=0;p<u;p++){const S=M[p];l[p]=S+(k[p]-S)*w}else switch(d){case f.MixBlend.setup:{const S=o;if(S.bones)for(let y=0;y<u;y++){const x=M[y];l[y]=(x+(k[y]-x)*w)*r}else{const y=S.vertices;for(let x=0;x<u;x++){const B=M[x],A=y[x];l[x]=A+(B+(k[x]-B)*w-A)*r}}break}case f.MixBlend.first:case f.MixBlend.replace:for(let S=0;S<u;S++){const y=M[S];l[S]+=(y+(k[S]-y)*w-l[S])*r}break;case f.MixBlend.add:const p=o;if(p.bones)for(let S=0;S<u;S++){const y=M[S];l[S]+=(y+(k[S]-y)*w)*r}else{const S=p.vertices;for(let y=0;y<u;y++){const x=M[y];l[y]+=(x+(k[y]-x)*w-S[y])*r}}}}}const Ye=class extends _{constructor(t){super(t,Ye.propertyIds),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,i){this.frames[t]=i.time,this.events[t]=i}apply(t,i,e,a,r,d,h){if(!a)return;const n=this.frames,o=this.frames.length;if(i>e)this.apply(t,i,Number.MAX_VALUE,a,r,d,h),i=-1;else if(i>=n[o-1])return;if(e<n[0])return;let l=0;if(i<n[0])l=0;else{l=_.search1(n,i)+1;const c=n[l];for(;l>0&&n[l-1]==c;)l--}for(;l<o&&e>=n[l];l++)a.push(this.events[l])}};let At=Ye;At.propertyIds=[`${N.event}`];const ve=class extends _{constructor(t){super(t,ve.propertyIds),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,i,e){this.frames[t]=i,this.drawOrders[t]=e}apply(t,i,e,a,r,d,h){if(h==f.MixDirection.mixOut){d==f.MixBlend.setup&&f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(e<this.frames[0]){(d==f.MixBlend.setup||d==f.MixBlend.first)&&f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const n=_.search1(this.frames,e),o=this.drawOrders[n];if(!o)f.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const l=t.drawOrder,c=t.slots;for(let u=0,m=o.length;u<m;u++)l[u]=c[o[u]]}}};let xt=ve;xt.propertyIds=[`${N.drawOrder}`];class se extends tt{constructor(t,i,e){super(t,i,[`${N.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,i,e,a,r,d,h){t*=6,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d?1:0,this.frames[t+5]=h?1:0}apply(t,i,e,a,r,d,h){const n=t.ikConstraints[this.ikConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.mix=n.data.mix,n.softness=n.data.softness,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch;return;case f.MixBlend.first:n.mix+=(n.data.mix-n.mix)*r,n.softness+=(n.data.softness-n.softness)*r,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch}return}let l=0,c=0;const u=_.search(o,e,6),m=this.curves[u/6];switch(m){case 0:const g=o[u];l=o[u+1],c=o[u+2];const w=(e-g)/(o[u+6]-g);l+=(o[u+6+1]-l)*w,c+=(o[u+6+2]-c)*w;break;case 1:l=o[u+1],c=o[u+2];break;default:l=this.getBezierValue(e,u,1,m-2),c=this.getBezierValue(e,u,2,m+18-2)}d==f.MixBlend.setup?(n.mix=n.data.mix+(l-n.data.mix)*r,n.softness=n.data.softness+(c-n.data.softness)*r,h==f.MixDirection.mixOut?(n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch):(n.bendDirection=o[u+3],n.compress=o[u+4]!=0,n.stretch=o[u+5]!=0)):(n.mix+=(l-n.mix)*r,n.softness+=(c-n.softness)*r,h==f.MixDirection.mixIn&&(n.bendDirection=o[u+3],n.compress=o[u+4]!=0,n.stretch=o[u+5]!=0))}}class ie extends tt{constructor(t,i,e){super(t,i,[`${N.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,i,e,a,r,d,h,n){const o=this.frames;t*=7,o[t]=i,o[t+1]=e,o[t+2]=a,o[t+3]=r,o[t+4]=d,o[t+5]=h,o[t+6]=n}apply(t,i,e,a,r,d,h){const n=t.transformConstraints[this.transformConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){const p=n.data;switch(d){case f.MixBlend.setup:n.mixRotate=p.mixRotate,n.mixX=p.mixX,n.mixY=p.mixY,n.mixScaleX=p.mixScaleX,n.mixScaleY=p.mixScaleY,n.mixShearY=p.mixShearY;return;case f.MixBlend.first:n.mixRotate+=(p.mixRotate-n.mixRotate)*r,n.mixX+=(p.mixX-n.mixX)*r,n.mixY+=(p.mixY-n.mixY)*r,n.mixScaleX+=(p.mixScaleX-n.mixScaleX)*r,n.mixScaleY+=(p.mixScaleY-n.mixScaleY)*r,n.mixShearY+=(p.mixShearY-n.mixShearY)*r}return}let l,c,u,m,g,w;const M=_.search(o,e,7),k=this.curves[M/7];switch(k){case 0:const p=o[M];l=o[M+1],c=o[M+2],u=o[M+3],m=o[M+4],g=o[M+5],w=o[M+6];const S=(e-p)/(o[M+7]-p);l+=(o[M+7+1]-l)*S,c+=(o[M+7+2]-c)*S,u+=(o[M+7+3]-u)*S,m+=(o[M+7+4]-m)*S,g+=(o[M+7+5]-g)*S,w+=(o[M+7+6]-w)*S;break;case 1:l=o[M+1],c=o[M+2],u=o[M+3],m=o[M+4],g=o[M+5],w=o[M+6];break;default:l=this.getBezierValue(e,M,1,k-2),c=this.getBezierValue(e,M,2,k+18-2),u=this.getBezierValue(e,M,3,k+18*2-2),m=this.getBezierValue(e,M,4,k+18*3-2),g=this.getBezierValue(e,M,5,k+18*4-2),w=this.getBezierValue(e,M,6,k+18*5-2)}if(d==f.MixBlend.setup){const p=n.data;n.mixRotate=p.mixRotate+(l-p.mixRotate)*r,n.mixX=p.mixX+(c-p.mixX)*r,n.mixY=p.mixY+(u-p.mixY)*r,n.mixScaleX=p.mixScaleX+(m-p.mixScaleX)*r,n.mixScaleY=p.mixScaleY+(g-p.mixScaleY)*r,n.mixShearY=p.mixShearY+(w-p.mixShearY)*r}else n.mixRotate+=(l-n.mixRotate)*r,n.mixX+=(c-n.mixX)*r,n.mixY+=(u-n.mixY)*r,n.mixScaleX+=(m-n.mixScaleX)*r,n.mixScaleY+=(g-n.mixScaleY)*r,n.mixShearY+=(w-n.mixShearY)*r}}class ae extends et{constructor(t,i,e){super(t,i,`${N.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,i,e,a,r,d,h){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.position=n.data.position;return;case f.MixBlend.first:n.position+=(n.data.position-n.position)*r}return}const l=this.getCurveValue(e);d==f.MixBlend.setup?n.position=n.data.position+(l-n.data.position)*r:n.position+=(l-n.position)*r}}class re extends et{constructor(t,i,e){super(t,i,`${N.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,i,e,a,r,d,h){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.spacing=n.data.spacing;return;case f.MixBlend.first:n.spacing+=(n.data.spacing-n.spacing)*r}return}const l=this.getCurveValue(e);d==f.MixBlend.setup?n.spacing=n.data.spacing+(l-n.data.spacing)*r:n.spacing+=(l-n.spacing)*r}}class oe extends tt{constructor(t,i,e){super(t,i,[`${N.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,i,e,a,r){const d=this.frames;t<<=2,d[t]=i,d[t+1]=e,d[t+2]=a,d[t+3]=r}apply(t,i,e,a,r,d,h){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(d){case f.MixBlend.setup:n.mixRotate=n.data.mixRotate,n.mixX=n.data.mixX,n.mixY=n.data.mixY;return;case f.MixBlend.first:n.mixRotate+=(n.data.mixRotate-n.mixRotate)*r,n.mixX+=(n.data.mixX-n.mixX)*r,n.mixY+=(n.data.mixY-n.mixY)*r}return}let l,c,u;const m=_.search(o,e,4),g=this.curves[m>>2];switch(g){case 0:const w=o[m];l=o[m+1],c=o[m+2],u=o[m+3];const M=(e-w)/(o[m+4]-w);l+=(o[m+4+1]-l)*M,c+=(o[m+4+2]-c)*M,u+=(o[m+4+3]-u)*M;break;case 1:l=o[m+1],c=o[m+2],u=o[m+3];break;default:l=this.getBezierValue(e,m,1,g-2),c=this.getBezierValue(e,m,2,g+18-2),u=this.getBezierValue(e,m,3,g+18*2-2)}if(d==f.MixBlend.setup){const w=n.data;n.mixRotate=w.mixRotate+(l-w.mixRotate)*r,n.mixX=w.mixX+(c-w.mixX)*r,n.mixY=w.mixY+(u-w.mixY)*r}else n.mixRotate+=(l-n.mixRotate)*r,n.mixX+=(c-n.mixX)*r,n.mixY+=(u-n.mixY)*r}}const ut=class extends _{constructor(t,i,e){super(t,[`${N.sequence}|${i}|${e.sequence.id}`]),this.slotIndex=i,this.attachment=e}getFrameEntries(){return ut.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,i,e,a,r){const d=this.frames;t*=ut.ENTRIES,d[t]=i,d[t+ut.MODE]=e|a<<4,d[t+ut.DELAY]=r}apply(t,i,e,a,r,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=n.attachment,l=this.attachment;if(o!=l&&(!(o instanceof Z)||o.timelineAttachment!=l))return;const c=this.frames;if(e<c[0]){(d==f.MixBlend.setup||d==f.MixBlend.first)&&(n.sequenceIndex=-1);return}const u=_.search(c,e,ut.ENTRIES),m=c[u],g=c[u+ut.MODE],w=c[u+ut.DELAY];if(!this.attachment.sequence)return;let M=g>>4;const k=this.attachment.sequence.regions.length,p=Lt[g&15];if(p!=at.hold)switch(M+=(e-m)/w+1e-5|0,p){case at.once:M=Math.min(k-1,M);break;case at.loop:M%=k;break;case at.pingpong:{const S=(k<<1)-2;M=S==0?0:M%S,M>=k&&(M=S-M);break}case at.onceReverse:M=Math.max(k-1-M,0);break;case at.loopReverse:M=k-1-M%k;break;case at.pingpongReverse:{const S=(k<<1)-2;M=S==0?0:(M+k-1)%S,M>=k&&(M=S-M)}}n.sequenceIndex=M}};let wt=ut;wt.ENTRIES=3,wt.MODE=1,wt.DELAY=2;const rt=class{constructor(s){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Te(this),this.propertyIDs=new f.StringSet,this.animationsChanged=!1,this.trackEntryPool=new f.Pool(()=>new Et),this.data=s}static emptyAnimation(){return rt._emptyAnimation}update(s){s*=this.timeScale;const t=this.tracks;for(let i=0,e=t.length;i<e;i++){const a=t[i];if(!a)continue;a.animationLast=a.nextAnimationLast,a.trackLast=a.nextTrackLast;let r=s*a.timeScale;if(a.delay>0){if(a.delay-=r,a.delay>0)continue;r=-a.delay,a.delay=0}let d=a.next;if(d){const h=a.trackLast-d.delay;if(h>=0){for(d.delay=0,d.trackTime+=a.timeScale==0?0:(h/a.timeScale+s)*d.timeScale,a.trackTime+=r,this.setCurrent(i,d,!0);d.mixingFrom;)d.mixTime+=s,d=d.mixingFrom;continue}}else if(a.trackLast>=a.trackEnd&&!a.mixingFrom){t[i]=null,this.queue.end(a),this.clearNext(a);continue}if(a.mixingFrom&&this.updateMixingFrom(a,s)){let h=a.mixingFrom;for(a.mixingFrom=null,h&&(h.mixingTo=null);h;)this.queue.end(h),h=h.mixingFrom}a.trackTime+=r}this.queue.drain()}updateMixingFrom(s,t){const i=s.mixingFrom;if(!i)return!0;const e=this.updateMixingFrom(i,t);return i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast,s.mixTime>0&&s.mixTime>=s.mixDuration?((i.totalAlpha==0||s.mixDuration==0)&&(s.mixingFrom=i.mixingFrom,i.mixingFrom&&(i.mixingFrom.mixingTo=s),s.interruptAlpha=i.interruptAlpha,this.queue.end(i)),e):(i.trackTime+=t*i.timeScale,s.mixTime+=t,!1)}apply(s){if(!s)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,i=this.tracks;let e=!1;for(let d=0,h=i.length;d<h;d++){const n=i[d];if(!n||n.delay>0)continue;e=!0;const o=d==0?f.MixBlend.first:n.mixBlend;let l=n.alpha;n.mixingFrom?l*=this.applyMixingFrom(n,s,o):n.trackTime>=n.trackEnd&&!n.next&&(l=0);const c=n.animationLast,u=n.getAnimationTime();let m=u,g=t;n.reverse&&(m=n.animation.duration-m,g=null);const w=n.animation.timelines,M=w.length;if(d==0&&l==1||o==f.MixBlend.add)for(let k=0;k<M;k++){f.Utils.webkit602BugfixHelper(l,o);const p=w[k];p instanceof pt?this.applyAttachmentTimeline(p,s,m,o,!0):p.apply(s,c,m,g,l,o,f.MixDirection.mixIn)}else{const k=n.timelineMode,p=n.shortestRotation,S=!p&&n.timelinesRotation.length!=M<<1;S&&(n.timelinesRotation.length=M<<1);for(let y=0;y<M;y++){const x=w[y],B=k[y]==le?o:f.MixBlend.setup;!p&&x instanceof Bt?this.applyRotateTimeline(x,s,m,l,B,n.timelinesRotation,y<<1,S):x instanceof pt?this.applyAttachmentTimeline(x,s,m,o,!0):(f.Utils.webkit602BugfixHelper(l,o),x.apply(s,c,m,g,l,B,f.MixDirection.mixIn))}}this.queueEvents(n,u),t.length=0,n.nextAnimationLast=u,n.nextTrackLast=n.trackTime}const a=this.unkeyedState+Ue,r=s.slots;for(let d=0,h=s.slots.length;d<h;d++){const n=r[d];if(n.attachmentState==a){const o=n.data.attachmentName;n.setAttachment(o?s.getAttachment(n.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(s,t,i){const e=s.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,i);let a=0;s.mixDuration==0?(a=1,i==f.MixBlend.first&&(i=f.MixBlend.setup)):(a=s.mixTime/s.mixDuration,a>1&&(a=1),i!=f.MixBlend.first&&(i=e.mixBlend));const r=a<e.attachmentThreshold,d=a<e.drawOrderThreshold,h=e.animation.timelines,n=h.length,o=e.alpha*s.interruptAlpha,l=o*(1-a),c=e.animationLast,u=e.getAnimationTime();let m=u,g=null;if(e.reverse?m=e.animation.duration-m:a<e.eventThreshold&&(g=this.events),i==f.MixBlend.add)for(let w=0;w<n;w++)h[w].apply(t,c,m,g,l,i,f.MixDirection.mixOut);else{const w=e.timelineMode,M=e.timelineHoldMix,k=e.shortestRotation,p=!k&&e.timelinesRotation.length!=n<<1;p&&(e.timelinesRotation.length=n<<1),e.totalAlpha=0;for(let S=0;S<n;S++){const y=h[S];let x=f.MixDirection.mixOut,B,A=0;switch(w[S]){case le:if(!d&&y instanceof xt)continue;B=i,A=l;break;case Fe:B=f.MixBlend.setup,A=l;break;case Xe:B=i,A=o;break;case he:B=f.MixBlend.setup,A=o;break;default:B=f.MixBlend.setup;const b=M[S];A=o*Math.max(0,1-b.mixTime/b.mixDuration);break}e.totalAlpha+=A,!k&&y instanceof Bt?this.applyRotateTimeline(y,t,m,A,B,e.timelinesRotation,S<<1,p):y instanceof pt?this.applyAttachmentTimeline(y,t,m,B,r):(f.Utils.webkit602BugfixHelper(A,i),d&&y instanceof xt&&B==f.MixBlend.setup&&(x=f.MixDirection.mixIn),y.apply(t,c,m,g,A,B,x))}}return s.mixDuration>0&&this.queueEvents(e,u),this.events.length=0,e.nextAnimationLast=u,e.nextTrackLast=e.trackTime,a}applyAttachmentTimeline(s,t,i,e,a){const r=t.slots[s.slotIndex];r.bone.active&&(i<s.frames[0]?(e==f.MixBlend.setup||e==f.MixBlend.first)&&this.setAttachment(t,r,r.data.attachmentName,a):this.setAttachment(t,r,s.attachmentNames[_.search1(s.frames,i)],a),r.attachmentState<=this.unkeyedState&&(r.attachmentState=this.unkeyedState+Ue))}setAttachment(s,t,i,e){t.setAttachment(i?s.getAttachment(t.data.index,i):null),e&&(t.attachmentState=this.unkeyedState+Qe)}applyRotateTimeline(s,t,i,e,a,r,d,h){if(h&&(r[d]=0),e==1){s.apply(t,0,i,null,1,a,f.MixDirection.mixIn);return}const n=t.bones[s.boneIndex];if(!n.active)return;const o=s.frames;let l=0,c=0;if(i<o[0])switch(a){case f.MixBlend.setup:n.rotation=n.data.rotation;default:return;case f.MixBlend.first:l=n.rotation,c=n.data.rotation}else l=a==f.MixBlend.setup?n.data.rotation:n.rotation,c=n.data.rotation+s.getCurveValue(i);let u=0,m=c-l;if(m-=(16384-(16384.499999999996-m/360|0))*360,m==0)u=r[d];else{let g=0,w=0;h?(g=0,w=m):(g=r[d],w=r[d+1]);const M=m>0;let k=g>=0;f.MathUtils.signum(w)!=f.MathUtils.signum(m)&&Math.abs(w)<=90&&(Math.abs(g)>180&&(g+=360*f.MathUtils.signum(g)),k=M),u=m+g-g%360,k!=M&&(u+=360*f.MathUtils.signum(g)),r[d]=u}r[d+1]=m,n.rotation=l+u*e}queueEvents(s,t){const i=s.animationStart,e=s.animationEnd,a=e-i,r=s.trackLast%a,d=this.events;let h=0;const n=d.length;for(;h<n;h++){const l=d[h];if(l.time<r)break;l.time>e||this.queue.event(s,l)}let o=!1;for(s.loop?o=a==0||r>s.trackTime%a:o=t>=e&&s.animationLast<e,o&&this.queue.complete(s);h<n;h++){const l=d[h];l.time<i||this.queue.event(s,l)}}clearTracks(){const s=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,i=this.tracks.length;t<i;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=s,this.queue.drain()}clearTrack(s){if(s>=this.tracks.length)return;const t=this.tracks[s];if(!t)return;this.queue.end(t),this.clearNext(t);let i=t;for(;;){const e=i.mixingFrom;if(!e)break;this.queue.end(e),i.mixingFrom=null,i.mixingTo=null,i=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(s,t,i){const e=this.expandToIndex(s);this.tracks[s]=t,t.previous=null,e&&(i&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(s,t,i=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(s,e,i)}setAnimationWith(s,t,i=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,a=this.expandToIndex(s);a&&(a.nextTrackLast==-1?(this.tracks[s]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.clearNext(a),a=a.mixingFrom,e=!1):this.clearNext(a));const r=this.trackEntry(s,t,i,a);return this.setCurrent(s,r,e),this.queue.drain(),r}addAnimation(s,t,i=!1,e=0){const a=this.data.skeletonData.findAnimation(t);if(!a)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(s,a,i,e)}addAnimationWith(s,t,i=!1,e=0){if(!t)throw new Error("animation cannot be null.");let a=this.expandToIndex(s);if(a)for(;a.next;)a=a.next;const r=this.trackEntry(s,t,i,a);return a?(a.next=r,r.previous=a,e<=0&&(e+=a.getTrackComplete()-r.mixDuration)):(this.setCurrent(s,r,!0),this.queue.drain()),r.delay=e,r}setEmptyAnimation(s,t=0){const i=this.setAnimationWith(s,rt.emptyAnimation(),!1);return i.mixDuration=t,i.trackEnd=t,i}addEmptyAnimation(s,t=0,i=0){const e=this.addAnimationWith(s,rt.emptyAnimation(),!1,i);return i<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(s=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let i=0,e=this.tracks.length;i<e;i++){const a=this.tracks[i];a&&this.setEmptyAnimation(a.trackIndex,s)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(s){return s<this.tracks.length?this.tracks[s]:(f.Utils.ensureArrayCapacity(this.tracks,s+1,null),this.tracks.length=s+1,null)}trackEntry(s,t,i,e){const a=this.trackEntryPool.obtain();return a.reset(),a.trackIndex=s,a.animation=t,a.loop=i,a.holdPrevious=!1,a.reverse=!1,a.shortestRotation=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=t.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.mixTime=0,a.mixDuration=e?this.data.getMix(e.animation,t):0,a.interruptAlpha=1,a.totalAlpha=0,a.mixBlend=f.MixBlend.replace,a}clearNext(s){let t=s.next;for(;t;)this.queue.dispose(t),t=t.next;s.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const s=this.tracks;for(let t=0,i=s.length;t<i;t++){let e=s[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=f.MixBlend.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(s){const t=s.mixingTo,i=s.animation.timelines,e=s.animation.timelines.length,a=s.timelineMode;a.length=e;const r=s.timelineHoldMix;r.length=0;const d=this.propertyIDs;if(t&&t.holdPrevious){for(let h=0;h<e;h++)a[h]=d.addAll(i[h].getPropertyIds())?he:Xe;return}t:for(let h=0;h<e;h++){const n=i[h],o=n.getPropertyIds();if(!d.addAll(o))a[h]=le;else if(!t||n instanceof pt||n instanceof xt||n instanceof At||!t.animation.hasTimeline(o))a[h]=Fe;else{for(let l=t.mixingTo;l;l=l.mixingTo)if(!l.animation.hasTimeline(o)){if(s.mixDuration>0){a[h]=Je,r[h]=l;continue t}break}a[h]=he}}}getCurrent(s){return s>=this.tracks.length?null:this.tracks[s]}addListener(s){if(!s)throw new Error("listener cannot be null.");this.listeners.push(s)}removeListener(s){const t=this.listeners.indexOf(s);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(s,t,i){rt.deprecatedWarning1||(rt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(s,t,i)}addAnimationByName(s,t,i,e){rt.deprecatedWarning2||(rt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(s,t,i,e)}hasAnimation(s){return this.data.skeletonData.findAnimation(s)!==null}hasAnimationByName(s){return rt.deprecatedWarning3||(rt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(s)}};let Mt=rt;Mt._emptyAnimation=new Xt("<empty>",[],0),Mt.deprecatedWarning1=!1,Mt.deprecatedWarning2=!1,Mt.deprecatedWarning3=!1;const lt=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=f.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return lt.deprecatedWarning1||(lt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){lt.deprecatedWarning1||(lt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return lt.deprecatedWarning2||(lt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){lt.deprecatedWarning2||(lt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Et=lt;Et.deprecatedWarning1=!1,Et.deprecatedWarning2=!1;class Te{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(K.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(K.interrupt),this.objects.push(t)}end(t){this.objects.push(K.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(K.dispose),this.objects.push(t)}complete(t){this.objects.push(K.complete),this.objects.push(t)}event(t,i){this.objects.push(K.event),this.objects.push(t),this.objects.push(i)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,i=this.animState.listeners;for(let e=0;e<t.length;e+=2){const a=t[e],r=t[e+1];switch(a){case K.start:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<i.length;h++){const n=i[h];n.start&&n.start(r)}break;case K.interrupt:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<i.length;h++){const n=i[h];n.interrupt&&n.interrupt(r)}break;case K.end:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<i.length;h++){const n=i[h];n.end&&n.end(r)}case K.dispose:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<i.length;h++){const n=i[h];n.dispose&&n.dispose(r)}this.animState.trackEntryPool.free(r);break;case K.complete:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<i.length;h++){const n=i[h];n.complete&&n.complete(r)}break;case K.event:const d=t[e+++2];r.listener&&r.listener.event&&r.listener.event(r,d);for(let h=0;h<i.length;h++){const n=i[h];n.event&&n.event(r,d)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var K=(s=>(s[s.start=0]="start",s[s.interrupt=1]="interrupt",s[s.end=2]="end",s[s.dispose=3]="dispose",s[s.complete=4]="complete",s[s.event=5]="event",s))(K||{});class Ke{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,i){}}const le=0,Fe=1,Xe=2,he=3,Je=4,Ue=1,Qe=2;class Ee{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,i,e){const a=this.skeletonData.findAnimation(t);if(!a)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(i);if(!r)throw new Error(`Animation not found: ${i}`);this.setMixWith(a,r,e)}setMixWith(t,i,e){if(!t)throw new Error("from cannot be null.");if(!i)throw new Error("to cannot be null.");const a=`${t.name}.${i.name}`;this.animationToMixTime[a]=e}getMix(t,i){const e=`${t.name}.${i.name}`,a=this.animationToMixTime[e];return a===void 0?this.defaultMix:a}}class Ze{constructor(t){this.atlas=t}loadSequence(t,i,e){const a=e.regions;for(let r=0,d=a.length;r<d;r++){const h=e.getPath(i,r),n=this.atlas.findRegion(h);if(n==null)throw new Error(`Region not found in atlas: ${h} (sequence: ${t})`);a[r]=n,a[r].renderObject=a[r]}}newRegionAttachment(t,i,e,a){const r=new q(i,e);if(a!=null)this.loadSequence(i,e,a);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (region attachment: ${i})`);d.renderObject=d,r.region=d}return r}newMeshAttachment(t,i,e,a){const r=new ft(i,e);if(a!=null)this.loadSequence(i,e,a);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${i})`);d.renderObject=d,r.region=d}return r}newBoundingBoxAttachment(t,i){return new bt(i)}newPathAttachment(t,i){return new gt(i)}newPointAttachment(t,i){return new vt(i)}newClippingAttachment(t,i){return new Yt(i)}}class ce{constructor(t,i,e){if(this.matrix=new He.Matrix,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!i)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=i,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,i,e,a,r,d,h){this.ax=t,this.ay=i,this.arotation=e,this.ascaleX=a,this.ascaleY=r,this.ashearX=d,this.ashearY=h;const n=this.parent,o=this.matrix,l=this.skeleton.scaleX,c=f.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!n){const M=this.skeleton,k=e+90+h;o.a=f.MathUtils.cosDeg(e+d)*a*l,o.c=f.MathUtils.cosDeg(k)*r*l,o.b=f.MathUtils.sinDeg(e+d)*a*c,o.d=f.MathUtils.sinDeg(k)*r*c,o.tx=t*l+M.x,o.ty=i*c+M.y;return}let u=n.matrix.a,m=n.matrix.c,g=n.matrix.b,w=n.matrix.d;switch(o.tx=u*t+m*i+n.matrix.tx,o.ty=g*t+w*i+n.matrix.ty,this.data.transformMode){case f.TransformMode.Normal:{const M=e+90+h,k=f.MathUtils.cosDeg(e+d)*a,p=f.MathUtils.cosDeg(M)*r,S=f.MathUtils.sinDeg(e+d)*a,y=f.MathUtils.sinDeg(M)*r;o.a=u*k+m*S,o.c=u*p+m*y,o.b=g*k+w*S,o.d=g*p+w*y;return}case f.TransformMode.OnlyTranslation:{const M=e+90+h;o.a=f.MathUtils.cosDeg(e+d)*a,o.c=f.MathUtils.cosDeg(M)*r,o.b=f.MathUtils.sinDeg(e+d)*a,o.d=f.MathUtils.sinDeg(M)*r;break}case f.TransformMode.NoRotationOrReflection:{let M=u*u+g*g,k=0;M>1e-4?(M=Math.abs(u*w-m*g)/M,u/=l,g/=c,m=g*M,w=u*M,k=Math.atan2(g,u)*f.MathUtils.radDeg):(u=0,g=0,k=90-Math.atan2(w,m)*f.MathUtils.radDeg);const p=e+d-k,S=e+h-k+90,y=f.MathUtils.cosDeg(p)*a,x=f.MathUtils.cosDeg(S)*r,B=f.MathUtils.sinDeg(p)*a,A=f.MathUtils.sinDeg(S)*r;o.a=u*y-m*B,o.c=u*x-m*A,o.b=g*y+w*B,o.d=g*x+w*A;break}case f.TransformMode.NoScale:case f.TransformMode.NoScaleOrReflection:{const M=f.MathUtils.cosDeg(e),k=f.MathUtils.sinDeg(e);let p=(u*M+m*k)/l,S=(g*M+w*k)/c,y=Math.sqrt(p*p+S*S);y>1e-5&&(y=1/y),p*=y,S*=y,y=Math.sqrt(p*p+S*S),this.data.transformMode==f.TransformMode.NoScale&&u*w-m*g<0!=(l<0!=c<0)&&(y=-y);const x=Math.PI/2+Math.atan2(S,p),B=Math.cos(x)*y,A=Math.sin(x)*y,b=f.MathUtils.cosDeg(d)*a,I=f.MathUtils.cosDeg(90+h)*r,Y=f.MathUtils.sinDeg(d)*a,v=f.MathUtils.sinDeg(90+h)*r;o.a=p*b+B*Y,o.c=p*I+B*v,o.b=S*b+A*Y,o.d=S*I+A*v;break}}o.a*=l,o.c*=l,o.b*=c,o.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*f.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*f.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,i=this.matrix;if(!t){this.ax=i.tx-this.skeleton.x,this.ay=i.ty-this.skeleton.y,this.arotation=Math.atan2(i.b,i.a)*f.MathUtils.radDeg,this.ascaleX=Math.sqrt(i.a*i.a+i.b*i.b),this.ascaleY=Math.sqrt(i.c*i.c+i.d*i.d),this.ashearX=0,this.ashearY=Math.atan2(i.a*i.c+i.b*i.d,i.a*i.d-i.b*i.c)*f.MathUtils.radDeg;return}const e=t.matrix,a=1/(e.a*e.d-e.b*e.c),r=i.tx-e.tx,d=i.ty-e.ty;this.ax=r*e.d*a-d*e.c*a,this.ay=d*e.a*a-r*e.b*a;const h=a*e.d,n=a*e.a,o=a*e.c,l=a*e.b,c=h*i.a-o*i.b,u=h*i.c-o*i.d,m=n*i.b-l*i.a,g=n*i.d-l*i.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+m*m),this.ascaleX>1e-4){const w=c*g-u*m;this.ascaleY=w/this.ascaleX,this.ashearY=Math.atan2(c*u+m*g,w)*f.MathUtils.radDeg,this.arotation=Math.atan2(m,c)*f.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+g*g),this.ashearY=0,this.arotation=90-Math.atan2(g,u)*f.MathUtils.radDeg}worldToLocal(t){const i=this.matrix,e=i.a,a=i.c,r=i.b,d=i.d,h=1/(e*d-a*r),n=t.x-i.tx,o=t.y-i.ty;return t.x=n*d*h-o*a*h,t.y=o*e*h-n*r*h,t}localToWorld(t){const i=this.matrix,e=t.x,a=t.y;return t.x=e*i.a+a*i.c+i.tx,t.y=e*i.b+a*i.d+i.ty,t}worldToLocalRotation(t){const i=f.MathUtils.sinDeg(t),e=f.MathUtils.cosDeg(t),a=this.matrix;return Math.atan2(a.a*i-a.b*e,a.d*e-a.c*i)*f.MathUtils.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const i=f.MathUtils.sinDeg(t),e=f.MathUtils.cosDeg(t),a=this.matrix;return Math.atan2(e*a.b+i*a.d,e*a.a+i*a.c)*f.MathUtils.radDeg}rotateWorld(t){const i=this.matrix,e=i.a,a=i.c,r=i.b,d=i.d,h=f.MathUtils.cosDeg(t),n=f.MathUtils.sinDeg(t);i.a=h*e-n*r,i.c=h*a-n*d,i.b=n*e+h*r,i.d=n*a+h*d}}class de{constructor(t,i,e){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=f.TransformMode.Normal,this.skinRequired=!1,this.color=new f.Color,t<0)throw new Error("index must be >= 0.");if(!i)throw new Error("name cannot be null.");this.index=t,this.name=i,this.parent=e}}class Rt{constructor(t,i,e){this.name=t,this.order=i,this.skinRequired=e}}class me{constructor(t,i){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!i)throw new Error("data cannot be null.");this.time=t,this.data=i}}class ue{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class Re{constructor(t,i){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!i)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let a=0;a<t.bones.length;a++){const r=i.findBone(t.bones[a].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[a].name}`);this.bones.push(r)}const e=i.findBone(t.target.name);if(!e)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=e}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,i=this.bones;switch(i.length){case 1:this.apply1(i[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(i[0],i[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,i,e,a,r,d,h){const n=t.parent.matrix;if(!n)throw new Error("IK bone must have parent.");const o=n.a;let l=n.c;const c=n.b;let u=n.d,m=-t.ashearX-t.arotation,g=0,w=0;const M=t.skeleton.scaleX,k=f.settings.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case f.TransformMode.OnlyTranslation:g=i-t.worldX,w=e-t.worldY,f.settings.yDown&&(w=-w);break;case f.TransformMode.NoRotationOrReflection:const y=Math.abs(o*u-l*c)/(o*o+c*c),x=o/M,B=c/k;l=-B*y*M,u=x*y*k,m+=Math.atan2(B,x)*f.MathUtils.radDeg;default:const A=i-n.tx,b=e-n.ty,I=o*u-l*c;g=(A*u-b*l)/I-t.ax,w=(b*o-A*c)/I-t.ay}m+=Math.atan2(w,g)*f.MathUtils.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=t.ascaleX,S=t.ascaleY;if(a||r){switch(t.data.transformMode){case f.TransformMode.NoScale:case f.TransformMode.NoScaleOrReflection:g=i-t.worldX,w=e-t.worldY}const y=t.data.length*p,x=Math.sqrt(g*g+w*w);if(a&&x<y||r&&x>y&&y>1e-4){const B=(x/y-1)*h+1;p*=B,d&&(S*=B)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,p,S,t.ashearX,t.ashearY)}apply2(t,i,e,a,r,d,h,n,o){const l=t.ax,c=t.ay;let u=t.ascaleX,m=t.ascaleY,g=u,w=m,M=i.ascaleX;const k=t.matrix;let p=0,S=0,y=0;u<0?(u=-u,p=180,y=-1):(p=0,y=1),m<0&&(m=-m,y=-y),M<0?(M=-M,S=180):S=0;const x=i.ax;let B=0,A=0,b=0,I=k.a,Y=k.c,v=k.b,T=k.d;const U=Math.abs(u-m)<=1e-4;!U||d?(B=0,A=I*x+k.tx,b=v*x+k.ty):(B=i.ay,A=I*x+Y*B+k.tx,b=v*x+T*B+k.ty);const X=t.parent.matrix;if(!X)throw new Error("IK parent must itself have a parent.");I=X.a,Y=X.c,v=X.b,T=X.d;const W=1/(I*T-Y*v);let R=A-X.tx,E=b-X.ty;const D=(R*T-E*Y)*W-l,j=(E*I-R*v)*W-c,z=Math.sqrt(D*D+j*j);let H=i.data.length*M,P,V;if(z<1e-4){this.apply1(t,e,a,!1,d,!1,o),i.updateWorldTransformWith(x,B,0,i.ascaleX,i.ascaleY,i.ashearX,i.ashearY);return}R=e-X.tx,E=a-X.ty;let O=(R*T-E*Y)*W-l,Q=(E*I-R*v)*W-c,it=O*O+Q*Q;if(n!=0){n*=u*(M+1)*.5;const J=Math.sqrt(it),dt=J-z-H*u+n;if(dt>0){let mt=Math.min(1,dt/(n*2))-1;mt=(dt-n*(1-mt*mt))/J,O-=mt*O,Q-=mt*Q,it=O*O+Q*Q}}t:if(U){H*=u;let J=(it-z*z-H*H)/(2*z*H);J<-1?(J=-1,V=Math.PI*r):J>1?(J=1,V=0,d&&(I=(Math.sqrt(it)/(z+H)-1)*o+1,g*=I,h&&(w*=I))):V=Math.acos(J)*r,I=z+H*J,Y=H*Math.sin(V),P=Math.atan2(Q*I-O*Y,O*I+Q*Y)}else{I=u*H,Y=m*H;const J=I*I,dt=Y*Y,mt=Math.atan2(Q,O);v=dt*z*z+J*it-J*dt;const Pt=-2*dt*z,We=dt-J;if(T=Pt*Pt-4*We*v,T>=0){let kt=Math.sqrt(T);Pt<0&&(kt=-kt),kt=-(Pt+kt)*.5;const je=kt/We,Ge=v/kt,St=Math.abs(je)<Math.abs(Ge)?je:Ge;if(St*St<=it){E=Math.sqrt(it-St*St)*r,P=mt-Math.atan2(E,St),V=Math.atan2(E/m,(St-z)/u);break t}}let Ne=f.MathUtils.PI,Vt=z-I,Ae=Vt*Vt,Oe=0,ze=0,$t=z+I,Ce=$t*$t,_e=0;v=-I*z/(J-dt),v>=-1&&v<=1&&(v=Math.acos(v),R=I*Math.cos(v)+z,E=Y*Math.sin(v),T=R*R+E*E,T<Ae&&(Ne=v,Ae=T,Vt=R,Oe=E),T>Ce&&(ze=v,Ce=T,$t=R,_e=E)),it<=(Ae+Ce)*.5?(P=mt-Math.atan2(Oe*r,Vt),V=Ne*r):(P=mt-Math.atan2(_e*r,$t),V=ze*r)}const Le=Math.atan2(B,x)*y;let It=t.arotation;P=(P-Le)*f.MathUtils.radDeg+p-It,P>180?P-=360:P<-180&&(P+=360),t.updateWorldTransformWith(l,c,It+P*o,g,w,0,0),It=i.arotation,V=((V+Le)*f.MathUtils.radDeg-i.ashearX)*y+S-It,V>180?V-=360:V<-180&&(V+=360),i.updateWorldTransformWith(x,B,It+V*o,i.ascaleX,i.ascaleY,i.ashearX,i.ashearY)}}class fe extends Rt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class ge extends Rt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=f.PositionMode.Fixed,this.spacingMode=G.Fixed,this.rotateMode=f.RotateMode.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var G=(s=>(s[s.Length=0]="Length",s[s.Fixed=1]="Fixed",s[s.Percent=2]="Percent",s[s.Proportional=3]="Proportional",s))(G||{});const ht=class{constructor(s,t){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!s)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=s,this.bones=new Array;for(let e=0,a=s.bones.length;e<a;e++){const r=t.findBone(s.bones[e].name);if(!r)throw new Error(`Couldn't find bone ${s.bones[e].name}.`);this.bones.push(r)}const i=t.findSlot(s.target.name);if(!i)throw new Error(`Couldn't find target bone ${s.target.name}`);this.target=i,this.position=s.position,this.spacing=s.spacing,this.mixRotate=s.mixRotate,this.mixX=s.mixX,this.mixY=s.mixY}isActive(){return this.active}update(){const s=this.target.getAttachment();if(!(s instanceof gt))return;const t=this.mixRotate,i=this.mixX,e=this.mixY;if(t==0&&i==0&&e==0)return;const a=this.data,r=a.rotateMode==f.RotateMode.Tangent,d=a.rotateMode==f.RotateMode.ChainScale,h=this.bones,n=h.length,o=r?n:n+1,l=f.Utils.setArraySize(this.spaces,o),c=d?this.lengths=f.Utils.setArraySize(this.lengths,n):[],u=this.spacing;switch(a.spacingMode){case G.Percent:if(d)for(let y=0,x=o-1;y<x;y++){const B=h[y],A=B.data.length;if(A<ht.epsilon)c[y]=0;else{const b=A*B.matrix.a,I=A*B.matrix.b;c[y]=Math.sqrt(b*b+I*I)}}f.Utils.arrayFill(l,1,o,u);break;case G.Proportional:let p=0;for(let y=0,x=o-1;y<x;){const B=h[y],A=B.data.length;if(A<ht.epsilon)d&&(c[y]=0),l[++y]=u;else{const b=A*B.matrix.a,I=A*B.matrix.b,Y=Math.sqrt(b*b+I*I);d&&(c[y]=Y),l[++y]=Y,p+=Y}}if(p>0){p=o/p*u;for(let y=1;y<o;y++)l[y]*=p}break;default:const S=a.spacingMode==G.Length;for(let y=0,x=o-1;y<x;){const B=h[y],A=B.data.length;if(A<ht.epsilon)d&&(c[y]=0),l[++y]=u;else{const b=A*B.matrix.a,I=A*B.matrix.b,Y=Math.sqrt(b*b+I*I);d&&(c[y]=Y),l[++y]=(S?A+u:u)*Y/A}}}const m=this.computeWorldPositions(s,o,r);let g=m[0],w=m[1],M=a.offsetRotation,k=!1;if(M==0)k=a.rotateMode==f.RotateMode.Chain;else{k=!1;const p=this.target.bone.matrix;M*=p.a*p.d-p.b*p.c>0?f.MathUtils.degRad:-f.MathUtils.degRad}for(let p=0,S=3;p<n;p++,S+=3){const y=h[p],x=y.matrix;x.tx+=(g-x.tx)*i,x.ty+=(w-x.ty)*e;const B=m[S],A=m[S+1],b=B-g,I=A-w;if(d){const Y=c[p];if(Y!=0){const v=(Math.sqrt(b*b+I*I)/Y-1)*t+1;x.a*=v,x.b*=v}}if(g=B,w=A,t>0){const Y=x.a,v=x.c,T=x.b,U=x.d;let X=0,W=0,R=0;if(r?X=m[S-1]:l[p+1]==0?X=m[S+2]:X=Math.atan2(I,b),X-=Math.atan2(T,Y),k){W=Math.cos(X),R=Math.sin(X);const E=y.data.length;g+=(E*(W*Y-R*T)-b)*t,w+=(E*(R*Y+W*T)-I)*t}else X+=M;X>f.MathUtils.PI?X-=f.MathUtils.PI2:X<-f.MathUtils.PI&&(X+=f.MathUtils.PI2),X*=t,W=Math.cos(X),R=Math.sin(X),x.a=W*Y-R*T,x.c=W*v-R*U,x.b=R*Y+W*T,x.d=R*v+W*U}y.updateAppliedTransform()}}computeWorldPositions(s,t,i){const e=this.target;let a=this.position;const r=this.spaces,d=f.Utils.setArraySize(this.positions,t*3+2);let h=this.world;const n=s.closed;let o=s.worldVerticesLength,l=o/6,c=ht.NONE;if(!s.constantSpeed){const E=s.lengths;l-=n?1:2;const D=E[l];this.data.positionMode==f.PositionMode.Percent&&(a*=D);let j;switch(this.data.spacingMode){case G.Percent:j=D;break;case G.Proportional:j=D/t;break;default:j=1}h=f.Utils.setArraySize(this.world,8);for(let z=0,H=0,P=0;z<t;z++,H+=3){const V=r[z]*j;a+=V;let O=a;if(n)O%=D,O<0&&(O+=D),P=0;else if(O<0){c!=ht.BEFORE&&(c=ht.BEFORE,s.computeWorldVertices(e,2,4,h,0,2)),this.addBeforePosition(O,h,0,d,H);continue}else if(O>D){c!=ht.AFTER&&(c=ht.AFTER,s.computeWorldVertices(e,o-6,4,h,0,2)),this.addAfterPosition(O-D,h,0,d,H);continue}for(;;P++){const Q=E[P];if(!(O>Q)){if(P==0)O/=Q;else{const it=E[P-1];O=(O-it)/(Q-it)}break}}P!=c&&(c=P,n&&P==l?(s.computeWorldVertices(e,o-4,4,h,0,2),s.computeWorldVertices(e,0,4,h,4,2)):s.computeWorldVertices(e,P*6+2,8,h,0,2)),this.addCurvePosition(O,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],d,H,i||z>0&&V==0)}return d}n?(o+=2,h=f.Utils.setArraySize(this.world,o),s.computeWorldVertices(e,2,o-4,h,0,2),s.computeWorldVertices(e,0,2,h,o-4,2),h[o-2]=h[0],h[o-1]=h[1]):(l--,o-=4,h=f.Utils.setArraySize(this.world,o),s.computeWorldVertices(e,2,o,h,0,2));const u=f.Utils.setArraySize(this.curves,l);let m=0,g=h[0],w=h[1],M=0,k=0,p=0,S=0,y=0,x=0,B=0,A=0,b=0,I=0,Y=0,v=0,T=0,U=0;for(let E=0,D=2;E<l;E++,D+=6)M=h[D],k=h[D+1],p=h[D+2],S=h[D+3],y=h[D+4],x=h[D+5],B=(g-M*2+p)*.1875,A=(w-k*2+S)*.1875,b=((M-p)*3-g+y)*.09375,I=((k-S)*3-w+x)*.09375,Y=B*2+b,v=A*2+I,T=(M-g)*.75+B+b*.16666667,U=(k-w)*.75+A+I*.16666667,m+=Math.sqrt(T*T+U*U),T+=Y,U+=v,Y+=b,v+=I,m+=Math.sqrt(T*T+U*U),T+=Y,U+=v,m+=Math.sqrt(T*T+U*U),T+=Y+b,U+=v+I,m+=Math.sqrt(T*T+U*U),u[E]=m,g=y,w=x;this.data.positionMode==f.PositionMode.Percent&&(a*=m);let X;switch(this.data.spacingMode){case G.Percent:X=m;break;case G.Proportional:X=m/t;break;default:X=1}const W=this.segments;let R=0;for(let E=0,D=0,j=0,z=0;E<t;E++,D+=3){const H=r[E]*X;a+=H;let P=a;if(n)P%=m,P<0&&(P+=m),j=0;else if(P<0){this.addBeforePosition(P,h,0,d,D);continue}else if(P>m){this.addAfterPosition(P-m,h,o-4,d,D);continue}for(;;j++){const V=u[j];if(!(P>V)){if(j==0)P/=V;else{const O=u[j-1];P=(P-O)/(V-O)}break}}if(j!=c){c=j;let V=j*6;for(g=h[V],w=h[V+1],M=h[V+2],k=h[V+3],p=h[V+4],S=h[V+5],y=h[V+6],x=h[V+7],B=(g-M*2+p)*.03,A=(w-k*2+S)*.03,b=((M-p)*3-g+y)*.006,I=((k-S)*3-w+x)*.006,Y=B*2+b,v=A*2+I,T=(M-g)*.3+B+b*.16666667,U=(k-w)*.3+A+I*.16666667,R=Math.sqrt(T*T+U*U),W[0]=R,V=1;V<8;V++)T+=Y,U+=v,Y+=b,v+=I,R+=Math.sqrt(T*T+U*U),W[V]=R;T+=Y,U+=v,R+=Math.sqrt(T*T+U*U),W[8]=R,T+=Y+b,U+=v+I,R+=Math.sqrt(T*T+U*U),W[9]=R,z=0}for(P*=R;;z++){const V=W[z];if(!(P>V)){if(z==0)P/=V;else{const O=W[z-1];P=z+(P-O)/(V-O)}break}}this.addCurvePosition(P*.1,g,w,M,k,p,S,y,x,d,D,i||E>0&&H==0)}return d}addBeforePosition(s,t,i,e,a){const r=t[i],d=t[i+1],h=t[i+2]-r,n=t[i+3]-d,o=Math.atan2(n,h);e[a]=r+s*Math.cos(o),e[a+1]=d+s*Math.sin(o),e[a+2]=o}addAfterPosition(s,t,i,e,a){const r=t[i+2],d=t[i+3],h=r-t[i],n=d-t[i+1],o=Math.atan2(n,h);e[a]=r+s*Math.cos(o),e[a+1]=d+s*Math.sin(o),e[a+2]=o}addCurvePosition(s,t,i,e,a,r,d,h,n,o,l,c){if(s==0||isNaN(s)){o[l]=t,o[l+1]=i,o[l+2]=Math.atan2(a-i,e-t);return}const u=s*s,m=u*s,g=1-s,w=g*g,M=w*g,k=g*s,p=k*3,S=g*p,y=p*s,x=t*M+e*S+r*y+h*m,B=i*M+a*S+d*y+n*m;o[l]=x,o[l+1]=B,c&&(s<.001?o[l+2]=Math.atan2(a-i,e-t):o[l+2]=Math.atan2(B-(i*w+a*k*2+d*u),x-(t*w+e*k*2+r*u)))}};let yt=ht;yt.NONE=-1,yt.BEFORE=-2,yt.AFTER=-3,yt.epsilon=1e-5;class De{constructor(t,i){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!i)throw new Error("bone cannot be null.");this.data=t,this.bone=i,this.color=new f.Color,this.darkColor=t.darkColor?new f.Color:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof Z)||!(this.attachment instanceof Z)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class Pe{constructor(t,i){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new f.Vector2,this.active=!1,!t)throw new Error("data cannot be null.");if(!i)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let a=0;a<t.bones.length;a++){const r=i.findBone(t.bones[a].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[a].name}.`);this.bones.push(r)}const e=i.findBone(t.target.name);if(!e)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=e}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,i=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=i!=0||e!=0,n=this.target,o=n.matrix,l=o.a,c=o.c,u=o.b,m=o.d,g=l*m-c*u>0?f.MathUtils.degRad:-f.MathUtils.degRad,w=this.data.offsetRotation*g,M=this.data.offsetShearY*g,k=this.bones;for(let p=0,S=k.length;p<S;p++){const y=k[p],x=y.matrix;if(t!=0){const B=x.a,A=x.c,b=x.b,I=x.d;let Y=Math.atan2(u,l)-Math.atan2(b,B)+w;Y>f.MathUtils.PI?Y-=f.MathUtils.PI2:Y<-f.MathUtils.PI&&(Y+=f.MathUtils.PI2),Y*=t;const v=Math.cos(Y),T=Math.sin(Y);x.a=v*B-T*b,x.c=v*A-T*I,x.b=T*B+v*b,x.d=T*A+v*I}if(h){const B=this.temp;n.localToWorld(B.set(this.data.offsetX,this.data.offsetY)),x.tx+=(B.x-x.tx)*i,x.ty+=(B.y-x.ty)*e}if(a!=0){let B=Math.sqrt(x.a*x.a+x.b*x.b);B!=0&&(B=(B+(Math.sqrt(l*l+u*u)-B+this.data.offsetScaleX)*a)/B),x.a*=B,x.b*=B}if(r!=0){let B=Math.sqrt(x.c*x.c+x.d*x.d);B!=0&&(B=(B+(Math.sqrt(c*c+m*m)-B+this.data.offsetScaleY)*r)/B),x.c*=B,x.d*=B}if(d>0){const B=x.c,A=x.d,b=Math.atan2(A,B);let I=Math.atan2(m,c)-Math.atan2(u,l)-(b-Math.atan2(x.b,x.a));I>f.MathUtils.PI?I-=f.MathUtils.PI2:I<-f.MathUtils.PI&&(I+=f.MathUtils.PI2),I=b+(I+M)*d;const Y=Math.sqrt(B*B+A*A);x.c=Math.cos(I)*Y,x.d=Math.sin(I)*Y}y.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,i=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=i!=0||e!=0,n=this.target,o=n.matrix,l=o.a,c=o.c,u=o.b,m=o.d,g=l*m-c*u>0?f.MathUtils.degRad:-f.MathUtils.degRad,w=this.data.offsetRotation*g,M=this.data.offsetShearY*g,k=this.bones;for(let p=0,S=k.length;p<S;p++){const y=k[p],x=y.matrix;if(t!=0){const B=x.a,A=x.c,b=x.b,I=x.d;let Y=Math.atan2(u,l)+w;Y>f.MathUtils.PI?Y-=f.MathUtils.PI2:Y<-f.MathUtils.PI&&(Y+=f.MathUtils.PI2),Y*=t;const v=Math.cos(Y),T=Math.sin(Y);x.a=v*B-T*b,x.c=v*A-T*I,x.b=T*B+v*b,x.d=T*A+v*I}if(h){const B=this.temp;n.localToWorld(B.set(this.data.offsetX,this.data.offsetY)),x.tx+=B.x*i,x.ty+=B.y*e}if(a!=0){const B=(Math.sqrt(l*l+u*u)-1+this.data.offsetScaleX)*a+1;x.a*=B,x.b*=B}if(r!=0){const B=(Math.sqrt(c*c+m*m)-1+this.data.offsetScaleY)*r+1;x.c*=B,x.d*=B}if(d>0){let B=Math.atan2(m,c)-Math.atan2(u,l);B>f.MathUtils.PI?B-=f.MathUtils.PI2:B<-f.MathUtils.PI&&(B+=f.MathUtils.PI2);const A=x.c,b=x.d;B=Math.atan2(b,A)+(B-f.MathUtils.PI/2+M)*d;const I=Math.sqrt(A*A+b*b);x.c=Math.cos(B)*I,x.d=Math.sin(B)*I}y.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,i=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=this.target,n=this.bones;for(let o=0,l=n.length;o<l;o++){const c=n[o];let u=c.arotation;if(t!=0){let p=h.arotation-u+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,u+=p*t}let m=c.ax,g=c.ay;m+=(h.ax-m+this.data.offsetX)*i,g+=(h.ay-g+this.data.offsetY)*e;let w=c.ascaleX,M=c.ascaleY;a!=0&&w!=0&&(w=(w+(h.ascaleX-w+this.data.offsetScaleX)*a)/w),r!=0&&M!=0&&(M=(M+(h.ascaleY-M+this.data.offsetScaleY)*r)/M);let k=c.ashearY;if(d!=0){let p=h.ashearY-k+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,k+=p*d}c.updateWorldTransformWith(m,g,u,w,M,c.ashearX,k)}}applyRelativeLocal(){const t=this.mixRotate,i=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=this.target,n=this.bones;for(let o=0,l=n.length;o<l;o++){const c=n[o],u=c.arotation+(h.arotation+this.data.offsetRotation)*t,m=c.ax+(h.ax+this.data.offsetX)*i,g=c.ay+(h.ay+this.data.offsetY)*e,w=c.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*a+1),M=c.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),k=c.ashearY+(h.ashearY+this.data.offsetShearY)*d;c.updateWorldTransformWith(m,g,u,w,M,c.ashearX,k)}}}const Ct=class{constructor(s){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!s)throw new Error("data cannot be null.");this.data=s,this.bones=new Array;for(let t=0;t<s.bones.length;t++){const i=s.bones[t];let e;if(!i.parent)e=new ce(i,this,null);else{const a=this.bones[i.parent.index];e=new ce(i,this,a),a.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<s.slots.length;t++){const i=s.slots[t],e=this.bones[i.boneData.index],a=new De(i,e);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let t=0;t<s.ikConstraints.length;t++){const i=s.ikConstraints[t];this.ikConstraints.push(new Re(i,this))}this.transformConstraints=new Array;for(let t=0;t<s.transformConstraints.length;t++){const i=s.transformConstraints[t];this.transformConstraints.push(new Pe(i,this))}this.pathConstraints=new Array;for(let t=0;t<s.pathConstraints.length;t++){const i=s.pathConstraints[t];this.pathConstraints.push(new yt(i,this))}this.color=new f.Color(1,1,1,1),this.updateCache()}updateCache(){const s=this._updateCache;s.length=0;const t=this.bones;for(let o=0,l=t.length;o<l;o++){const c=t[o];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){const o=this.skin.bones;for(let l=0,c=this.skin.bones.length;l<c;l++){let u=this.bones[o[l].index];do u.sorted=!1,u.active=!0,u=u.parent;while(u)}}const i=this.ikConstraints,e=this.transformConstraints,a=this.pathConstraints,r=i.length,d=e.length,h=a.length,n=r+d+h;t:for(let o=0;o<n;o++){for(let l=0;l<r;l++){const c=i[l];if(c.data.order==o){this.sortIkConstraint(c);continue t}}for(let l=0;l<d;l++){const c=e[l];if(c.data.order==o){this.sortTransformConstraint(c);continue t}}for(let l=0;l<h;l++){const c=a[l];if(c.data.order==o){this.sortPathConstraint(c);continue t}}}for(let o=0,l=t.length;o<l;o++)this.sortBone(t[o])}sortIkConstraint(s){if(s.active=s.target.isActive()&&(!s.data.skinRequired||this.skin&&f.Utils.contains(this.skin.constraints,s.data,!0)),!s.active)return;const t=s.target;this.sortBone(t);const i=s.bones,e=i[0];if(this.sortBone(e),i.length==1)this._updateCache.push(s),this.sortReset(e.children);else{const a=i[i.length-1];this.sortBone(a),this._updateCache.push(s),this.sortReset(e.children),a.sorted=!0}}sortPathConstraint(s){if(s.active=s.target.bone.isActive()&&(!s.data.skinRequired||this.skin&&f.Utils.contains(this.skin.constraints,s.data,!0)),!s.active)return;const t=s.target,i=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,i,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,i,e);for(let h=0,n=this.data.skins.length;h<n;h++)this.sortPathConstraintAttachment(this.data.skins[h],i,e);const a=t.getAttachment();a instanceof gt&&this.sortPathConstraintAttachmentWith(a,e);const r=s.bones,d=r.length;for(let h=0;h<d;h++)this.sortBone(r[h]);this._updateCache.push(s);for(let h=0;h<d;h++)this.sortReset(r[h].children);for(let h=0;h<d;h++)r[h].sorted=!0}sortTransformConstraint(s){if(s.active=s.target.isActive()&&(!s.data.skinRequired||this.skin&&f.Utils.contains(this.skin.constraints,s.data,!0)),!s.active)return;this.sortBone(s.target);const t=s.bones,i=t.length;if(s.data.local)for(let e=0;e<i;e++){const a=t[e];this.sortBone(a.parent),this.sortBone(a)}else for(let e=0;e<i;e++)this.sortBone(t[e]);this._updateCache.push(s);for(let e=0;e<i;e++)this.sortReset(t[e].children);for(let e=0;e<i;e++)t[e].sorted=!0}sortPathConstraintAttachment(s,t,i){const e=s.attachments[t];if(e)for(const a in e)this.sortPathConstraintAttachmentWith(e[a],i)}sortPathConstraintAttachmentWith(s,t){if(!(s instanceof gt))return;const i=s.bones;if(!i)this.sortBone(t);else{const e=this.bones;for(let a=0,r=i.length;a<r;){let d=i[a++];for(d+=a;a<d;)this.sortBone(e[i[a++]])}}}sortBone(s){if(!s||s.sorted)return;const t=s.parent;t&&this.sortBone(t),s.sorted=!0,this._updateCache.push(s)}sortReset(s){for(let t=0,i=s.length;t<i;t++){const e=s[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const s=this.bones;for(let i=0,e=s.length;i<e;i++){const a=s[i];a.ax=a.x,a.ay=a.y,a.arotation=a.rotation,a.ascaleX=a.scaleX,a.ascaleY=a.scaleY,a.ashearX=a.shearX,a.ashearY=a.shearY}const t=this._updateCache;for(let i=0,e=t.length;i<e;i++)t[i].update()}updateWorldTransformWith(s){const t=this.getRootBone(),i=s.matrix.a,e=s.matrix.c,a=s.matrix.b,r=s.matrix.d;t.matrix.tx=i*this.x+e*this.y+s.worldX,t.matrix.ty=a*this.x+r*this.y+s.worldY;const d=t.rotation+90+t.shearY,h=f.MathUtils.cosDeg(t.rotation+t.shearX)*t.scaleX,n=f.MathUtils.cosDeg(d)*t.scaleY,o=f.MathUtils.sinDeg(t.rotation+t.shearX)*t.scaleX,l=f.MathUtils.sinDeg(d)*t.scaleY,c=this.scaleX,u=f.settings.yDown?-this.scaleY:this.scaleY;t.matrix.a=(i*h+e*o)*c,t.matrix.c=(i*n+e*l)*c,t.matrix.b=(a*h+r*o)*u,t.matrix.d=(a*n+r*l)*u;const m=this._updateCache;for(let g=0,w=m.length;g<w;g++){const M=m[g];M!=t&&M.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const s=this.bones;for(let a=0,r=s.length;a<r;a++)s[a].setToSetupPose();const t=this.ikConstraints;for(let a=0,r=t.length;a<r;a++){const d=t[a];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const i=this.transformConstraints;for(let a=0,r=i.length;a<r;a++){const d=i[a],h=d.data;d.mixRotate=h.mixRotate,d.mixX=h.mixX,d.mixY=h.mixY,d.mixScaleX=h.mixScaleX,d.mixScaleY=h.mixScaleY,d.mixShearY=h.mixShearY}const e=this.pathConstraints;for(let a=0,r=e.length;a<r;a++){const d=e[a],h=d.data;d.position=h.position,d.spacing=h.spacing,d.mixRotate=h.mixRotate,d.mixX=h.mixX,d.mixY=h.mixY}}setSlotsToSetupPose(){const s=this.slots;f.Utils.arrayCopy(s,0,this.drawOrder,0,s.length);for(let t=0,i=s.length;t<i;t++)s[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(s){if(!s)throw new Error("boneName cannot be null.");const t=this.bones;for(let i=0,e=t.length;i<e;i++){const a=t[i];if(a.data.name==s)return a}return null}findBoneIndex(s){if(!s)throw new Error("boneName cannot be null.");const t=this.bones;for(let i=0,e=t.length;i<e;i++)if(t[i].data.name==s)return i;return-1}findSlot(s){if(!s)throw new Error("slotName cannot be null.");const t=this.slots;for(let i=0,e=t.length;i<e;i++){const a=t[i];if(a.data.name==s)return a}return null}findSlotIndex(s){if(!s)throw new Error("slotName cannot be null.");const t=this.slots;for(let i=0,e=t.length;i<e;i++)if(t[i].data.name==s)return i;return-1}setSkinByName(s){const t=this.data.findSkin(s);if(!t)throw new Error(`Skin not found: ${s}`);this.setSkin(t)}setSkin(s){if(s!=this.skin){if(s)if(this.skin)s.attachAll(this,this.skin);else{const t=this.slots;for(let i=0,e=t.length;i<e;i++){const a=t[i],r=a.data.attachmentName;if(r){const d=s.getAttachment(i,r);d&&a.setAttachment(d)}}}this.skin=s,this.updateCache()}}getAttachmentByName(s,t){const i=this.data.findSlot(s);if(!i)throw new Error(`Can't find slot with name ${s}`);return this.getAttachment(i.index,t)}getAttachment(s,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const i=this.skin.getAttachment(s,t);if(i)return i}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(s,t):null}setAttachment(s,t){if(!s)throw new Error("slotName cannot be null.");const i=this.slots;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.data.name==s){let d=null;if(t&&(d=this.getAttachment(e,t),!d))throw new Error(`Attachment not found: ${t}, for slot: ${s}`);r.setAttachment(d);return}}throw new Error(`Slot not found: ${s}`)}findIkConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let i=0,e=t.length;i<e;i++){const a=t[i];if(a.data.name==s)return a}return null}findTransformConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let i=0,e=t.length;i<e;i++){const a=t[i];if(a.data.name==s)return a}return null}findPathConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let i=0,e=t.length;i<e;i++){const a=t[i];if(a.data.name==s)return a}return null}getBoundsRect(){const s=new f.Vector2,t=new f.Vector2;return this.getBounds(s,t),{x:s.x,y:s.y,width:t.x,height:t.y}}getBounds(s,t,i=new Array(2)){if(!s)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let n=0,o=e.length;n<o;n++){const l=e[n];if(!l.bone.active)continue;let c=0,u=null;const m=l.getAttachment();if(m instanceof q)c=8,u=f.Utils.setArraySize(i,c,0),m.computeWorldVertices(l,u,0,2);else if(m instanceof ft){const g=m;c=g.worldVerticesLength,u=f.Utils.setArraySize(i,c,0),g.computeWorldVertices(l,0,c,u,0,2)}if(u)for(let g=0,w=u.length;g<w;g+=2){const M=u[g],k=u[g+1];a=Math.min(a,M),r=Math.min(r,k),d=Math.max(d,M),h=Math.max(h,k)}}s.set(a,r),t.set(d-a,h-r)}get flipX(){return this.scaleX==-1}set flipX(s){Ct.deprecatedWarning1||(Ct.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=s?1:-1}get flipY(){return this.scaleY==-1}set flipY(s){Ct.deprecatedWarning1||(Ct.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=s?1:-1}};let pe=Ct;pe.deprecatedWarning1=!1;class xe{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const i=this.bones;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const i=this.bones;for(let e=0,a=i.length;e<a;e++)if(i[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const i=this.slots;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const i=this.slots;for(let e=0,a=i.length;e<a;e++)if(i[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const i=this.skins;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const i=this.events;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const i=this.animations;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const i=this.ikConstraints;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const i=this.transformConstraints;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const i=this.pathConstraints;for(let e=0,a=i.length;e<a;e++){const r=i[e];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const i=this.pathConstraints;for(let e=0,a=i.length;e<a;e++)if(i[e].name==t)return e;return-1}}class we{constructor(t,i,e){if(this.index=0,this.color=new f.Color(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode="normal",t<0)throw new Error("index must be >= 0.");if(!i)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=i,this.boneData=e}}class Me extends Rt{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class ye{constructor(t,i,e){this.slotIndex=t,this.name=i,this.attachment=e}}class Dt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,i,e){if(!e)throw new Error("attachment cannot be null.");const a=this.attachments;t>=a.length&&(a.length=t+1),a[t]||(a[t]={}),a[t][i]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const a=t.bones[e];let r=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){r=!0;break}r||this.bones.push(a)}for(let e=0;e<t.constraints.length;e++){const a=t.constraints[e];let r=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){r=!0;break}r||this.constraints.push(a)}const i=t.getAttachments();for(let e=0;e<i.length;e++){const a=i[e];this.setAttachment(a.slotIndex,a.name,a.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const a=t.bones[e];let r=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){r=!0;break}r||this.bones.push(a)}for(let e=0;e<t.constraints.length;e++){const a=t.constraints[e];let r=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){r=!0;break}r||this.constraints.push(a)}const i=t.getAttachments();for(let e=0;e<i.length;e++){const a=i[e];a.attachment&&(a.attachment instanceof ft?(a.attachment=a.attachment.newLinkedMesh(),this.setAttachment(a.slotIndex,a.name,a.attachment)):(a.attachment=a.attachment.copy(),this.setAttachment(a.slotIndex,a.name,a.attachment)))}}getAttachment(t,i){const e=this.attachments[t];return e?e[i]:null}removeAttachment(t,i){const e=this.attachments[t];e&&delete e[i]}getAttachments(){const t=new Array;for(let i=0;i<this.attachments.length;i++){const e=this.attachments[i];if(e)for(const a in e){const r=e[a];r&&t.push(new ye(i,a,r))}}return t}getAttachmentsForSlot(t,i){const e=this.attachments[t];if(e)for(const a in e){const r=e[a];r&&i.push(new ye(t,a,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,i){let e=0;for(let a=0;a<t.slots.length;a++){const r=t.slots[a],d=r.getAttachment();if(d&&e<i.attachments.length){const h=i.attachments[e];for(const n in h){const o=h[n];if(d==o){const l=this.getAttachment(e,n);l&&r.setAttachment(l);break}}}e++}}}const Ve=class{constructor(s){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=s}readSkeletonData(s){const t=this.scale,i=new xe;i.name="";const e=new f.BinaryInput(s),a=e.readInt32(),r=e.readInt32();i.hash=r==0&&a==0?null:r.toString(16)+a.toString(16),i.version=e.readString();const d=i.version.substr(0,3);if(d!=="4.0"&&d!=="4.1"){const l=`Spine 4.1 loader cant load version ${i.version}. Please configure your pixi-spine bundle`;console.error(l)}this.ver40=d==="4.0",i.x=e.readFloat(),i.y=e.readFloat(),i.width=e.readFloat(),i.height=e.readFloat();const h=e.readBoolean();h&&(i.fps=e.readFloat(),i.imagesPath=e.readString(),i.audioPath=e.readString());let n=0;n=e.readInt(!0);for(let l=0;l<n;l++){const c=e.readString();if(!c)throw new Error("String in string table must not be null.");e.strings.push(c)}n=e.readInt(!0);for(let l=0;l<n;l++){const c=e.readString();if(!c)throw new Error("Bone name must not be null.");const u=l==0?null:i.bones[e.readInt(!0)],m=new de(l,c,u);m.rotation=e.readFloat(),m.x=e.readFloat()*t,m.y=e.readFloat()*t,m.scaleX=e.readFloat(),m.scaleY=e.readFloat(),m.shearX=e.readFloat(),m.shearY=e.readFloat(),m.length=e.readFloat()*t,m.transformMode=e.readInt(!0),m.skinRequired=e.readBoolean(),h&&f.Color.rgba8888ToColor(m.color,e.readInt32()),i.bones.push(m)}n=e.readInt(!0);for(let l=0;l<n;l++){const c=e.readString();if(!c)throw new Error("Slot name must not be null.");const u=i.bones[e.readInt(!0)],m=new we(l,c,u);f.Color.rgba8888ToColor(m.color,e.readInt32());const g=e.readInt32();g!=-1&&f.Color.rgb888ToColor(m.darkColor=new f.Color,g),m.attachmentName=e.readStringRef(),m.blendMode=Ve.blendModeFromNumber(e.readInt(!0)),i.slots.push(m)}n=e.readInt(!0);for(let l=0,c;l<n;l++){const u=e.readString();if(!u)throw new Error("IK constraint data name must not be null.");const m=new fe(u);m.order=e.readInt(!0),m.skinRequired=e.readBoolean(),c=e.readInt(!0);for(let g=0;g<c;g++)m.bones.push(i.bones[e.readInt(!0)]);m.target=i.bones[e.readInt(!0)],m.mix=e.readFloat(),m.softness=e.readFloat()*t,m.bendDirection=e.readByte(),m.compress=e.readBoolean(),m.stretch=e.readBoolean(),m.uniform=e.readBoolean(),i.ikConstraints.push(m)}n=e.readInt(!0);for(let l=0,c;l<n;l++){const u=e.readString();if(!u)throw new Error("Transform constraint data name must not be null.");const m=new Me(u);m.order=e.readInt(!0),m.skinRequired=e.readBoolean(),c=e.readInt(!0);for(let g=0;g<c;g++)m.bones.push(i.bones[e.readInt(!0)]);m.target=i.bones[e.readInt(!0)],m.local=e.readBoolean(),m.relative=e.readBoolean(),m.offsetRotation=e.readFloat(),m.offsetX=e.readFloat()*t,m.offsetY=e.readFloat()*t,m.offsetScaleX=e.readFloat(),m.offsetScaleY=e.readFloat(),m.offsetShearY=e.readFloat(),m.mixRotate=e.readFloat(),m.mixX=e.readFloat(),m.mixY=e.readFloat(),m.mixScaleX=e.readFloat(),m.mixScaleY=e.readFloat(),m.mixShearY=e.readFloat(),i.transformConstraints.push(m)}n=e.readInt(!0);for(let l=0,c;l<n;l++){const u=e.readString();if(!u)throw new Error("Path constraint data name must not be null.");const m=new ge(u);m.order=e.readInt(!0),m.skinRequired=e.readBoolean(),c=e.readInt(!0);for(let g=0;g<c;g++)m.bones.push(i.bones[e.readInt(!0)]);m.target=i.slots[e.readInt(!0)],m.positionMode=e.readInt(!0),m.spacingMode=e.readInt(!0),m.rotateMode=e.readInt(!0),m.offsetRotation=e.readFloat(),m.position=e.readFloat(),m.positionMode==f.PositionMode.Fixed&&(m.position*=t),m.spacing=e.readFloat(),(m.spacingMode==G.Length||m.spacingMode==G.Fixed)&&(m.spacing*=t),m.mixRotate=e.readFloat(),m.mixX=e.readFloat(),m.mixY=e.readFloat(),i.pathConstraints.push(m)}const o=this.readSkin(e,i,!0,h);o&&(i.defaultSkin=o,i.skins.push(o));{let l=i.skins.length;for(f.Utils.setArraySize(i.skins,n=l+e.readInt(!0));l<n;l++){const c=this.readSkin(e,i,!1,h);if(!c)throw new Error("readSkin() should not have returned null.");i.skins[l]=c}}n=this.linkedMeshes.length;for(let l=0;l<n;l++){const c=this.linkedMeshes[l],u=c.skin?i.findSkin(c.skin):i.defaultSkin;if(!u)throw new Error("Not skin found for linked mesh.");if(!c.parent)throw new Error("Linked mesh parent must not be null");const m=u.getAttachment(c.slotIndex,c.parent);if(!m)throw new Error(`Parent mesh not found: ${c.parent}`);c.mesh.timelineAttachment=c.inheritTimeline?m:c.mesh,c.mesh.setParentMesh(m)}this.linkedMeshes.length=0,n=e.readInt(!0);for(let l=0;l<n;l++){const c=e.readStringRef();if(!c)throw new Error;const u=new ue(c);u.intValue=e.readInt(!1),u.floatValue=e.readFloat(),u.stringValue=e.readString(),u.audioPath=e.readString(),u.audioPath&&(u.volume=e.readFloat(),u.balance=e.readFloat()),i.events.push(u)}n=e.readInt(!0);for(let l=0;l<n;l++){const c=e.readString();if(!c)throw new Error("Animatio name must not be null.");i.animations.push(this.readAnimation(e,c,i))}return i}readSkin(s,t,i,e){let a=null,r=0;if(i){if(r=s.readInt(!0),r==0)return null;a=new Dt("default")}else{const d=s.readStringRef();if(!d)throw new Error("Skin name must not be null.");a=new Dt(d),a.bones.length=s.readInt(!0);for(let h=0,n=a.bones.length;h<n;h++)a.bones[h]=t.bones[s.readInt(!0)];for(let h=0,n=s.readInt(!0);h<n;h++)a.constraints.push(t.ikConstraints[s.readInt(!0)]);for(let h=0,n=s.readInt(!0);h<n;h++)a.constraints.push(t.transformConstraints[s.readInt(!0)]);for(let h=0,n=s.readInt(!0);h<n;h++)a.constraints.push(t.pathConstraints[s.readInt(!0)]);r=s.readInt(!0)}for(let d=0;d<r;d++){const h=s.readInt(!0);for(let n=0,o=s.readInt(!0);n<o;n++){const l=s.readStringRef();if(!l)throw new Error("Attachment name must not be null");const c=this.readAttachment(s,t,a,h,l,e);c&&a.setAttachment(h,l,c)}}return a}readAttachment(s,t,i,e,a,r){const d=this.scale;let h=s.readStringRef();switch(h||(h=a),s.readByte()){case f.AttachmentType.Region:{let n=s.readStringRef();const o=s.readFloat(),l=s.readFloat(),c=s.readFloat(),u=s.readFloat(),m=s.readFloat(),g=s.readFloat(),w=s.readFloat(),M=s.readInt32(),k=this.readSequence(s);n||(n=h);const p=this.attachmentLoader.newRegionAttachment(i,h,n,k);return p?(p.path=n,p.x=l*d,p.y=c*d,p.scaleX=u,p.scaleY=m,p.rotation=o,p.width=g*d,p.height=w*d,f.Color.rgba8888ToColor(p.color,M),p.sequence=k,k==null&&p.updateRegion(),p):null}case f.AttachmentType.BoundingBox:{const n=s.readInt(!0),o=this.readVertices(s,n),l=r?s.readInt32():0,c=this.attachmentLoader.newBoundingBoxAttachment(i,h);return c?(c.worldVerticesLength=n<<1,c.vertices=o.vertices,c.bones=o.bones,r&&f.Color.rgba8888ToColor(c.color,l),c):null}case f.AttachmentType.Mesh:{let n=s.readStringRef();const o=s.readInt32(),l=s.readInt(!0),c=this.readFloatArray(s,l<<1,1),u=this.readShortArray(s),m=this.readVertices(s,l),g=s.readInt(!0),w=this.readSequence(s);let M=[],k=0,p=0;r&&(M=this.readShortArray(s),k=s.readFloat(),p=s.readFloat()),n||(n=h);const S=this.attachmentLoader.newMeshAttachment(i,h,n,w);return S?(S.path=n,f.Color.rgba8888ToColor(S.color,o),S.bones=m.bones,S.vertices=m.vertices,S.worldVerticesLength=l<<1,S.triangles=u,S.regionUVs=new Float32Array(c),S.hullLength=g<<1,S.sequence=w,r&&(S.edges=M,S.width=k*d,S.height=p*d),S):null}case f.AttachmentType.LinkedMesh:{let n=s.readStringRef();const o=s.readInt32(),l=s.readStringRef(),c=s.readStringRef(),u=s.readBoolean(),m=this.readSequence(s);let g=0,w=0;r&&(g=s.readFloat(),w=s.readFloat()),n||(n=h);const M=this.attachmentLoader.newMeshAttachment(i,h,n,m);return M?(M.path=n,f.Color.rgba8888ToColor(M.color,o),M.sequence=m,r&&(M.width=g*d,M.height=w*d),this.linkedMeshes.push(new tn(M,l,e,c,u)),M):null}case f.AttachmentType.Path:{const n=s.readBoolean(),o=s.readBoolean(),l=s.readInt(!0),c=this.readVertices(s,l),u=f.Utils.newArray(l/3,0);for(let w=0,M=u.length;w<M;w++)u[w]=s.readFloat()*d;const m=r?s.readInt32():0,g=this.attachmentLoader.newPathAttachment(i,h);return g?(g.closed=n,g.constantSpeed=o,g.worldVerticesLength=l<<1,g.vertices=c.vertices,g.bones=c.bones,g.lengths=u,r&&f.Color.rgba8888ToColor(g.color,m),g):null}case f.AttachmentType.Point:{const n=s.readFloat(),o=s.readFloat(),l=s.readFloat(),c=r?s.readInt32():0,u=this.attachmentLoader.newPointAttachment(i,h);return u?(u.x=o*d,u.y=l*d,u.rotation=n,r&&f.Color.rgba8888ToColor(u.color,c),u):null}case f.AttachmentType.Clipping:{const n=s.readInt(!0),o=s.readInt(!0),l=this.readVertices(s,o),c=r?s.readInt32():0,u=this.attachmentLoader.newClippingAttachment(i,h);return u?(u.endSlot=t.slots[n],u.worldVerticesLength=o<<1,u.vertices=l.vertices,u.bones=l.bones,r&&f.Color.rgba8888ToColor(u.color,c),u):null}}return null}readSequence(s){if(this.ver40||!s.readBoolean())return null;const t=new Ft(s.readInt(!0));return t.start=s.readInt(!0),t.digits=s.readInt(!0),t.setupIndex=s.readInt(!0),t}readDeformTimelineType(s){return this.ver40?qe:s.readByte()}readVertices(s,t){const i=this.scale,e=t<<1,a=new en;if(!s.readBoolean())return a.vertices=this.readFloatArray(s,e,i),a;const r=new Array,d=new Array;for(let h=0;h<t;h++){const n=s.readInt(!0);d.push(n);for(let o=0;o<n;o++)d.push(s.readInt(!0)),r.push(s.readFloat()*i),r.push(s.readFloat()*i),r.push(s.readFloat())}return a.vertices=f.Utils.toFloatArray(r),a.bones=d,a}readFloatArray(s,t,i){const e=new Array(t);if(i==1)for(let a=0;a<t;a++)e[a]=s.readFloat();else for(let a=0;a<t;a++)e[a]=s.readFloat()*i;return e}readShortArray(s){const t=s.readInt(!0),i=new Array(t);for(let e=0;e<t;e++)i[e]=s.readShort();return i}readAnimation(s,t,i){s.readInt(!0);const e=new Array,a=this.scale;for(let n=0,o=s.readInt(!0);n<o;n++){const l=s.readInt(!0);for(let c=0,u=s.readInt(!0);c<u;c++){const m=s.readByte(),g=s.readInt(!0),w=g-1;switch(m){case un:{const M=new pt(g,l);for(let k=0;k<g;k++)M.setFrame(k,s.readFloat(),s.readStringRef());e.push(M);break}case fn:{const M=s.readInt(!0),k=new Jt(g,M,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,x=s.readUnsignedByte()/255,B=s.readUnsignedByte()/255;for(let A=0,b=0;k.setFrame(A,p,S,y,x,B),A!=w;A++){const I=s.readFloat(),Y=s.readUnsignedByte()/255,v=s.readUnsignedByte()/255,T=s.readUnsignedByte()/255,U=s.readUnsignedByte()/255;switch(s.readByte()){case nt:k.setStepped(A);break;case st:$(s,k,b++,A,0,p,I,S,Y,1),$(s,k,b++,A,1,p,I,y,v,1),$(s,k,b++,A,2,p,I,x,T,1),$(s,k,b++,A,3,p,I,B,U,1)}p=I,S=Y,y=v,x=T,B=U}e.push(k);break}case gn:{const M=s.readInt(!0),k=new Qt(g,M,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,x=s.readUnsignedByte()/255;for(let B=0,A=0;k.setFrame(B,p,S,y,x),B!=w;B++){const b=s.readFloat(),I=s.readUnsignedByte()/255,Y=s.readUnsignedByte()/255,v=s.readUnsignedByte()/255;switch(s.readByte()){case nt:k.setStepped(B);break;case st:$(s,k,A++,B,0,p,b,S,I,1),$(s,k,A++,B,1,p,b,y,Y,1),$(s,k,A++,B,2,p,b,x,v,1)}p=b,S=I,y=Y,x=v}e.push(k);break}case pn:{const M=s.readInt(!0),k=new te(g,M,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,x=s.readUnsignedByte()/255,B=s.readUnsignedByte()/255,A=s.readUnsignedByte()/255,b=s.readUnsignedByte()/255,I=s.readUnsignedByte()/255;for(let Y=0,v=0;k.setFrame(Y,p,S,y,x,B,A,b,I),Y!=w;Y++){const T=s.readFloat(),U=s.readUnsignedByte()/255,X=s.readUnsignedByte()/255,W=s.readUnsignedByte()/255,R=s.readUnsignedByte()/255,E=s.readUnsignedByte()/255,D=s.readUnsignedByte()/255,j=s.readUnsignedByte()/255;switch(s.readByte()){case nt:k.setStepped(Y);break;case st:$(s,k,v++,Y,0,p,T,S,U,1),$(s,k,v++,Y,1,p,T,y,X,1),$(s,k,v++,Y,2,p,T,x,W,1),$(s,k,v++,Y,3,p,T,B,R,1),$(s,k,v++,Y,4,p,T,A,E,1),$(s,k,v++,Y,5,p,T,b,D,1),$(s,k,v++,Y,6,p,T,I,j,1)}p=T,S=U,y=X,x=W,B=R,A=E,b=D,I=j}e.push(k);break}case xn:{const M=s.readInt(!0),k=new ee(g,M,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,x=s.readUnsignedByte()/255,B=s.readUnsignedByte()/255,A=s.readUnsignedByte()/255,b=s.readUnsignedByte()/255;for(let I=0,Y=0;k.setFrame(I,p,S,y,x,B,A,b),I!=w;I++){const v=s.readFloat(),T=s.readUnsignedByte()/255,U=s.readUnsignedByte()/255,X=s.readUnsignedByte()/255,W=s.readUnsignedByte()/255,R=s.readUnsignedByte()/255,E=s.readUnsignedByte()/255;switch(s.readByte()){case nt:k.setStepped(I);break;case st:$(s,k,Y++,I,0,p,v,S,T,1),$(s,k,Y++,I,1,p,v,y,U,1),$(s,k,Y++,I,2,p,v,x,X,1),$(s,k,Y++,I,3,p,v,B,W,1),$(s,k,Y++,I,4,p,v,A,R,1),$(s,k,Y++,I,5,p,v,b,E,1)}p=v,S=T,y=U,x=X,B=W,A=R,b=E}e.push(k);break}case wn:{const M=new Zt(g,s.readInt(!0),l);let k=s.readFloat(),p=s.readUnsignedByte()/255;for(let S=0,y=0;M.setFrame(S,k,p),S!=w;S++){const x=s.readFloat(),B=s.readUnsignedByte()/255;switch(s.readByte()){case nt:M.setStepped(S);break;case st:$(s,M,y++,S,0,k,x,p,B,1)}k=x,p=B}e.push(M)}}}}for(let n=0,o=s.readInt(!0);n<o;n++){const l=s.readInt(!0);for(let c=0,u=s.readInt(!0);c<u;c++){const m=s.readByte(),g=s.readInt(!0),w=s.readInt(!0);switch(m){case nn:e.push(ct(s,new Bt(g,w,l),1));break;case sn:e.push(ke(s,new Wt(g,w,l),a));break;case an:e.push(ct(s,new Nt(g,w,l),a));break;case rn:e.push(ct(s,new Ot(g,w,l),a));break;case on:e.push(ke(s,new zt(g,w,l),1));break;case ln:e.push(ct(s,new _t(g,w,l),1));break;case hn:e.push(ct(s,new jt(g,w,l),1));break;case cn:e.push(ke(s,new Gt(g,w,l),1));break;case dn:e.push(ct(s,new Ht(g,w,l),1));break;case mn:e.push(ct(s,new Kt(g,w,l),1))}}}for(let n=0,o=s.readInt(!0);n<o;n++){const l=s.readInt(!0),c=s.readInt(!0),u=c-1,m=new se(c,s.readInt(!0),l);let g=s.readFloat(),w=s.readFloat(),M=s.readFloat()*a;for(let k=0,p=0;m.setFrame(k,g,w,M,s.readByte(),s.readBoolean(),s.readBoolean()),k!=u;k++){const S=s.readFloat(),y=s.readFloat(),x=s.readFloat()*a;switch(s.readByte()){case nt:m.setStepped(k);break;case st:$(s,m,p++,k,0,g,S,w,y,1),$(s,m,p++,k,1,g,S,M,x,a)}g=S,w=y,M=x}e.push(m)}for(let n=0,o=s.readInt(!0);n<o;n++){const l=s.readInt(!0),c=s.readInt(!0),u=c-1,m=new ie(c,s.readInt(!0),l);let g=s.readFloat(),w=s.readFloat(),M=s.readFloat(),k=s.readFloat(),p=s.readFloat(),S=s.readFloat(),y=s.readFloat();for(let x=0,B=0;m.setFrame(x,g,w,M,k,p,S,y),x!=u;x++){const A=s.readFloat(),b=s.readFloat(),I=s.readFloat(),Y=s.readFloat(),v=s.readFloat(),T=s.readFloat(),U=s.readFloat();switch(s.readByte()){case nt:m.setStepped(x);break;case st:$(s,m,B++,x,0,g,A,w,b,1),$(s,m,B++,x,1,g,A,M,I,1),$(s,m,B++,x,2,g,A,k,Y,1),$(s,m,B++,x,3,g,A,p,v,1),$(s,m,B++,x,4,g,A,S,T,1),$(s,m,B++,x,5,g,A,y,U,1)}g=A,w=b,M=I,k=Y,p=v,S=T,y=U}e.push(m)}for(let n=0,o=s.readInt(!0);n<o;n++){const l=s.readInt(!0),c=i.pathConstraints[l];for(let u=0,m=s.readInt(!0);u<m;u++)switch(s.readByte()){case yn:e.push(ct(s,new ae(s.readInt(!0),s.readInt(!0),l),c.positionMode==f.PositionMode.Fixed?a:1));break;case kn:e.push(ct(s,new re(s.readInt(!0),s.readInt(!0),l),c.spacingMode==G.Length||c.spacingMode==G.Fixed?a:1));break;case Sn:const g=new oe(s.readInt(!0),s.readInt(!0),l);let w=s.readFloat(),M=s.readFloat(),k=s.readFloat(),p=s.readFloat();for(let S=0,y=0,x=g.getFrameCount()-1;g.setFrame(S,w,M,k,p),S!=x;S++){const B=s.readFloat(),A=s.readFloat(),b=s.readFloat(),I=s.readFloat();switch(s.readByte()){case nt:g.setStepped(S);break;case st:$(s,g,y++,S,0,w,B,M,A,1),$(s,g,y++,S,1,w,B,k,b,1),$(s,g,y++,S,2,w,B,p,I,1)}w=B,M=A,k=b,p=I}e.push(g)}}for(let n=0,o=s.readInt(!0);n<o;n++){const l=i.skins[s.readInt(!0)];for(let c=0,u=s.readInt(!0);c<u;c++){const m=s.readInt(!0);for(let g=0,w=s.readInt(!0);g<w;g++){const M=s.readStringRef();if(!M)throw new Error("attachmentName must not be null.");const k=l.getAttachment(m,M),p=this.readDeformTimelineType(s),S=s.readInt(!0),y=S-1;switch(p){case qe:{const x=k,B=x.bones,A=x.vertices,b=B?A.length/3*2:A.length,I=s.readInt(!0),Y=new ne(S,I,m,x);let v=s.readFloat();for(let T=0,U=0;;T++){let X,W=s.readInt(!0);if(W==0)X=B?f.Utils.newFloatArray(b):A;else{X=f.Utils.newFloatArray(b);const E=s.readInt(!0);if(W+=E,a==1)for(let D=E;D<W;D++)X[D]=s.readFloat();else for(let D=E;D<W;D++)X[D]=s.readFloat()*a;if(!B)for(let D=0,j=X.length;D<j;D++)X[D]+=A[D]}if(Y.setFrame(T,v,X),T==y)break;const R=s.readFloat();switch(s.readByte()){case nt:Y.setStepped(T);break;case st:$(s,Y,U++,T,0,v,R,0,1,1)}v=R}e.push(Y);break}case Mn:{const x=new wt(S,m,k);for(let B=0;B<S;B++){const A=s.readFloat(),b=s.readInt32();x.setFrame(B,A,Lt[b&15],b>>4,s.readFloat())}e.push(x);break}}}}}const r=s.readInt(!0);if(r>0){const n=new xt(r),o=i.slots.length;for(let l=0;l<r;l++){const c=s.readFloat(),u=s.readInt(!0),m=f.Utils.newArray(o,0);for(let k=o-1;k>=0;k--)m[k]=-1;const g=f.Utils.newArray(o-u,0);let w=0,M=0;for(let k=0;k<u;k++){const p=s.readInt(!0);for(;w!=p;)g[M++]=w++;m[w+s.readInt(!0)]=w++}for(;w<o;)g[M++]=w++;for(let k=o-1;k>=0;k--)m[k]==-1&&(m[k]=g[--M]);n.setFrame(l,c,m)}e.push(n)}const d=s.readInt(!0);if(d>0){const n=new At(d);for(let o=0;o<d;o++){const l=s.readFloat(),c=i.events[s.readInt(!0)],u=new me(l,c);u.intValue=s.readInt(!1),u.floatValue=s.readFloat(),u.stringValue=s.readBoolean()?s.readString():c.stringValue,u.data.audioPath&&(u.volume=s.readFloat(),u.balance=s.readFloat()),n.setFrame(o,u)}e.push(n)}let h=0;for(let n=0,o=e.length;n<o;n++)h=Math.max(h,e[n].getDuration());return new Xt(t,e,h)}static blendModeFromNumber(s){if(s==0)return"normal";if(s==1)return"add";if(s==2)return"multiply";if(s==3)return"screen";throw new Error(`Unknown blend mode: ${s}`)}};let $e=Ve;$e.BlendModeValues=["normal","add","multiply","screen"];class tn{constructor(t,i,e,a,r){this.mesh=t,this.skin=i,this.slotIndex=e,this.parent=a,this.inheritTimeline=r}}class en{constructor(t=null,i=null){this.bones=t,this.vertices=i}}function ct(s,t,i){let e=s.readFloat(),a=s.readFloat()*i;for(let r=0,d=0,h=t.getFrameCount()-1;t.setFrame(r,e,a),r!=h;r++){const n=s.readFloat(),o=s.readFloat()*i;switch(s.readByte()){case nt:t.setStepped(r);break;case st:$(s,t,d++,r,0,e,n,a,o,i)}e=n,a=o}return t}function ke(s,t,i){let e=s.readFloat(),a=s.readFloat()*i,r=s.readFloat()*i;for(let d=0,h=0,n=t.getFrameCount()-1;t.setFrame(d,e,a,r),d!=n;d++){const o=s.readFloat(),l=s.readFloat()*i,c=s.readFloat()*i;switch(s.readByte()){case nt:t.setStepped(d);break;case st:$(s,t,h++,d,0,e,o,a,l,i),$(s,t,h++,d,1,e,o,r,c,i)}e=o,a=l,r=c}return t}function $(s,t,i,e,a,r,d,h,n,o){t.setBezier(i,e,a,r,h,s.readFloat(),s.readFloat()*o,s.readFloat(),s.readFloat()*o,d,n)}const nn=0,sn=1,an=2,rn=3,on=4,ln=5,hn=6,cn=7,dn=8,mn=9,un=0,fn=1,gn=2,pn=3,xn=4,wn=5,qe=0,Mn=1,yn=0,kn=1,Sn=2,nt=1,st=2;class Bn extends f.SkeletonBoundsBase{}class Se{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const i=this.scale,e=new xe,a=typeof t=="string"?JSON.parse(t):t,r=a.skeleton;if(r){e.hash=r.hash,e.version=r.spine;const d=e.version.substr(0,3);if(d!=="4.0"&&d!=="4.1"){const h=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(h)}e.x=r.x,e.y=r.y,e.width=r.width,e.height=r.height,e.fps=r.fps,e.imagesPath=r.images}if(a.bones)for(let d=0;d<a.bones.length;d++){const h=a.bones[d];let n=null;const o=C(h,"parent",null);if(o!=null&&(n=e.findBone(o),n==null))throw new Error(`Parent bone not found: ${o}`);const l=new de(e.bones.length,h.name,n);l.length=C(h,"length",0)*i,l.x=C(h,"x",0)*i,l.y=C(h,"y",0)*i,l.rotation=C(h,"rotation",0),l.scaleX=C(h,"scaleX",1),l.scaleY=C(h,"scaleY",1),l.shearX=C(h,"shearX",0),l.shearY=C(h,"shearY",0),l.transformMode=f.Utils.enumValue(f.TransformMode,C(h,"transform","Normal")),l.skinRequired=C(h,"skin",!1);const c=C(h,"color",null);c&&l.color.setFromString(c),e.bones.push(l)}if(a.slots)for(let d=0;d<a.slots.length;d++){const h=a.slots[d],n=e.findBone(h.bone);if(!n)throw new Error(`Couldn't find bone ${h.bone} for slot ${h.name}`);const o=new we(e.slots.length,h.name,n),l=C(h,"color",null);l&&o.color.setFromString(l);const c=C(h,"dark",null);c&&(o.darkColor=f.Color.fromString(c)),o.attachmentName=C(h,"attachment",null),o.blendMode=Se.blendModeFromString(C(h,"blend","normal")),e.slots.push(o)}if(a.ik)for(let d=0;d<a.ik.length;d++){const h=a.ik[d],n=new fe(h.name);n.order=C(h,"order",0),n.skinRequired=C(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const l=h.bones[o],c=e.findBone(l);if(c==null)throw new Error(`IK bone not found: ${l}`);n.bones.push(c)}n.target=e.findBone(h.target),n.mix=C(h,"mix",1),n.softness=C(h,"softness",0)*i,n.bendDirection=C(h,"bendPositive",!0)?1:-1,n.compress=C(h,"compress",!1),n.stretch=C(h,"stretch",!1),n.uniform=C(h,"uniform",!1),e.ikConstraints.push(n)}if(a.transform)for(let d=0;d<a.transform.length;d++){const h=a.transform[d],n=new Me(h.name);n.order=C(h,"order",0),n.skinRequired=C(h,"skin",!1);for(let c=0;c<h.bones.length;c++){const u=h.bones[c],m=e.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for transform constraint ${h.name}.`);n.bones.push(m)}const o=h.target,l=e.findBone(o);if(!l)throw new Error(`Couldn't find target bone ${o} for transform constraint ${h.name}.`);n.target=l,n.local=C(h,"local",!1),n.relative=C(h,"relative",!1),n.offsetRotation=C(h,"rotation",0),n.offsetX=C(h,"x",0)*i,n.offsetY=C(h,"y",0)*i,n.offsetScaleX=C(h,"scaleX",0),n.offsetScaleY=C(h,"scaleY",0),n.offsetShearY=C(h,"shearY",0),n.mixRotate=C(h,"mixRotate",1),n.mixX=C(h,"mixX",1),n.mixY=C(h,"mixY",n.mixX),n.mixScaleX=C(h,"mixScaleX",1),n.mixScaleY=C(h,"mixScaleY",n.mixScaleX),n.mixShearY=C(h,"mixShearY",1),e.transformConstraints.push(n)}if(a.path)for(let d=0;d<a.path.length;d++){const h=a.path[d],n=new ge(h.name);n.order=C(h,"order",0),n.skinRequired=C(h,"skin",!1);for(let c=0;c<h.bones.length;c++){const u=h.bones[c],m=e.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for path constraint ${h.name}.`);n.bones.push(m)}const o=h.target,l=e.findSlot(o);if(!l)throw new Error(`Couldn't find target slot ${o} for path constraint ${h.name}.`);n.target=l,n.positionMode=f.Utils.enumValue(f.PositionMode,C(h,"positionMode","Percent")),n.spacingMode=f.Utils.enumValue(G,C(h,"spacingMode","Length")),n.rotateMode=f.Utils.enumValue(f.RotateMode,C(h,"rotateMode","Tangent")),n.offsetRotation=C(h,"rotation",0),n.position=C(h,"position",0),n.positionMode==f.PositionMode.Fixed&&(n.position*=i),n.spacing=C(h,"spacing",0),(n.spacingMode==G.Length||n.spacingMode==G.Fixed)&&(n.spacing*=i),n.mixRotate=C(h,"mixRotate",1),n.mixX=C(h,"mixX",1),n.mixY=C(h,"mixY",n.mixX),e.pathConstraints.push(n)}if(a.skins)for(let d=0;d<a.skins.length;d++){const h=a.skins[d],n=new Dt(h.name);if(h.bones)for(let o=0;o<h.bones.length;o++){const l=h.bones[o],c=e.findBone(l);if(!c)throw new Error(`Couldn't find bone ${l} for skin ${h.name}.`);n.bones.push(c)}if(h.ik)for(let o=0;o<h.ik.length;o++){const l=h.ik[o],c=e.findIkConstraint(l);if(!c)throw new Error(`Couldn't find IK constraint ${l} for skin ${h.name}.`);n.constraints.push(c)}if(h.transform)for(let o=0;o<h.transform.length;o++){const l=h.transform[o],c=e.findTransformConstraint(l);if(!c)throw new Error(`Couldn't find transform constraint ${l} for skin ${h.name}.`);n.constraints.push(c)}if(h.path)for(let o=0;o<h.path.length;o++){const l=h.path[o],c=e.findPathConstraint(l);if(!c)throw new Error(`Couldn't find path constraint ${l} for skin ${h.name}.`);n.constraints.push(c)}for(const o in h.attachments){const l=e.findSlot(o);if(!l)throw new Error(`Couldn't find slot ${o} for skin ${h.name}.`);const c=h.attachments[o];for(const u in c){const m=this.readAttachment(c[u],n,l.index,u,e);m&&n.setAttachment(l.index,u,m)}}e.skins.push(n),n.name=="default"&&(e.defaultSkin=n)}for(let d=0,h=this.linkedMeshes.length;d<h;d++){const n=this.linkedMeshes[d],o=n.skin?e.findSkin(n.skin):e.defaultSkin;if(!o)throw new Error(`Skin not found: ${n.skin}`);const l=o.getAttachment(n.slotIndex,n.parent);if(!l)throw new Error(`Parent mesh not found: ${n.parent}`);n.mesh.timelineAttachment=n.inheritTimeline?l:n.mesh,n.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,a.events)for(const d in a.events){const h=a.events[d],n=new ue(d);n.intValue=C(h,"int",0),n.floatValue=C(h,"float",0),n.stringValue=C(h,"string",""),n.audioPath=C(h,"audio",null),n.audioPath&&(n.volume=C(h,"volume",1),n.balance=C(h,"balance",0)),e.events.push(n)}if(a.animations)for(const d in a.animations){const h=a.animations[d];this.readAnimation(h,d,e)}return e}readAttachment(t,i,e,a,r){const d=this.scale;switch(a=C(t,"name",a),C(t,"type","region")){case"region":{const h=C(t,"path",a),n=this.readSequence(C(t,"sequence",null)),o=this.attachmentLoader.newRegionAttachment(i,a,h,n);if(!o)return null;o.path=h,o.x=C(t,"x",0)*d,o.y=C(t,"y",0)*d,o.scaleX=C(t,"scaleX",1),o.scaleY=C(t,"scaleY",1),o.rotation=C(t,"rotation",0),o.width=t.width*d,o.height=t.height*d,o.sequence=n;const l=C(t,"color",null);return l&&o.color.setFromString(l),o}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(i,a);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const n=C(t,"color",null);return n&&h.color.setFromString(n),h}case"mesh":case"linkedmesh":{const h=C(t,"path",a),n=this.readSequence(C(t,"sequence",null)),o=this.attachmentLoader.newMeshAttachment(i,a,h,n);if(!o)return null;o.path=h;const l=C(t,"color",null);l&&o.color.setFromString(l),o.width=C(t,"width",0)*d,o.height=C(t,"height",0)*d,o.sequence=n;const c=C(t,"parent",null);if(c)return this.linkedMeshes.push(new An(o,C(t,"skin",null),e,c,C(t,"timelines",!0))),o;const u=t.uvs;return this.readVertices(t,o,u.length),o.triangles=t.triangles,o.regionUVs=new Float32Array(u),o.edges=C(t,"edges",null),o.hullLength=C(t,"hull",0)*2,o}case"path":{const h=this.attachmentLoader.newPathAttachment(i,a);if(!h)return null;h.closed=C(t,"closed",!1),h.constantSpeed=C(t,"constantSpeed",!0);const n=t.vertexCount;this.readVertices(t,h,n<<1);const o=f.Utils.newArray(n/3,0);for(let c=0;c<t.lengths.length;c++)o[c]=t.lengths[c]*d;h.lengths=o;const l=C(t,"color",null);return l&&h.color.setFromString(l),h}case"point":{const h=this.attachmentLoader.newPointAttachment(i,a);if(!h)return null;h.x=C(t,"x",0)*d,h.y=C(t,"y",0)*d,h.rotation=C(t,"rotation",0);const n=C(t,"color",null);return n&&h.color.setFromString(n),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(i,a);if(!h)return null;const n=C(t,"end",null);if(n!=null){const c=r.findSlot(n);if(c==null)throw new Error(`Clipping end slot not found: ${n}`);h.endSlot=c}const o=t.vertexCount;this.readVertices(t,h,o<<1);const l=C(t,"color",null);return l&&h.color.setFromString(l),h}}return null}readSequence(t){if(t==null)return null;const i=new Ft(C(t,"count",0));return i.start=C(t,"start",1),i.digits=C(t,"digits",0),i.setupIndex=C(t,"setup",0),i}readVertices(t,i,e){const a=this.scale;i.worldVerticesLength=e;const r=t.vertices;if(e==r.length){const n=f.Utils.toFloatArray(r);if(a!=1)for(let o=0,l=r.length;o<l;o++)n[o]*=a;i.vertices=n;return}const d=new Array,h=new Array;for(let n=0,o=r.length;n<o;){const l=r[n++];h.push(l);for(let c=n+l*4;n<c;n+=4)h.push(r[n]),d.push(r[n+1]*a),d.push(r[n+2]*a),d.push(r[n+3])}i.bones=h,i.vertices=f.Utils.toFloatArray(d)}readAnimation(t,i,e){const a=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const n=t.slots[h],o=e.findSlot(h);if(!o)throw new Error(`Slot not found: ${h}`);const l=o.index;for(const c in n){const u=n[c];if(!u)continue;const m=u.length;if(c=="attachment"){const g=new pt(m,l);for(let w=0;w<m;w++){const M=u[w];g.setFrame(w,C(M,"time",0),C(M,"name",null))}r.push(g)}else if(c=="rgba"){const g=new Jt(m,m<<2,l);let w=u[0],M=C(w,"time",0),k=f.Color.fromString(w.color);for(let p=0,S=0;;p++){g.setFrame(p,M,k.r,k.g,k.b,k.a);const y=u[p+1];if(!y){g.shrink(S);break}const x=C(y,"time",0),B=f.Color.fromString(y.color),A=w.curve;A&&(S=L(A,g,S,p,0,M,x,k.r,B.r,1),S=L(A,g,S,p,1,M,x,k.g,B.g,1),S=L(A,g,S,p,2,M,x,k.b,B.b,1),S=L(A,g,S,p,3,M,x,k.a,B.a,1)),M=x,k=B,w=y}r.push(g)}else if(c=="rgb"){const g=new Qt(m,m*3,l);let w=u[0],M=C(w,"time",0),k=f.Color.fromString(w.color);for(let p=0,S=0;;p++){g.setFrame(p,M,k.r,k.g,k.b);const y=u[p+1];if(!y){g.shrink(S);break}const x=C(y,"time",0),B=f.Color.fromString(y.color),A=w.curve;A&&(S=L(A,g,S,p,0,M,x,k.r,B.r,1),S=L(A,g,S,p,1,M,x,k.g,B.g,1),S=L(A,g,S,p,2,M,x,k.b,B.b,1)),M=x,k=B,w=y}r.push(g)}else if(c=="alpha")r.push(ot(u,new Zt(m,m,l),0,1));else if(c=="rgba2"){const g=new te(m,m*7,l);let w=u[0],M=C(w,"time",0),k=f.Color.fromString(w.light),p=f.Color.fromString(w.dark);for(let S=0,y=0;;S++){g.setFrame(S,M,k.r,k.g,k.b,k.a,p.r,p.g,p.b);const x=u[S+1];if(!x){g.shrink(y);break}const B=C(x,"time",0),A=f.Color.fromString(x.light),b=f.Color.fromString(x.dark),I=w.curve;I&&(y=L(I,g,y,S,0,M,B,k.r,A.r,1),y=L(I,g,y,S,1,M,B,k.g,A.g,1),y=L(I,g,y,S,2,M,B,k.b,A.b,1),y=L(I,g,y,S,3,M,B,k.a,A.a,1),y=L(I,g,y,S,4,M,B,p.r,b.r,1),y=L(I,g,y,S,5,M,B,p.g,b.g,1),y=L(I,g,y,S,6,M,B,p.b,b.b,1)),M=B,k=A,p=b,w=x}r.push(g)}else if(c=="rgb2"){const g=new ee(m,m*6,l);let w=u[0],M=C(w,"time",0),k=f.Color.fromString(w.light),p=f.Color.fromString(w.dark);for(let S=0,y=0;;S++){g.setFrame(S,M,k.r,k.g,k.b,p.r,p.g,p.b);const x=u[S+1];if(!x){g.shrink(y);break}const B=C(x,"time",0),A=f.Color.fromString(x.light),b=f.Color.fromString(x.dark),I=w.curve;I&&(y=L(I,g,y,S,0,M,B,k.r,A.r,1),y=L(I,g,y,S,1,M,B,k.g,A.g,1),y=L(I,g,y,S,2,M,B,k.b,A.b,1),y=L(I,g,y,S,3,M,B,p.r,b.r,1),y=L(I,g,y,S,4,M,B,p.g,b.g,1),y=L(I,g,y,S,5,M,B,p.b,b.b,1)),M=B,k=A,p=b,w=x}r.push(g)}}}if(t.bones)for(const h in t.bones){const n=t.bones[h],o=e.findBone(h);if(!o)throw new Error(`Bone not found: ${h}`);const l=o.index;for(const c in n){const u=n[c],m=u.length;if(m!=0){if(c==="rotate")r.push(ot(u,new Bt(m,m,l),0,1));else if(c==="translate"){const g=new Wt(m,m<<1,l);r.push(Be(u,g,"x","y",0,a))}else if(c==="translatex"){const g=new Nt(m,m,l);r.push(ot(u,g,0,a))}else if(c==="translatey"){const g=new Ot(m,m,l);r.push(ot(u,g,0,a))}else if(c==="scale"){const g=new zt(m,m<<1,l);r.push(Be(u,g,"x","y",1,1))}else if(c==="scalex"){const g=new _t(m,m,l);r.push(ot(u,g,1,1))}else if(c==="scaley"){const g=new jt(m,m,l);r.push(ot(u,g,1,1))}else if(c==="shear"){const g=new Gt(m,m<<1,l);r.push(Be(u,g,"x","y",0,1))}else if(c==="shearx"){const g=new Ht(m,m,l);r.push(ot(u,g,0,1))}else if(c==="sheary"){const g=new Kt(m,m,l);r.push(ot(u,g,0,1))}}}}if(t.ik)for(const h in t.ik){const n=t.ik[h];let o=n[0];if(!o)continue;const l=e.findIkConstraint(h);if(!l)throw new Error(`IK Constraint not found: ${h}`);const c=e.ikConstraints.indexOf(l),u=new se(n.length,n.length<<1,c);let m=C(o,"time",0),g=C(o,"mix",1),w=C(o,"softness",0)*a;for(let M=0,k=0;;M++){u.setFrame(M,m,g,w,C(o,"bendPositive",!0)?1:-1,C(o,"compress",!1),C(o,"stretch",!1));const p=n[M+1];if(!p){u.shrink(k);break}const S=C(p,"time",0),y=C(p,"mix",1),x=C(p,"softness",0)*a,B=o.curve;B&&(k=L(B,u,k,M,0,m,S,g,y,1),k=L(B,u,k,M,1,m,S,w,x,a)),m=S,g=y,w=x,o=p}r.push(u)}if(t.transform)for(const h in t.transform){const n=t.transform[h];let o=n[0];if(!o)continue;const l=e.findTransformConstraint(h);if(!l)throw new Error(`Transform constraint not found: ${h}`);const c=e.transformConstraints.indexOf(l),u=new ie(n.length,n.length*6,c);let m=C(o,"time",0),g=C(o,"mixRotate",1),w=C(o,"mixX",1),M=C(o,"mixY",w),k=C(o,"mixScaleX",1),p=C(o,"mixScaleY",k);const S=C(o,"mixShearY",1);for(let y=0,x=0;;y++){u.setFrame(y,m,g,w,M,k,p,S);const B=n[y+1];if(!B){u.shrink(x);break}const A=C(B,"time",0),b=C(B,"mixRotate",1),I=C(B,"mixX",1),Y=C(B,"mixY",I),v=C(B,"mixScaleX",1),T=C(B,"mixScaleY",v),U=C(B,"mixShearY",1),X=o.curve;X&&(x=L(X,u,x,y,0,m,A,g,b,1),x=L(X,u,x,y,1,m,A,w,I,1),x=L(X,u,x,y,2,m,A,M,Y,1),x=L(X,u,x,y,3,m,A,k,v,1),x=L(X,u,x,y,4,m,A,p,T,1),x=L(X,u,x,y,5,m,A,S,U,1)),m=A,g=b,w=I,M=Y,k=v,p=T,k=v,o=B}r.push(u)}if(t.path)for(const h in t.path){const n=t.path[h],o=e.findPathConstraint(h);if(!o)throw new Error(`Path constraint not found: ${h}`);const l=e.pathConstraints.indexOf(o);for(const c in n){const u=n[c];let m=u[0];if(!m)continue;const g=u.length;if(c==="position"){const w=new ae(g,g,l);r.push(ot(u,w,0,o.positionMode==f.PositionMode.Fixed?a:1))}else if(c==="spacing"){const w=new re(g,g,l);r.push(ot(u,w,0,o.spacingMode==G.Length||o.spacingMode==G.Fixed?a:1))}else if(c==="mix"){const w=new oe(g,g*3,l);let M=C(m,"time",0),k=C(m,"mixRotate",1),p=C(m,"mixX",1),S=C(m,"mixY",p);for(let y=0,x=0;;y++){w.setFrame(y,M,k,p,S);const B=u[y+1];if(!B){w.shrink(x);break}const A=C(B,"time",0),b=C(B,"mixRotate",1),I=C(B,"mixX",1),Y=C(B,"mixY",I),v=m.curve;v&&(x=L(v,w,x,y,0,M,A,k,b,1),x=L(v,w,x,y,1,M,A,p,I,1),x=L(v,w,x,y,2,M,A,S,Y,1)),M=A,k=b,p=I,S=Y,m=B}r.push(w)}}}if(t.deform){t.attachments={};for(const h in t.deform){const n=t.deform[h],o=t.attachments[h]={};for(const l in n){const c=n[l],u=o[l]={};for(const m in c)u[m]={deform:c[m]}}}}if(t.attachments)for(const h in t.attachments){const n=t.attachments[h],o=e.findSkin(h);if(o==null){if(f.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${h}`);continue}for(const l in n){const c=n[l],u=e.findSlot(l);if(!u)throw new Error(`Slot not found: ${l}`);const m=u.index;for(const g in c){const w=c[g],M=o.getAttachment(m,g);for(const k in w){const p=w[k];let S=p[0];if(S){if(k=="deform"){const y=M.bones,x=M.vertices,B=y?x.length/3*2:x.length,A=new ne(p.length,p.length,m,M);let b=C(S,"time",0);for(let I=0,Y=0;;I++){let v;const T=C(S,"vertices",null);if(!T)v=y?f.Utils.newFloatArray(B):x;else{v=f.Utils.newFloatArray(B);const R=C(S,"offset",0);if(f.Utils.arrayCopy(T,0,v,R,T.length),a!=1)for(let E=R,D=E+T.length;E<D;E++)v[E]*=a;if(!y)for(let E=0;E<B;E++)v[E]+=x[E]}A.setFrame(I,b,v);const U=p[I+1];if(!U){A.shrink(Y);break}const X=C(U,"time",0),W=S.curve;W&&(Y=L(W,A,Y,I,0,b,X,0,1,1)),b=X,S=U}r.push(A)}else if(k=="sequence"){const y=new wt(p.length,m,M);let x=0;for(let B=0;B<p.length;B++){const A=C(S,"delay",x),b=C(S,"time",0),I=at[C(S,"mode","hold")],Y=C(S,"index",0);y.setFrame(B,b,I,Y,A),x=A,S=p[B+1]}r.push(y)}}}}}}if(t.drawOrder){const h=new xt(t.drawOrder.length),n=e.slots.length;let o=0;for(let l=0;l<t.drawOrder.length;l++,o++){const c=t.drawOrder[l];let u=null;const m=C(c,"offsets",null);if(m){u=f.Utils.newArray(n,-1);const g=f.Utils.newArray(n-m.length,0);let w=0,M=0;for(let k=0;k<m.length;k++){const p=m[k],S=e.findSlot(p.slot);if(!S)throw new Error(`Slot not found: ${S}`);const y=S.index;for(;w!=y;)g[M++]=w++;u[w+p.offset]=w++}for(;w<n;)g[M++]=w++;for(let k=n-1;k>=0;k--)u[k]==-1&&(u[k]=g[--M])}h.setFrame(o,C(c,"time",0),u)}r.push(h)}if(t.events){const h=new At(t.events.length);let n=0;for(let o=0;o<t.events.length;o++,n++){const l=t.events[o],c=e.findEvent(l.name);if(!c)throw new Error(`Event not found: ${l.name}`);const u=new me(f.Utils.toSinglePrecision(C(l,"time",0)),c);u.intValue=C(l,"int",c.intValue),u.floatValue=C(l,"float",c.floatValue),u.stringValue=C(l,"string",c.stringValue),u.data.audioPath&&(u.volume=C(l,"volume",1),u.balance=C(l,"balance",0)),h.setFrame(n,u)}r.push(h)}let d=0;for(let h=0,n=r.length;h<n;h++)d=Math.max(d,r[h].getDuration());if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Xt(i,r,d))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return"normal";if(t=="additive")return"add";if(t=="multiply")return"multiply";if(t=="screen")return"screen";throw new Error(`Unknown blend mode: ${t}`)}}class An{constructor(t,i,e,a,r){this.mesh=t,this.skin=i,this.slotIndex=e,this.parent=a,this.inheritTimeline=r}}function ot(s,t,i,e){let a=s[0],r=C(a,"time",0),d=C(a,"value",i)*e,h=0;for(let n=0;;n++){t.setFrame(n,r,d);const o=s[n+1];if(!o)return t.shrink(h),t;const l=C(o,"time",0),c=C(o,"value",i)*e;a.curve&&(h=L(a.curve,t,h,n,0,r,l,d,c,e)),r=l,d=c,a=o}}function Be(s,t,i,e,a,r){let d=s[0],h=C(d,"time",0),n=C(d,i,a)*r,o=C(d,e,a)*r,l=0;for(let c=0;;c++){t.setFrame(c,h,n,o);const u=s[c+1];if(!u)return t.shrink(l),t;const m=C(u,"time",0),g=C(u,i,a)*r,w=C(u,e,a)*r,M=d.curve;M&&(l=L(M,t,l,c,0,h,m,n,g,r),l=L(M,t,l,c,1,h,m,o,w,r)),h=m,n=g,o=w,d=u}}function L(s,t,i,e,a,r,d,h,n,o){if(s=="stepped")return t.setStepped(e),i;const l=a<<2,c=s[l],u=s[l+1]*o,m=s[l+2],g=s[l+3]*o;return t.setBezier(i,e,a,r,h,c,u,m,g,d,n),i+1}function C(s,t,i){return s[t]!==void 0?s[t]:i}class Cn extends f.SpineBase{createSkeleton(t){this.skeleton=new pe(t),this.skeleton.updateWorldTransform(),this.stateData=new Ee(t),this.state=new Mt(this.stateData)}}return F.AlphaTimeline=Zt,F.Animation=Xt,F.AnimationState=Mt,F.AnimationStateAdapter=Ke,F.AnimationStateData=Ee,F.AtlasAttachmentLoader=Ze,F.Attachment=qt,F.AttachmentTimeline=pt,F.Bone=ce,F.BoneData=de,F.BoundingBoxAttachment=bt,F.ClippingAttachment=Yt,F.ConstraintData=Rt,F.CurveTimeline=tt,F.CurveTimeline1=et,F.CurveTimeline2=Ut,F.DeformTimeline=ne,F.DrawOrderTimeline=xt,F.Event=me,F.EventData=ue,F.EventQueue=Te,F.EventTimeline=At,F.EventType=K,F.IkConstraint=Re,F.IkConstraintData=fe,F.IkConstraintTimeline=se,F.MeshAttachment=ft,F.PathAttachment=gt,F.PathConstraint=yt,F.PathConstraintData=ge,F.PathConstraintMixTimeline=oe,F.PathConstraintPositionTimeline=ae,F.PathConstraintSpacingTimeline=re,F.PointAttachment=vt,F.RGB2Timeline=ee,F.RGBA2Timeline=te,F.RGBATimeline=Jt,F.RGBTimeline=Qt,F.RegionAttachment=q,F.RotateTimeline=Bt,F.ScaleTimeline=zt,F.ScaleXTimeline=_t,F.ScaleYTimeline=jt,F.Sequence=Ft,F.SequenceMode=at,F.SequenceModeValues=Lt,F.SequenceTimeline=wt,F.ShearTimeline=Gt,F.ShearXTimeline=Ht,F.ShearYTimeline=Kt,F.Skeleton=pe,F.SkeletonBinary=$e,F.SkeletonBounds=Bn,F.SkeletonData=xe,F.SkeletonJson=Se,F.Skin=Dt,F.SkinEntry=ye,F.Slot=De,F.SlotData=we,F.SpacingMode=G,F.Spine=Cn,F.Timeline=_,F.TrackEntry=Et,F.TransformConstraint=Pe,F.TransformConstraintData=Me,F.TransformConstraintTimeline=ie,F.TranslateTimeline=Wt,F.TranslateXTimeline=Nt,F.TranslateYTimeline=Ot,F.VertexAttachment=Z,F}({},PIXI.spine,pixi_js);
//# sourceMappingURL=runtime-4.1.js.map
