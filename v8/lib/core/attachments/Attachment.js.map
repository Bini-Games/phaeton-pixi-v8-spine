{"version":3,"file":"Attachment.js","sources":["../../../src/core/attachments/Attachment.ts"],"sourcesContent":["import { AttachmentType, Utils } from '@pixi-spine/base';\r\nimport type { IAttachment, NumberArrayLike } from '@pixi-spine/base';\r\n\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * The base class for all attachments.\r\n * @public\r\n */\r\nexport abstract class Attachment implements IAttachment {\r\n    name: string;\r\n    type: AttachmentType;\r\n\r\n    constructor(name: string) {\r\n        if (!name) throw new Error('name cannot be null.');\r\n        this.name = name;\r\n    }\r\n\r\n    abstract copy(): Attachment;\r\n}\r\n\r\n/**\r\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\r\n * {@link Slot#deform}.\r\n * @public\r\n */\r\nexport abstract class VertexAttachment extends Attachment {\r\n    private static nextID = 0;\r\n\r\n    /** The unique ID for this attachment. */\r\n    id = VertexAttachment.nextID++;\r\n\r\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\r\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\r\n     * if this attachment has no weights. */\r\n    bones: Array<number> | null = null;\r\n\r\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\r\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\r\n     * each vertex. */\r\n    vertices: NumberArrayLike = [];\r\n\r\n    /** The maximum number of world vertex values that can be output by\r\n     * {@link #computeWorldVertices()} using the `count` parameter. */\r\n    worldVerticesLength = 0;\r\n\r\n    /** Timelines for the timeline attachment are also applied to this attachment.\r\n     * May be null if no attachment-specific timelines should be applied. */\r\n    timelineAttachment: Attachment = this;\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n    }\r\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\r\n     * not empty, it is used to deform the vertices.\r\n     *\r\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\r\n     * Runtimes Guide.\r\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\r\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\r\n     *           `stride` / 2.\r\n     * @param offset The `worldVertices` index to begin writing values.\r\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        count = offset + (count >> 1) * stride;\r\n        const skeleton = slot.bone.skeleton;\r\n        const deformArray = slot.deform;\r\n        let vertices = this.vertices;\r\n        const bones = this.bones;\r\n\r\n        if (!bones) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            const mat = slot.bone.matrix;\r\n            const x = mat.tx;\r\n            const y = mat.ty;\r\n            const a = mat.a;\r\n            const b = mat.c;\r\n            const c = mat.b;\r\n            const d = mat.d;\r\n\r\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                const vx = vertices[v];\r\n                const vy = vertices[v + 1];\r\n\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n\r\n            return;\r\n        }\r\n        let v = 0;\r\n        let skip = 0;\r\n\r\n        for (let i = 0; i < start; i += 2) {\r\n            const n = bones[v];\r\n\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        const skeletonBones = skeleton.bones;\r\n\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b];\r\n                    const vy = vertices[b + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            const deform = deformArray;\r\n\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                let wx = 0;\r\n                let wy = 0;\r\n                let n = bones[v++];\r\n\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    const mat = skeletonBones[bones[v]].matrix;\r\n                    const vx = vertices[b] + deform[f];\r\n                    const vy = vertices[b + 1] + deform[f + 1];\r\n                    const weight = vertices[b + 2];\r\n\r\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Does not copy id (generated) or name (set on construction). **/\r\n    copyTo(attachment: VertexAttachment) {\r\n        if (this.bones) {\r\n            attachment.bones = new Array<number>(this.bones.length);\r\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n        } else attachment.bones = null;\r\n\r\n        if (this.vertices) {\r\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n        }\r\n\r\n        attachment.worldVerticesLength = this.worldVerticesLength;\r\n        attachment.timelineAttachment = this.timelineAttachment;\r\n    }\r\n}\r\n"],"names":["v","Utils"],"mappings":"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"}