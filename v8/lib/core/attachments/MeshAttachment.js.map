{"version":3,"file":"MeshAttachment.js","sources":["../../../src/core/attachments/MeshAttachment.ts"],"sourcesContent":["import { Attachment, VertexAttachment } from './Attachment';\r\nimport { AttachmentType, Color, IMeshAttachment, IHasTextureRegion, NumberArrayLike, TextureRegion, Utils } from '@pixi-spine/base';\r\nimport type { Sequence } from './Sequence';\r\nimport type { Slot } from '../Slot';\r\n\r\n/**\r\n * @public\r\n */\r\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment, IHasTextureRegion {\r\n    type = AttachmentType.Mesh;\r\n\r\n    region: TextureRegion | null = null;\r\n\r\n    /** The name of the texture region for this attachment. */\r\n    path: string;\r\n\r\n    /** The UV pair for each vertex, normalized within the texture region. */\r\n    regionUVs: Float32Array;\r\n\r\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\r\n    triangles: Array<number> = [];\r\n\r\n    /** The color to tint the mesh. */\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\r\n    width = 0;\r\n\r\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\r\n    height = 0;\r\n\r\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\r\n    hullLength = 0;\r\n\r\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\r\n     * nonessential data was exported. Triangulation is not performed at runtime. */\r\n    edges: Array<number> = [];\r\n\r\n    private parentMesh: MeshAttachment | null = null;\r\n\r\n    sequence: Sequence | null = null;\r\n\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor(name: string, path: string) {\r\n        super(name);\r\n        this.path = path;\r\n    }\r\n\r\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\r\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\r\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\r\n    getParentMesh() {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh(parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n        }\r\n    }\r\n\r\n    copy(): Attachment {\r\n        if (this.parentMesh) return this.newLinkedMesh();\r\n\r\n        const copy = new MeshAttachment(this.name, this.path);\r\n\r\n        copy.region = this.region;\r\n        copy.color.setFromColor(this.color);\r\n\r\n        this.copyTo(copy);\r\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n        copy.triangles = new Array<number>(this.triangles.length);\r\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n        copy.hullLength = this.hullLength;\r\n\r\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\r\n\r\n        // Nonessential.\r\n        if (this.edges) {\r\n            copy.edges = new Array<number>(this.edges.length);\r\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n        }\r\n        copy.width = this.width;\r\n        copy.height = this.height;\r\n\r\n        return copy;\r\n    }\r\n\r\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\r\n        if (this.sequence != null) this.sequence.apply(slot, this);\r\n        super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\r\n    }\r\n\r\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\r\n    newLinkedMesh(): MeshAttachment {\r\n        const copy = new MeshAttachment(this.name, this.path);\r\n\r\n        copy.region = this.region;\r\n        copy.color.setFromColor(this.color);\r\n        copy.timelineAttachment = this.timelineAttachment;\r\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\r\n        // if (copy.region != null) copy.updateRegion();\r\n\r\n        return copy;\r\n    }\r\n}\r\n"],"names":["VertexAttachment","AttachmentType","Color","Utils"],"mappings":";;;;;AAQO,MAAM,uBAAuBA,2BAA+D,CAAA;AAAA,EAoC/F,WAAA,CAAY,MAAc,IAAc,EAAA;AACpC,IAAA,KAAA,CAAM,IAAI,CAAA,CAAA;AApCd,IAAA,IAAA,CAAA,IAAA,GAAOC,mBAAe,CAAA,IAAA,CAAA;AAEtB,IAA+B,IAAA,CAAA,MAAA,GAAA,IAAA,CAAA;AAS/B;AAAA,IAAA,IAAA,CAAA,SAAA,GAA2B,EAAC,CAAA;AAG5B;AAAA,IAAA,IAAA,CAAA,KAAA,GAAQ,IAAIC,UAAA,CAAM,CAAG,EAAA,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAG5B;AAAA,IAAQ,IAAA,CAAA,KAAA,GAAA,CAAA,CAAA;AAGR;AAAA,IAAS,IAAA,CAAA,MAAA,GAAA,CAAA,CAAA;AAGT;AAAA,IAAa,IAAA,CAAA,UAAA,GAAA,CAAA,CAAA;AAIb;AAAA;AAAA,IAAA,IAAA,CAAA,KAAA,GAAuB,EAAC,CAAA;AAExB,IAAA,IAAA,CAAQ,UAAoC,GAAA,IAAA,CAAA;AAE5C,IAA4B,IAAA,CAAA,QAAA,GAAA,IAAA,CAAA;AAE5B,IAAA,IAAA,CAAA,SAAA,GAAY,IAAIA,UAAA,CAAM,CAAG,EAAA,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAI5B,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAAA,GAChB;AAAA;AAAA;AAAA;AAAA,EAKA,aAAgB,GAAA;AACZ,IAAA,OAAO,IAAK,CAAA,UAAA,CAAA;AAAA,GAChB;AAAA;AAAA,EAGA,cAAc,UAA4B,EAAA;AACtC,IAAA,IAAA,CAAK,UAAa,GAAA,UAAA,CAAA;AAClB,IAAA,IAAI,UAAY,EAAA;AACZ,MAAA,IAAA,CAAK,QAAQ,UAAW,CAAA,KAAA,CAAA;AACxB,MAAA,IAAA,CAAK,WAAW,UAAW,CAAA,QAAA,CAAA;AAC3B,MAAA,IAAA,CAAK,sBAAsB,UAAW,CAAA,mBAAA,CAAA;AACtC,MAAA,IAAA,CAAK,YAAY,UAAW,CAAA,SAAA,CAAA;AAC5B,MAAA,IAAA,CAAK,YAAY,UAAW,CAAA,SAAA,CAAA;AAC5B,MAAA,IAAA,CAAK,aAAa,UAAW,CAAA,UAAA,CAAA;AAC7B,MAAA,IAAA,CAAK,sBAAsB,UAAW,CAAA,mBAAA,CAAA;AAAA,KAC1C;AAAA,GACJ;AAAA,EAEA,IAAmB,GAAA;AACf,IAAA,IAAI,IAAK,CAAA,UAAA;AAAY,MAAA,OAAO,KAAK,aAAc,EAAA,CAAA;AAE/C,IAAA,MAAM,OAAO,IAAI,cAAA,CAAe,IAAK,CAAA,IAAA,EAAM,KAAK,IAAI,CAAA,CAAA;AAEpD,IAAA,IAAA,CAAK,SAAS,IAAK,CAAA,MAAA,CAAA;AACnB,IAAK,IAAA,CAAA,KAAA,CAAM,YAAa,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;AAElC,IAAA,IAAA,CAAK,OAAO,IAAI,CAAA,CAAA;AAChB,IAAA,IAAA,CAAK,SAAY,GAAA,IAAI,YAAa,CAAA,IAAA,CAAK,UAAU,MAAM,CAAA,CAAA;AACvD,IAAMC,UAAA,CAAA,SAAA,CAAU,KAAK,SAAW,EAAA,CAAA,EAAG,KAAK,SAAW,EAAA,CAAA,EAAG,IAAK,CAAA,SAAA,CAAU,MAAM,CAAA,CAAA;AAC3E,IAAA,IAAA,CAAK,SAAY,GAAA,IAAI,KAAc,CAAA,IAAA,CAAK,UAAU,MAAM,CAAA,CAAA;AACxD,IAAMA,UAAA,CAAA,SAAA,CAAU,KAAK,SAAW,EAAA,CAAA,EAAG,KAAK,SAAW,EAAA,CAAA,EAAG,IAAK,CAAA,SAAA,CAAU,MAAM,CAAA,CAAA;AAC3E,IAAA,IAAA,CAAK,aAAa,IAAK,CAAA,UAAA,CAAA;AAEvB,IAAA,IAAA,CAAK,WAAW,IAAK,CAAA,QAAA,IAAY,OAAO,IAAK,CAAA,QAAA,CAAS,MAAS,GAAA,IAAA,CAAA;AAG/D,IAAA,IAAI,KAAK,KAAO,EAAA;AACZ,MAAA,IAAA,CAAK,KAAQ,GAAA,IAAI,KAAc,CAAA,IAAA,CAAK,MAAM,MAAM,CAAA,CAAA;AAChD,MAAMA,UAAA,CAAA,SAAA,CAAU,KAAK,KAAO,EAAA,CAAA,EAAG,KAAK,KAAO,EAAA,CAAA,EAAG,IAAK,CAAA,KAAA,CAAM,MAAM,CAAA,CAAA;AAAA,KACnE;AACA,IAAA,IAAA,CAAK,QAAQ,IAAK,CAAA,KAAA,CAAA;AAClB,IAAA,IAAA,CAAK,SAAS,IAAK,CAAA,MAAA,CAAA;AAEnB,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAEA,qBAAqB,IAAY,EAAA,KAAA,EAAe,KAAe,EAAA,aAAA,EAAgC,QAAgB,MAAgB,EAAA;AAC3H,IAAA,IAAI,KAAK,QAAY,IAAA,IAAA;AAAM,MAAK,IAAA,CAAA,QAAA,CAAS,KAAM,CAAA,IAAA,EAAM,IAAI,CAAA,CAAA;AACzD,IAAA,KAAA,CAAM,qBAAqB,IAAM,EAAA,KAAA,EAAO,KAAO,EAAA,aAAA,EAAe,QAAQ,MAAM,CAAA,CAAA;AAAA,GAChF;AAAA;AAAA,EAGA,aAAgC,GAAA;AAC5B,IAAA,MAAM,OAAO,IAAI,cAAA,CAAe,IAAK,CAAA,IAAA,EAAM,KAAK,IAAI,CAAA,CAAA;AAEpD,IAAA,IAAA,CAAK,SAAS,IAAK,CAAA,MAAA,CAAA;AACnB,IAAK,IAAA,CAAA,KAAA,CAAM,YAAa,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;AAClC,IAAA,IAAA,CAAK,qBAAqB,IAAK,CAAA,kBAAA,CAAA;AAC/B,IAAA,IAAA,CAAK,aAAc,CAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAK,aAAa,IAAI,CAAA,CAAA;AAG3D,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AACJ;;;;"}