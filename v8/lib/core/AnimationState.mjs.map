{"version":3,"file":"AnimationState.mjs","sources":["../../src/core/AnimationState.ts"],"sourcesContent":["import { IAnimationState, IAnimationStateListener, ITrackEntry, MathUtils, MixBlend, MixDirection, Pool, StringSet, Utils } from '@pixi-spine/base';\r\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\r\nimport type { AnimationStateData } from './AnimationStateData';\r\nimport type { Event } from './Event';\r\nimport type { Skeleton } from './Skeleton';\r\nimport type { Slot } from './Slot';\r\n\r\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\r\n * multiple animations on top of each other (layering).\r\n *\r\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\r\n * @public\r\n * */\r\nexport class AnimationState implements IAnimationState<AnimationStateData> {\r\n    static _emptyAnimation = new Animation('<empty>', [], 0);\r\n    private static emptyAnimation(): Animation {\r\n        return AnimationState._emptyAnimation;\r\n    }\r\n\r\n    /** The AnimationStateData to look up mix durations. */\r\n    data: AnimationStateData;\r\n\r\n    /** The list of tracks that currently have animations, which may contain null entries. */\r\n    tracks = new Array<TrackEntry | null>();\r\n\r\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\r\n     * or faster. Defaults to 1.\r\n     *\r\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\r\n    timeScale = 1;\r\n    unkeyedState = 0;\r\n\r\n    events = new Array<Event>();\r\n    listeners = new Array<AnimationStateListener>();\r\n    queue = new EventQueue(this);\r\n    propertyIDs = new StringSet();\r\n    animationsChanged = false;\r\n\r\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\r\n\r\n    constructor(data: AnimationStateData) {\r\n        this.data = data;\r\n    }\r\n\r\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\r\n    update(delta: number) {\r\n        delta *= this.timeScale;\r\n        const tracks = this.tracks;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            const current = tracks[i];\r\n\r\n            if (!current) continue;\r\n\r\n            current.animationLast = current.nextAnimationLast;\r\n            current.trackLast = current.nextTrackLast;\r\n\r\n            let currentDelta = delta * current.timeScale;\r\n\r\n            if (current.delay > 0) {\r\n                current.delay -= currentDelta;\r\n                if (current.delay > 0) continue;\r\n                currentDelta = -current.delay;\r\n                current.delay = 0;\r\n            }\r\n\r\n            let next = current.next;\r\n\r\n            if (next) {\r\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\r\n                const nextTime = current.trackLast - next.delay;\r\n\r\n                if (nextTime >= 0) {\r\n                    next.delay = 0;\r\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\r\n                    current.trackTime += currentDelta;\r\n                    this.setCurrent(i, next, true);\r\n                    while (next.mixingFrom) {\r\n                        next.mixTime += delta;\r\n                        next = next.mixingFrom;\r\n                    }\r\n                    continue;\r\n                }\r\n            } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\r\n                tracks[i] = null;\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                continue;\r\n            }\r\n            if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\r\n                // End mixing from entries once all have completed.\r\n                let from: TrackEntry | null = current.mixingFrom;\r\n\r\n                current.mixingFrom = null;\r\n                if (from) from.mixingTo = null;\r\n                while (from) {\r\n                    this.queue.end(from);\r\n                    from = from.mixingFrom;\r\n                }\r\n            }\r\n\r\n            current.trackTime += currentDelta;\r\n        }\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Returns true when all mixing from entries are complete. */\r\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\r\n        const from = to.mixingFrom;\r\n\r\n        if (!from) return true;\r\n\r\n        const finished = this.updateMixingFrom(from, delta);\r\n\r\n        from.animationLast = from.nextAnimationLast;\r\n        from.trackLast = from.nextTrackLast;\r\n\r\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\r\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\r\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\r\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n                to.mixingFrom = from.mixingFrom;\r\n                if (from.mixingFrom) from.mixingFrom.mixingTo = to;\r\n                to.interruptAlpha = from.interruptAlpha;\r\n                this.queue.end(from);\r\n            }\r\n\r\n            return finished;\r\n        }\r\n\r\n        from.trackTime += delta * from.timeScale;\r\n        to.mixTime += delta;\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\r\n     * animation state can be applied to multiple skeletons to pose them identically.\r\n     * @returns True if any animations were applied. */\r\n    apply(skeleton: Skeleton): boolean {\r\n        if (!skeleton) throw new Error('skeleton cannot be null.');\r\n        if (this.animationsChanged) this._animationsChanged();\r\n\r\n        const events = this.events;\r\n        const tracks = this.tracks;\r\n        let applied = false;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            const current = tracks[i];\r\n\r\n            if (!current || current.delay > 0) continue;\r\n            applied = true;\r\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\r\n\r\n            // Apply mixing from entries first.\r\n            let mix = current.alpha;\r\n\r\n            if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);\r\n            else if (current.trackTime >= current.trackEnd && !current.next) mix = 0;\r\n\r\n            // Apply current entry.\r\n            const animationLast = current.animationLast;\r\n            const animationTime = current.getAnimationTime();\r\n            let applyTime = animationTime;\r\n            let applyEvents: Event[] | null = events;\r\n\r\n            if (current.reverse) {\r\n                applyTime = current.animation.duration - applyTime;\r\n                applyEvents = null;\r\n            }\r\n            const timelines = current.animation.timelines;\r\n            const timelineCount = timelines.length;\r\n\r\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\r\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\r\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\r\n                    Utils.webkit602BugfixHelper(mix, blend);\r\n                    const timeline = timelines[ii];\r\n\r\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\r\n                }\r\n            } else {\r\n                const timelineMode = current.timelineMode;\r\n\r\n                const shortestRotation = current.shortestRotation;\r\n                const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\r\n\r\n                if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\r\n\r\n                for (let ii = 0; ii < timelineCount; ii++) {\r\n                    const timeline = timelines[ii];\r\n                    const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\r\n\r\n                    if (!shortestRotation && timeline instanceof RotateTimeline) {\r\n                        this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\r\n                    } else if (timeline instanceof AttachmentTimeline) {\r\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\r\n                    } else {\r\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                        Utils.webkit602BugfixHelper(mix, blend);\r\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\r\n                    }\r\n                }\r\n            }\r\n            this.queueEvents(current, animationTime);\r\n            events.length = 0;\r\n            current.nextAnimationLast = animationTime;\r\n            current.nextTrackLast = current.trackTime;\r\n        }\r\n\r\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\r\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\r\n        // the time is before the first key).\r\n        const setupState = this.unkeyedState + SETUP;\r\n        const slots = skeleton.slots;\r\n\r\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\r\n            const slot = slots[i];\r\n\r\n            if (slot.attachmentState == setupState) {\r\n                const attachmentName = slot.data.attachmentName;\r\n\r\n                slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n            }\r\n        }\r\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\r\n\r\n        this.queue.drain();\r\n\r\n        return applied;\r\n    }\r\n\r\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\r\n        const from = to.mixingFrom;\r\n\r\n        if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\r\n\r\n        let mix = 0;\r\n\r\n        if (to.mixDuration == 0) {\r\n            // Single frame mix to undo mixingFrom changes.\r\n            mix = 1;\r\n            if (blend == MixBlend.first) blend = MixBlend.setup;\r\n        } else {\r\n            mix = to.mixTime / to.mixDuration;\r\n            if (mix > 1) mix = 1;\r\n            if (blend != MixBlend.first) blend = from.mixBlend;\r\n        }\r\n\r\n        const attachments = mix < from.attachmentThreshold;\r\n        const drawOrder = mix < from.drawOrderThreshold;\r\n        const timelines = from.animation.timelines;\r\n        const timelineCount = timelines.length;\r\n        const alphaHold = from.alpha * to.interruptAlpha;\r\n        const alphaMix = alphaHold * (1 - mix);\r\n        const animationLast = from.animationLast;\r\n        const animationTime = from.getAnimationTime();\r\n        let applyTime = animationTime;\r\n        let events = null;\r\n\r\n        if (from.reverse) applyTime = from.animation.duration - applyTime;\r\n        else if (mix < from.eventThreshold) events = this.events;\r\n\r\n        if (blend == MixBlend.add) {\r\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\r\n        } else {\r\n            const timelineMode = from.timelineMode;\r\n            const timelineHoldMix = from.timelineHoldMix;\r\n\r\n            const shortestRotation = from.shortestRotation;\r\n            const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\r\n\r\n            if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\r\n\r\n            from.totalAlpha = 0;\r\n            for (let i = 0; i < timelineCount; i++) {\r\n                const timeline = timelines[i];\r\n                let direction = MixDirection.mixOut;\r\n                let timelineBlend: MixBlend;\r\n                let alpha = 0;\r\n\r\n                switch (timelineMode[i]) {\r\n                    case SUBSEQUENT:\r\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\r\n                        timelineBlend = blend;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaMix;\r\n                        break;\r\n                    case HOLD_SUBSEQUENT:\r\n                        timelineBlend = blend;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    case HOLD_FIRST:\r\n                        timelineBlend = MixBlend.setup;\r\n                        alpha = alphaHold;\r\n                        break;\r\n                    default:\r\n                        timelineBlend = MixBlend.setup;\r\n                        const holdMix = timelineHoldMix[i];\r\n\r\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\r\n                        break;\r\n                }\r\n                from.totalAlpha += alpha;\r\n\r\n                if (!shortestRotation && timeline instanceof RotateTimeline)\r\n                    this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\r\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\r\n                else {\r\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\r\n                    Utils.webkit602BugfixHelper(alpha, blend);\r\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\r\n                    timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\r\n        this.events.length = 0;\r\n        from.nextAnimationLast = animationTime;\r\n        from.nextTrackLast = from.trackTime;\r\n\r\n        return mix;\r\n    }\r\n\r\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\r\n        const slot = skeleton.slots[timeline.slotIndex];\r\n\r\n        if (!slot.bone.active) return;\r\n\r\n        if (time < timeline.frames[0]) {\r\n            // Time is before first frame.\r\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\r\n        } else this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\r\n\r\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\r\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\r\n    }\r\n\r\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null, attachments: boolean) {\r\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\r\n        if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\r\n    }\r\n\r\n    applyRotateTimeline(\r\n        timeline: RotateTimeline,\r\n        skeleton: Skeleton,\r\n        time: number,\r\n        alpha: number,\r\n        blend: MixBlend,\r\n        timelinesRotation: Array<number>,\r\n        i: number,\r\n        firstFrame: boolean\r\n    ) {\r\n        if (firstFrame) timelinesRotation[i] = 0;\r\n\r\n        if (alpha == 1) {\r\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\r\n\r\n            return;\r\n        }\r\n\r\n        const bone = skeleton.bones[timeline.boneIndex];\r\n\r\n        if (!bone.active) return;\r\n        const frames = timeline.frames;\r\n        let r1 = 0;\r\n        let r2 = 0;\r\n\r\n        if (time < frames[0]) {\r\n            switch (blend) {\r\n                case MixBlend.setup:\r\n                    bone.rotation = bone.data.rotation;\r\n                default:\r\n                    return;\r\n                case MixBlend.first:\r\n                    r1 = bone.rotation;\r\n                    r2 = bone.data.rotation;\r\n            }\r\n        } else {\r\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\r\n            r2 = bone.data.rotation + timeline.getCurveValue(time);\r\n        }\r\n\r\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\r\n        let total = 0;\r\n        let diff = r2 - r1;\r\n\r\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n        if (diff == 0) {\r\n            total = timelinesRotation[i];\r\n        } else {\r\n            let lastTotal = 0;\r\n            let lastDiff = 0;\r\n\r\n            if (firstFrame) {\r\n                lastTotal = 0;\r\n                lastDiff = diff;\r\n            } else {\r\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\r\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\r\n            }\r\n            const current = diff > 0;\r\n            let dir = lastTotal >= 0;\r\n            // Detect cross at 0 (not 180).\r\n\r\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n                // A cross after a 360 rotation is a loop.\r\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\r\n                dir = current;\r\n            }\r\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\r\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\r\n            timelinesRotation[i] = total;\r\n        }\r\n        timelinesRotation[i + 1] = diff;\r\n        bone.rotation = r1 + total * alpha;\r\n    }\r\n\r\n    queueEvents(entry: TrackEntry, animationTime: number) {\r\n        const animationStart = entry.animationStart;\r\n        const animationEnd = entry.animationEnd;\r\n        const duration = animationEnd - animationStart;\r\n        const trackLastWrapped = entry.trackLast % duration;\r\n\r\n        // Queue events before complete.\r\n        const events = this.events;\r\n        let i = 0;\r\n        const n = events.length;\r\n\r\n        for (; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.time < trackLastWrapped) break;\r\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n\r\n        // Queue complete if completed a loop iteration or the animation.\r\n        let complete = false;\r\n\r\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n        if (complete) this.queue.complete(entry);\r\n\r\n        // Queue events after complete.\r\n        for (; i < n; i++) {\r\n            const event = events[i];\r\n\r\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\r\n            this.queue.event(entry, event);\r\n        }\r\n    }\r\n\r\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTracks() {\r\n        const oldDrainDisabled = this.queue.drainDisabled;\r\n\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    /** Removes all animations from the track, leaving skeletons in their current pose.\r\n     *\r\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\r\n     * rather than leaving them in their current pose. */\r\n    clearTrack(trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        const current = this.tracks[trackIndex];\r\n\r\n        if (!current) return;\r\n\r\n        this.queue.end(current);\r\n\r\n        this.clearNext(current);\r\n\r\n        let entry = current;\r\n\r\n        while (true) {\r\n            const from = entry.mixingFrom;\r\n\r\n            if (!from) break;\r\n            this.queue.end(from);\r\n            entry.mixingFrom = null;\r\n            entry.mixingTo = null;\r\n            entry = from;\r\n        }\r\n\r\n        this.tracks[current.trackIndex] = null;\r\n\r\n        this.queue.drain();\r\n    }\r\n\r\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\r\n        const from = this.expandToIndex(index);\r\n\r\n        this.tracks[index] = current;\r\n        current.previous = null;\r\n\r\n        if (from) {\r\n            if (interrupt) this.queue.interrupt(from);\r\n            current.mixingFrom = from;\r\n            from.mixingTo = current;\r\n            current.mixTime = 0;\r\n\r\n            // Store the interrupted mix percentage.\r\n            if (from.mixingFrom && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\r\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\r\n        }\r\n\r\n        this.queue.start(current);\r\n    }\r\n\r\n    /** Sets an animation by name.\r\n     *\r\n     * See {@link #setAnimationWith()}. */\r\n    setAnimation(trackIndex: number, animationName: string, loop = false) {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\r\n\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\r\n     * applied to a skeleton, it is replaced (not mixed from).\r\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    setAnimationWith(trackIndex: number, animation: Animation, loop = false) {\r\n        if (!animation) throw new Error('animation cannot be null.');\r\n        let interrupt = true;\r\n        let current = this.expandToIndex(trackIndex);\r\n\r\n        if (current) {\r\n            if (current.nextTrackLast == -1) {\r\n                // Don't mix from an entry that was never applied.\r\n                this.tracks[trackIndex] = current.mixingFrom;\r\n                this.queue.interrupt(current);\r\n                this.queue.end(current);\r\n                this.clearNext(current);\r\n                current = current.mixingFrom;\r\n                interrupt = false;\r\n            } else this.clearNext(current);\r\n        }\r\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\r\n\r\n        this.setCurrent(trackIndex, entry, interrupt);\r\n        this.queue.drain();\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Queues an animation by name.\r\n     *\r\n     * See {@link #addAnimationWith()}. */\r\n    addAnimation(trackIndex: number, animationName: string, loop = false, delay = 0) {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\r\n\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\r\n     * equivalent to calling {@link #setAnimationWith()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\r\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\r\n     *           previous entry is looping, its next loop completion is used instead of its duration.\r\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addAnimationWith(trackIndex: number, animation: Animation, loop = false, delay = 0) {\r\n        if (!animation) throw new Error('animation cannot be null.');\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n\r\n        if (last) {\r\n            while (last.next) last = last.next;\r\n        }\r\n\r\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\r\n        if (!last) {\r\n            this.setCurrent(trackIndex, entry, true);\r\n            this.queue.drain();\r\n        } else {\r\n            last.next = entry;\r\n            entry.previous = last;\r\n            if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\r\n        }\r\n\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\r\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\r\n     *\r\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\r\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\r\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\r\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\r\n     * 0 still mixes out over one frame.\r\n     *\r\n     * Mixing in is done by first setting an empty animation, then adding an animation using\r\n     * {@link #addAnimation()} and on the returned track entry, set the\r\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\r\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\r\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\r\n    setEmptyAnimation(trackIndex: number, mixDuration = 0) {\r\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\r\n\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\r\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\r\n     * {@link #setEmptyAnimation()}.\r\n     *\r\n     * See {@link #setEmptyAnimation()}.\r\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\r\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\r\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\r\n     *           loop completion is used instead of its duration.\r\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\r\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\r\n    addEmptyAnimation(trackIndex: number, mixDuration = 0, delay = 0) {\r\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\r\n\r\n        if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\r\n        entry.mixDuration = mixDuration;\r\n        entry.trackEnd = mixDuration;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\r\n     * duration. */\r\n    setEmptyAnimations(mixDuration = 0) {\r\n        const oldDrainDisabled = this.queue.drainDisabled;\r\n\r\n        this.queue.drainDisabled = true;\r\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\r\n            const current = this.tracks[i];\r\n\r\n            if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\r\n        }\r\n        this.queue.drainDisabled = oldDrainDisabled;\r\n        this.queue.drain();\r\n    }\r\n\r\n    expandToIndex(index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\r\n        this.tracks.length = index + 1;\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @param last May be null. */\r\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry | null) {\r\n        const entry = this.trackEntryPool.obtain();\r\n\r\n        entry.reset();\r\n        entry.trackIndex = trackIndex;\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.holdPrevious = false;\r\n\r\n        entry.reverse = false;\r\n        entry.shortestRotation = false;\r\n\r\n        entry.eventThreshold = 0;\r\n        entry.attachmentThreshold = 0;\r\n        entry.drawOrderThreshold = 0;\r\n\r\n        entry.animationStart = 0;\r\n        entry.animationEnd = animation.duration;\r\n        entry.animationLast = -1;\r\n        entry.nextAnimationLast = -1;\r\n\r\n        entry.delay = 0;\r\n        entry.trackTime = 0;\r\n        entry.trackLast = -1;\r\n        entry.nextTrackLast = -1;\r\n        entry.trackEnd = Number.MAX_VALUE;\r\n        entry.timeScale = 1;\r\n\r\n        entry.alpha = 1;\r\n        entry.mixTime = 0;\r\n        entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\r\n        entry.interruptAlpha = 1;\r\n        entry.totalAlpha = 0;\r\n        entry.mixBlend = MixBlend.replace;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\r\n    clearNext(entry: TrackEntry) {\r\n        let next = entry.next;\r\n\r\n        while (next) {\r\n            this.queue.dispose(next);\r\n            next = next.next;\r\n        }\r\n        entry.next = null;\r\n    }\r\n\r\n    _animationsChanged() {\r\n        this.animationsChanged = false;\r\n\r\n        this.propertyIDs.clear();\r\n        const tracks = this.tracks;\r\n\r\n        for (let i = 0, n = tracks.length; i < n; i++) {\r\n            let entry = tracks[i];\r\n\r\n            if (!entry) continue;\r\n            while (entry.mixingFrom) entry = entry.mixingFrom;\r\n            do {\r\n                if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\r\n                entry = entry.mixingTo;\r\n            } while (entry);\r\n        }\r\n    }\r\n\r\n    computeHold(entry: TrackEntry) {\r\n        const to = entry.mixingTo;\r\n        const timelines = entry.animation.timelines;\r\n        const timelinesCount = entry.animation.timelines.length;\r\n        const timelineMode = entry.timelineMode;\r\n\r\n        timelineMode.length = timelinesCount;\r\n        const timelineHoldMix = entry.timelineHoldMix;\r\n\r\n        timelineHoldMix.length = 0;\r\n        const propertyIDs = this.propertyIDs;\r\n\r\n        if (to && to.holdPrevious) {\r\n            for (let i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\r\n\r\n            return;\r\n        }\r\n\r\n        // eslint-disable-next-line no-restricted-syntax, no-labels\r\n        outer: for (let i = 0; i < timelinesCount; i++) {\r\n            const timeline = timelines[i];\r\n            const ids = timeline.getPropertyIds();\r\n\r\n            if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;\r\n            else if (\r\n                !to ||\r\n                timeline instanceof AttachmentTimeline ||\r\n                timeline instanceof DrawOrderTimeline ||\r\n                timeline instanceof EventTimeline ||\r\n                !to.animation.hasTimeline(ids)\r\n            ) {\r\n                timelineMode[i] = FIRST;\r\n            } else {\r\n                for (let next = to.mixingTo; next; next = next.mixingTo) {\r\n                    if (next.animation.hasTimeline(ids)) continue;\r\n                    if (entry.mixDuration > 0) {\r\n                        timelineMode[i] = HOLD_MIX;\r\n                        timelineHoldMix[i] = next;\r\n                        // eslint-disable-next-line no-labels\r\n                        continue outer;\r\n                    }\r\n                    break;\r\n                }\r\n                timelineMode[i] = HOLD_FIRST;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\r\n    getCurrent(trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    /** Adds a listener to receive events for all track entries. */\r\n    addListener(listener: AnimationStateListener) {\r\n        if (!listener) throw new Error('listener cannot be null.');\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    /** Removes the listener added with {@link #addListener()}. */\r\n    removeListener(listener: AnimationStateListener) {\r\n        const index = this.listeners.indexOf(listener);\r\n\r\n        if (index >= 0) this.listeners.splice(index, 1);\r\n    }\r\n\r\n    /** Removes all listeners added with {@link #addListener()}. */\r\n    clearListeners() {\r\n        this.listeners.length = 0;\r\n    }\r\n\r\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\r\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\r\n     * are not wanted because new animations are being set. */\r\n    clearListenerNotifications() {\r\n        this.queue.clear();\r\n    }\r\n\r\n    // deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1 = false;\r\n\r\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2 = false;\r\n\r\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3 = false;\r\n\r\n    hasAnimation(animationName: string): boolean {\r\n        const animation = this.data.skeletonData.findAnimation(animationName);\r\n\r\n        return animation !== null;\r\n    }\r\n\r\n    hasAnimationByName(animationName: string): boolean {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\r\n        }\r\n\r\n        return this.hasAnimation(animationName);\r\n    }\r\n}\r\n\r\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\r\n *\r\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\r\n * @public\r\n * */\r\nexport class TrackEntry implements ITrackEntry {\r\n    /** The animation to apply for this track entry. */\r\n    animation: Animation | null = null;\r\n\r\n    previous: TrackEntry | null = null;\r\n\r\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\r\n    next: TrackEntry | null = null;\r\n\r\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\r\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\r\n    mixingFrom: TrackEntry | null = null;\r\n\r\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\r\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\r\n    mixingTo: TrackEntry | null = null;\r\n\r\n    /** The listener for events generated by this track entry, or null.\r\n     *\r\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\r\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\r\n    listener: AnimationStateListener | null = null;\r\n\r\n    /** The index of the track where this track entry is either current or queued.\r\n     *\r\n     * See {@link AnimationState#getCurrent()}. */\r\n    trackIndex = 0;\r\n\r\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\r\n     * duration. */\r\n    loop = false;\r\n\r\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\r\n     * of being mixed out.\r\n     *\r\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\r\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\r\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\r\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\r\n     * keys the property, only when a higher track also keys the property.\r\n     *\r\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\r\n     * previous animation. */\r\n    holdPrevious = false;\r\n\r\n    reverse = false;\r\n\r\n    shortestRotation = false;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\r\n     * timelines are not applied while this animation is being mixed out. */\r\n    eventThreshold = 0;\r\n\r\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\r\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\r\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\r\n    attachmentThreshold = 0;\r\n\r\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\r\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\r\n     * so draw order timelines are not applied while this animation is being mixed out. */\r\n    drawOrderThreshold = 0;\r\n\r\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\r\n     *\r\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\r\n     * value to prevent timeline keys before the start time from triggering. */\r\n    animationStart = 0;\r\n\r\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\r\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\r\n    animationEnd = 0;\r\n\r\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\r\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\r\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\r\n     * is applied. */\r\n    animationLast = 0;\r\n\r\n    nextAnimationLast = 0;\r\n\r\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\r\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\r\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\r\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\r\n     *\r\n     * {@link #timeScale} affects the delay. */\r\n    delay = 0;\r\n\r\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\r\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\r\n     * looping. */\r\n    trackTime = 0;\r\n\r\n    trackLast = 0;\r\n    nextTrackLast = 0;\r\n\r\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\r\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\r\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\r\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\r\n     *\r\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\r\n     * abruptly cease being applied. */\r\n    trackEnd = 0;\r\n\r\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\r\n     * faster. Defaults to 1.\r\n     *\r\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\r\n     * match the animation speed.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\r\n     * the time scale is not 1, the delay may need to be adjusted.\r\n     *\r\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\r\n    timeScale = 0;\r\n\r\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\r\n     * to 1, which overwrites the skeleton's current pose with this animation.\r\n     *\r\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\r\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\r\n    alpha = 0;\r\n\r\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\r\n     * slightly more than `mixDuration` when the mix is complete. */\r\n    mixTime = 0;\r\n\r\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\r\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\r\n     *\r\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\r\n     * properties it was animating.\r\n     *\r\n     * The `mixDuration` can be set manually rather than use the value from\r\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\r\n     * track entry only before {@link AnimationState#update(float)} is first called.\r\n     *\r\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\r\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\r\n     * afterward. */\r\n    mixDuration = 0;\r\n    interruptAlpha = 0;\r\n    totalAlpha = 0;\r\n\r\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\r\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\r\n     * the values from the lower tracks.\r\n     *\r\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\r\n     * called. */\r\n    mixBlend = MixBlend.replace;\r\n    timelineMode = new Array<number>();\r\n    timelineHoldMix = new Array<TrackEntry>();\r\n    timelinesRotation = new Array<number>();\r\n\r\n    reset() {\r\n        this.next = null;\r\n        this.previous = null;\r\n        this.mixingFrom = null;\r\n        this.mixingTo = null;\r\n        this.animation = null;\r\n        this.listener = null;\r\n        this.timelineMode.length = 0;\r\n        this.timelineHoldMix.length = 0;\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\r\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\r\n     * `animationStart` time. */\r\n    getAnimationTime() {\r\n        if (this.loop) {\r\n            const duration = this.animationEnd - this.animationStart;\r\n\r\n            if (duration == 0) return this.animationStart;\r\n\r\n            return (this.trackTime % duration) + this.animationStart;\r\n        }\r\n\r\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n    }\r\n\r\n    setAnimationLast(animationLast: number) {\r\n        this.animationLast = animationLast;\r\n        this.nextAnimationLast = animationLast;\r\n    }\r\n\r\n    /** Returns true if at least one loop has been completed.\r\n     *\r\n     * See {@link AnimationStateListener#complete()}. */\r\n    isComplete() {\r\n        return this.trackTime >= this.animationEnd - this.animationStart;\r\n    }\r\n\r\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\r\n     * long way around when using {@link #alpha} and starting animations on other tracks.\r\n     *\r\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\r\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\r\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\r\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\r\n    resetRotationDirections() {\r\n        this.timelinesRotation.length = 0;\r\n    }\r\n\r\n    getTrackComplete() {\r\n        const duration = this.animationEnd - this.animationStart;\r\n\r\n        if (duration != 0) {\r\n            if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\r\n            if (this.trackTime < duration) return duration; // Before duration.\r\n        }\r\n\r\n        return this.trackTime; // Next update.\r\n    }\r\n\r\n    // deprecated stuff\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: Boolean = false;\r\n    private static deprecatedWarning2: Boolean = false;\r\n\r\n    get time() {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\r\n        }\r\n\r\n        return this.trackTime;\r\n    }\r\n\r\n    set time(value: number) {\r\n        if (!TrackEntry.deprecatedWarning1) {\r\n            TrackEntry.deprecatedWarning1 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    get endTime() {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\r\n        }\r\n\r\n        return this.trackTime;\r\n    }\r\n\r\n    set endTime(value: number) {\r\n        if (!TrackEntry.deprecatedWarning2) {\r\n            TrackEntry.deprecatedWarning2 = true;\r\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\r\n        }\r\n        this.trackTime = value;\r\n    }\r\n\r\n    loopsCount() {\r\n        return Math.floor(this.trackTime / this.trackEnd);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class EventQueue {\r\n    objects: Array<any> = [];\r\n    drainDisabled = false;\r\n    animState: AnimationState;\r\n\r\n    constructor(animState: AnimationState) {\r\n        this.animState = animState;\r\n    }\r\n\r\n    start(entry: TrackEntry) {\r\n        this.objects.push(EventType.start);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    interrupt(entry: TrackEntry) {\r\n        this.objects.push(EventType.interrupt);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    end(entry: TrackEntry) {\r\n        this.objects.push(EventType.end);\r\n        this.objects.push(entry);\r\n        this.animState.animationsChanged = true;\r\n    }\r\n\r\n    dispose(entry: TrackEntry) {\r\n        this.objects.push(EventType.dispose);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    complete(entry: TrackEntry) {\r\n        this.objects.push(EventType.complete);\r\n        this.objects.push(entry);\r\n    }\r\n\r\n    event(entry: TrackEntry, event: Event) {\r\n        this.objects.push(EventType.event);\r\n        this.objects.push(entry);\r\n        this.objects.push(event);\r\n    }\r\n\r\n    drain() {\r\n        if (this.drainDisabled) return;\r\n        this.drainDisabled = true;\r\n\r\n        const objects = this.objects;\r\n        const listeners = this.animState.listeners;\r\n\r\n        for (let i = 0; i < objects.length; i += 2) {\r\n            const type = objects[i] as EventType;\r\n            const entry = objects[i + 1] as TrackEntry;\r\n\r\n            switch (type) {\r\n                case EventType.start:\r\n                    if (entry.listener && entry.listener.start) entry.listener.start(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.start) listener.start(entry);\r\n                    }\r\n                    break;\r\n                case EventType.interrupt:\r\n                    if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.interrupt) listener.interrupt(entry);\r\n                    }\r\n                    break;\r\n                case EventType.end:\r\n                    if (entry.listener && entry.listener.end) entry.listener.end(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.end) listener.end(entry);\r\n                    }\r\n                // Fall through.\r\n                case EventType.dispose:\r\n                    if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.dispose) listener.dispose(entry);\r\n                    }\r\n                    this.animState.trackEntryPool.free(entry);\r\n                    break;\r\n                case EventType.complete:\r\n                    if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.complete) listener.complete(entry);\r\n                    }\r\n                    break;\r\n                case EventType.event:\r\n                    const event = objects[i++ + 2] as Event;\r\n\r\n                    if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\r\n                    for (let ii = 0; ii < listeners.length; ii++) {\r\n                        const listener = listeners[ii];\r\n\r\n                        if (listener.event) listener.event(entry, event);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        this.clear();\r\n\r\n        this.drainDisabled = false;\r\n    }\r\n\r\n    clear() {\r\n        this.objects.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport enum EventType {\r\n    start,\r\n    interrupt,\r\n    end,\r\n    dispose,\r\n    complete,\r\n    event,\r\n}\r\n\r\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\r\n * events.\r\n *\r\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\r\n * {@link AnimationState#addListener()}.\r\n * @public\r\n * */\r\nexport interface AnimationStateListener extends IAnimationStateListener {\r\n    /** Invoked when this entry has been set as the current entry. */\r\n    start?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\r\n     * mixing. */\r\n    interrupt?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\r\n    end?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\r\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\r\n    dispose?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked every time this entry's animation completes a loop. */\r\n    complete?: (entry: TrackEntry) => void;\r\n\r\n    /** Invoked when this entry's animation triggers an event. */\r\n    event?: (entry: TrackEntry, event: Event) => void;\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\r\n    start(entry: TrackEntry) {}\r\n\r\n    interrupt(entry: TrackEntry) {}\r\n\r\n    end(entry: TrackEntry) {}\r\n\r\n    dispose(entry: TrackEntry) {}\r\n\r\n    complete(entry: TrackEntry) {}\r\n\r\n    event(entry: TrackEntry, event: Event) {}\r\n}\r\n\r\n/** 1. A previously applied timeline has set this property.\r\n *\r\n * Result: Mix from the current pose to the timeline pose. */\r\nconst SUBSEQUENT = 0;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry applied after this one does not have a timeline to set this property.\r\n *\r\n * Result: Mix from the setup pose to the timeline pose. */\r\nconst FIRST = 1;\r\n/** 1) A previously applied timeline has set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\r\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_SUBSEQUENT = 2;\r\n/** 1) This is the first timeline to set this property.<br>\r\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\r\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\r\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\r\n * that key the same property. A subsequent timeline will set this property using a mix. */\r\nconst HOLD_FIRST = 3;\r\n/** 1. This is the first timeline to set this property.\r\n * 2. The next track entry to be applied does have a timeline to set this property.\r\n * 3. The next track entry after that one does have a timeline to set this property.\r\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\r\n *\r\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\r\n * 2 track entries in a row have a timeline that sets the same property.\r\n *\r\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\r\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\r\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\r\n * place. */\r\nconst HOLD_MIX = 4;\r\n\r\nconst SETUP = 1;\r\nconst CURRENT = 2;\r\n"],"names":["EventType"],"mappings":"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"}